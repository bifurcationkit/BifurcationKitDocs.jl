<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Shooting · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../educational/">Educational introduction</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox" checked/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li><li class="is-active"><a class="tocitem" href>Shooting</a><ul class="internal"><li><a class="tocitem" href="#Standard-Shooting"><span>Standard Shooting</span></a></li><li><a class="tocitem" href="#Poincaré-shooting"><span>Poincaré shooting</span></a></li><li><a class="tocitem" href="#Floquet-multipliers-computation"><span>Floquet multipliers computation</span></a></li><li><a class="tocitem" href="#Computation-with-newton"><span>Computation with <code>newton</code></span></a></li><li><a class="tocitem" href="#Computation-with-newton-and-deflation"><span>Computation with <code>newton</code> and deflation</span></a></li><li><a class="tocitem" href="#Continuation"><span>Continuation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../ANM/">ANM</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-4" type="checkbox"/><label class="tocitem" for="menuitem-7-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../cusp/">Cusp</a></li><li><a class="tocitem" href="../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../bautin/">Bautin</a></li><li><a class="tocitem" href="../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../hh/">Hopf-Hopf</a></li></ul></li><li><span class="tocitem">Normal form (periodic orbits)</span></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../migration/">Migration to v0.2.x</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problems</a></li><li><a class="is-disabled">Periodic Orbits</a></li><li class="is-active"><a href>Shooting</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Shooting</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/periodicOrbitShooting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Periodic-orbits-based-on-the-shooting-method"><a class="docs-heading-anchor" href="#Periodic-orbits-based-on-the-shooting-method">Periodic orbits based on the shooting method</a><a id="Periodic-orbits-based-on-the-shooting-method-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-orbits-based-on-the-shooting-method" title="Permalink"></a></h1><p>A set of shooting algorithms is provided which are called either <em>Simple Shooting (SS)</em> if a single shooting is used and <em>Multiple Shooting (MS)</em> otherwise. For the exposition, we follow the PhD thesis<sup class="footnote-reference"><a id="citeref-Lust" href="#footnote-Lust">[Lust]</a></sup> and also <sup class="footnote-reference"><a id="citeref-Umbria" href="#footnote-Umbria">[Umbria]</a></sup>.</p><p>We aim at finding periodic orbits for the Cauchy problem </p><p class="math-container">\[\tag{1} \frac{d x}{d t}=f(x)\]</p><p>and we write <span>$\phi^t(x_0)$</span> the associated flow (or semigroup of solutions).</p><div class="admonition is-success"><header class="admonition-header">Tip about convenience functions</header><div class="admonition-body"><p>For convenience, we provide some functions <code>plotPeriodicShooting</code> for plotting, <code>getAmplitude</code> (resp. <code>getMaximum</code>) for getting the amplitude (resp. maximum) of the solution encoded by a shooting problem. See the tutorials for examples of use.</p></div></div><h2 id="Standard-Shooting"><a class="docs-heading-anchor" href="#Standard-Shooting">Standard Shooting</a><a id="Standard-Shooting-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Shooting" title="Permalink"></a></h2><h3 id="Simple-shooting"><a class="docs-heading-anchor" href="#Simple-shooting">Simple shooting</a><a id="Simple-shooting-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-shooting" title="Permalink"></a></h3><p>A periodic orbit is found when we have a couple <span>$(x, T)$</span> such that <span>$\phi^T(x) = x$</span> and the trajectory is non constant. Therefore, we want to solve the equations <span>$G(x,T)=0$</span> given by</p><p class="math-container">\[\tag{SS}
\begin{array}{l}{\phi^T(x)-x=0} \\ {s(x,T)=0}\end{array}.\]</p><p>The section <span>$s(x,T)=0$</span> is a phase condition to remove the indeterminacy of the point on the limit cycle.</p><h3 id="Multiple-shooting"><a class="docs-heading-anchor" href="#Multiple-shooting">Multiple shooting</a><a id="Multiple-shooting-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-shooting" title="Permalink"></a></h3><p>This case is similar to the previous one but more sections are used. To this end, we partition the unit interval with <span>$m+1$</span> points <span>$0=s_{0}&lt;s_{1}&lt;\cdots&lt;s_{m-1}&lt;s_{m}=1$</span> and consider the equations <span>$G(x_1,\cdots,x_m,T)=0$</span></p><p class="math-container">\[\begin{aligned}
\phi^{\delta s_1T}(x_{1})-x_{2} &amp;=0 \\ 
\phi^{\delta s_2T}(x_{2})-x_{3} &amp;=0 \\ &amp; \vdots \\ 
\phi^{\delta s_{m-1}T}(x_{m-1})-x_{m} &amp;=0 \\ 
\phi^{\delta s_mT}(x_{m})-x_{1} &amp;=0 \\ s(x_{1}, T) &amp;=0. 
\end{aligned}\tag{MS}\]</p><p>where <span>$\delta s_i:=s_{i+1}-s_i$</span>. The Jacobian of the system of equations <em>w.r.t.</em> <span>$(x,T)$</span> is given by </p><p class="math-container">\[\mathcal{J}=\left(\begin{array}{cc}{\mathcal J_c} &amp; {\partial_TG} \\ {\star} &amp; {d}\end{array}\right)\]</p><p>where the cyclic matrix <span>$\mathcal J_c$</span> is</p><p class="math-container">\[\mathcal J_c := 
\left(\begin{array}{ccccc}
{M_{1}} &amp; {-I} &amp; {} &amp; {} \\ 
{} &amp; {M_{2}} &amp; {-I} &amp; {}\\ 
{} &amp; {} &amp; {\ddots} &amp; {-I}\\ 
{-I} &amp; {} &amp; {} &amp; {M_{m}}\\ 
\end{array}\right)\]</p><p>and <span>$M_i=\partial_x\phi^{\delta s_i T}(x_i)$</span>.</p><h3 id="Section"><a class="docs-heading-anchor" href="#Section">Section</a><a id="Section-1"></a><a class="docs-heading-anchor-permalink" href="#Section" title="Permalink"></a></h3><p>The periodic orbits solutions of (SS) or (MS) are not uniquely defined because of the phase invariance. A section <span>$s(x,T)=0$</span> (resp. <span>$s(x_1,T)=0$</span>) for (SS) (resp. (MS)) must be provided. The default is the same for both $ s(x,T) = T\cdot \langle x-x_\pi, \phi\rangle.$</p><h3 id="Encoding-of-the-functional"><a class="docs-heading-anchor" href="#Encoding-of-the-functional">Encoding of the functional</a><a id="Encoding-of-the-functional-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding-of-the-functional" title="Permalink"></a></h3><p>The functional is encoded in the composite type <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a>. In particular, the user can pass its own time stepper or one can use the different ODE solvers in  <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a> which makes it very easy to choose a solver tailored for the a specific problem. See the link <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> for more information ;  for example on how to access the underlying functional, its jacobian...</p><h2 id="Poincaré-shooting"><a class="docs-heading-anchor" href="#Poincaré-shooting">Poincaré shooting</a><a id="Poincaré-shooting-1"></a><a class="docs-heading-anchor-permalink" href="#Poincaré-shooting" title="Permalink"></a></h2><blockquote><p>The algorithm is based on the one described in <strong>Newton–Krylov Continuation of Periodic Orbits for Navier–Stokes Flows.</strong>, Sánchez, J., M. Net, B. Garcı́a-Archilla, and C. Simó (2004) and <strong>Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems.</strong> Waugh, Iain, Simon Illingworth, and Matthew Juniper (2013). </p></blockquote><p>We look for periodic orbits solutions of (1) using the hyperplanes <span>$\Sigma_i=\{x\ / \ \langle x-x^c_{I}, n_i\rangle=0\}$</span> for <span>$i=1,\cdots,M$</span>, centered on <span>$x^c_i$</span>, which intersect transversally an initial periodic orbit guess. We write <span>$\Pi_i:\Sigma_i\to\Sigma_{mod(i+1,M)}$</span>, the Poincaré return map to <span>$\Sigma_{mod(i+1,M)}$</span>. The main idea of the algorithm is to use the fact that the problem is <span>$(N-1)\cdot M$</span> dimensional if <span>$x_i\in\mathbb R^N$</span> because each <span>$x_i$</span> lives in <span>$\Sigma_i$</span>. Hence, one has to constrain the unknowns to these hyperplanes otherwise the Newton algorithm does not converge well.</p><p>We thus need to parametrize these hyperplanes.</p><p>To this end, we introduce the projection operator <span>$R_i:\mathbb R^N\to \mathbb R^{N-1}$</span> such that </p><p class="math-container">\[R_{i}\left(x_{1}, x_{2}, \ldots, x_{k_i-1}, x_{k_i}, x_{k_i+1}, \ldots, x_{N}\right)=\left(x_{1}, x_{2}, \ldots, x_{k_i-1}, x_{k_i+1}, \ldots, x_{N}\right)\]</p><p>where <span>$k_i:=argmax_p |n_{i,p}|$</span>. The inverse operator <span>$E_i:\mathbb R^{N-1}\to\Sigma_i$</span> is defined by (where <span>$\bar x:=R_i(x)$</span>)</p><p class="math-container">\[E_{i}(\bar x) := E_{i}\left(x_{1}, x_{2}, \ldots, x_{k_i-1}, x_{k_i+1}, \ldots, x_{N}\right)=
\left(x_{1}, x_{2}, \ldots, x_{k_i-1}, x^c_{i,k_i}-\frac{\bar{n}_i \cdot\left(\overline{x}-\overline{x}^c_{i}\right)}{n_{i,k_i}}, x_{k_i+1}, \ldots, x_{N}\right).\]</p><p>We note that <span>$R_i\circ E_i = I_{\mathbb R^{N-1}}$</span> and <span>$E_i\circ R_i = I_{\mathbb R^{N}}$</span>.</p><p>We then look for solutions of the following problem:</p><p class="math-container">\[\begin{aligned} 
\bar x_1 - R_M\Pi_M(E_M(\bar x_M))&amp;=0 \\ 
\bar x_2 - R_1\Pi_1(E_i(\bar x_1))&amp;=0 \\ &amp; \vdots \\ 
\bar x_M - R_{M-1}\Pi_{M-1}(E_{M-1}(\bar x_{M-1}))&amp;=0. 
\end{aligned}\]</p><h3 id="Encoding-of-the-functional-2"><a class="docs-heading-anchor" href="#Encoding-of-the-functional-2">Encoding of the functional</a><a class="docs-heading-anchor-permalink" href="#Encoding-of-the-functional-2" title="Permalink"></a></h3><p>The functional is encoded in the composite type <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. In particular, the user can pass their own time stepper or he can use the different ODE solvers in  <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a> which makes it very easy to choose a tailored solver: the partial Poincaré return maps are implemented using <strong>callbacks</strong>. See the link <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> for more information, in particular on how to access the underlying functional, its jacobian...</p><h2 id="Floquet-multipliers-computation"><a class="docs-heading-anchor" href="#Floquet-multipliers-computation">Floquet multipliers computation</a><a id="Floquet-multipliers-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Floquet-multipliers-computation" title="Permalink"></a></h2><h3 id="Standard-shooting"><a class="docs-heading-anchor" href="#Standard-shooting">Standard shooting</a><a id="Standard-shooting-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-shooting" title="Permalink"></a></h3><p>The Floquet multipliers are computed as the eigenvalues of the monodromy matrix <span>$M=M_M\cdots M_1$</span>.</p><blockquote><p>Unlike the case with <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitTrapeze/">Finite differences</a>, the matrices <span>$M_i$</span> are not sparse.</p></blockquote><h3 id="Poincaré-shooting-2"><a class="docs-heading-anchor" href="#Poincaré-shooting-2">Poincaré shooting</a><a class="docs-heading-anchor-permalink" href="#Poincaré-shooting-2" title="Permalink"></a></h3><p>The (non trivial) Floquet exponents are eigenvalues of the Poincaré return map <span>$\Pi:\Sigma_1\to\Sigma_1$</span>. We have <span>$\Pi = \Pi_M\circ\Pi_{M-1}\circ\cdots\circ\Pi_2\circ\Pi_1$</span>. Its differential is thus</p><p class="math-container">\[d\Pi(x)\cdot h = d\Pi_M(x_{M})d\Pi_{M-1}(x_{M-1})\cdots d\Pi_1(x_1)\cdot h\]</p><h3 id="Numerical-method"><a class="docs-heading-anchor" href="#Numerical-method">Numerical method</a><a id="Numerical-method-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-method" title="Permalink"></a></h3><p>We provide two methods to compute the Floquet coefficients.</p><ul><li>A <strong>not very precise</strong> algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. </li></ul><p>It amounts to computing the eigenvalues of <span>$M=M_M\cdots M_1$</span> (resp. <span>$d\Pi$</span>) for the Standard (resp. Poincaré) Shooting. The method allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at <a href="../library/#BifurcationKit.FloquetQaD"><code>FloquetQaD</code></a>.</p><ul><li>The state of the art method is based on a Periodic Schur decomposition. It is available through the package <a href="https://github.com/bifurcationkit/PeriodicSchurBifurcationKit.jl">PeriodicSchurBifurcationKit.jl</a>. For more information, have a look at <code>FloquetPQZ</code>.</li></ul><h2 id="Computation-with-newton"><a class="docs-heading-anchor" href="#Computation-with-newton">Computation with <code>newton</code></a><a id="Computation-with-newton-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-with-newton" title="Permalink"></a></h2><p>We provide a simplified call to <code>newton</code> to locate the periodic orbit. Have a look at the tutorial <a href="../tutorials/tutorials3b/#Continuation-of-periodic-orbits-(Standard-Shooting)">Continuation of periodic orbits (Standard Shooting)</a> for a simple example on how to use the above methods. </p><p>The docs for this specific <code>newton</code> are located at <a href="../library/#BifurcationKit.newton"><code>newton</code></a>.</p><h2 id="Computation-with-newton-and-deflation"><a class="docs-heading-anchor" href="#Computation-with-newton-and-deflation">Computation with <code>newton</code> and deflation</a><a id="Computation-with-newton-and-deflation-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-with-newton-and-deflation" title="Permalink"></a></h2><p>We also provide a simplified call to <code>newton</code> to locate the periodic orbit with a deflation operator:</p><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newton-Tuple{AbstractShootingProblem, Any, NewtonPar}" href="#BifurcationKit.newton-Tuple{AbstractShootingProblem, Any, NewtonPar}"><code>BifurcationKit.newton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, options)
</code></pre><p>This is the Newton-Krylov Solver for computing a periodic orbit using the (Standard / Poincaré) Shooting method. Note that the linear solver has to be appropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="../library/#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.</p><ul><li><code>prob</code> a problem of type <code>&lt;: AbstractShootingProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit. See <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> and See <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> for information regarding the shape of <code>orbitguess</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <a href="../library/#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div></section></article><p>and</p><pre><code class="nohighlight hljs">newton(prob::BifurcationKit.AbstractShootingProblem,
				orbitguess::vectype,
				defOp::DeflationOperator{Tp, Tdot, T, vectype},
				options::NewtonPar{T, S, E};
				lens::Union{Lens, Nothing} = nothing,
				kwargs...,
			) where {T, Tp, Tdot, vectype, S, E}</code></pre><h2 id="Continuation"><a class="docs-heading-anchor" href="#Continuation">Continuation</a><a id="Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation" title="Permalink"></a></h2><p>Have a look at the <a href="../tutorials/tutorials3b/#Continuation-of-periodic-orbits-(Standard-Shooting)">Continuation of periodic orbits (Standard Shooting)</a> example for the Brusselator.</p><p>In order to plot the orbit during continuation, one has to recompute the orbit inside a <code>plotSolution</code> function passed to <code>continuation</code>. This is simplified by the function <code>getPeriodicOrbit</code> which returns a solution to be plotted. We refer to <a href="../tutorials/ode/tutorialsODE-PD/#Period-doubling-in-Lur&#39;e-problem-(PD-aBS)">Period doubling in Lur&#39;e problem (PD aBS)</a> for an example of use.</p><p>The docs for this specific <code>continuation</code> are located at <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation-Tuple{AbstractShootingProblem, Any, BifurcationKit.AbstractContinuationAlgorithm, ContinuationPar, BifurcationKit.AbstractBorderedLinearSolver}" href="#BifurcationKit.continuation-Tuple{AbstractShootingProblem, Any, BifurcationKit.AbstractContinuationAlgorithm, ContinuationPar, BifurcationKit.AbstractBorderedLinearSolver}"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">continuation(probPO, orbitguess, alg, contParams, linearAlgo)
</code></pre><p>This is the continuation method for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> except that <code>probPO</code> is either a <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Optional arguments</strong></p><ul><li><code>eigsolver</code> specify an eigen solver for the computation of the Floquet exponents, defaults to <code>FloquetQaD</code></li><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Lust"><a class="tag is-link" href="#citeref-Lust">Lust</a><blockquote><p><strong>Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations</strong>, Lust Kurt, 1997. </p></blockquote></li><li class="footnote" id="footnote-Umbria"><a class="tag is-link" href="#citeref-Umbria">Umbria</a><blockquote><p>J. S. Umbría and M. Net. <strong>Numerical continuation methods for large-scale dissipative dynamical systems</strong>. The European Physical Journal Special Topics, 225(13):2465–2486, 2016.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../periodicOrbitCollocation/">« Collocation</a><a class="docs-footer-nextpage" href="../intro_wave/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 27 June 2023 20:46">Tuesday 27 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
