var documenterSearchIndex = {"docs":
[{"location":"bt/#Normal-form-of-the-Bogdanov-Takens-bifurcation","page":"Bogdanov-Takens","title":"Normal form of the Bogdanov-Takens bifurcation","text":"","category":"section"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"We follow the book[Haragus] and consider a Cauchy problem","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"dot x=mathbf F(xp)","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"We denote by mathbf L the jacobian of mathbf F at the bifurcation point (x_0p_0). We choose a basis such that:","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"mathbfL zeta_0=0 quad mathbfL zeta_1=zeta_0","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"We can also select a basis:","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"mathbfL^* zeta_1^*=0 quad mathbfL^* zeta_0^*=zeta_1^*","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"such that","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"leftlanglezeta_0 zeta_0^*rightrangle=1 quadleftlanglezeta_1 zeta_0^*rightrangle=0 quadleftlanglezeta_0 zeta_1^*rightrangle=0 quadleftlanglezeta_1 zeta_1^*rightrangle=1","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"Under some conditions, x(t)approx x_0+A(t)zeta_0 + B(t)zeta_1 where AB satisfy the normal form:","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"beginaligned\nfracd Ad t=B \nfracd Bd t=alpha_1(mu)+alpha_2(mu) A+alpha_3(mu) B+b A B+a A^2widetilderho(A B mu)\nendalignedtagE","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"where p = p_0+mu and with coefficients","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"beginaligned\na=leftlanglemathbfF_20left(zeta_0 zeta_0right) zeta_1^*rightrangle \nb=leftlangle 2 mathbfF_20left(zeta_0 zeta_1right)-2 Psi_200 zeta_1^*rightrangle\nendaligned","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"The Psis satisfy","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"beginaligned\na zeta_1 =mathbfL Psi_200+mathbfF_20left(zeta_0 zeta_0right) \nb zeta_1+2 Psi_200 =mathbfL Psi_110+2 mathbfF_20left(zeta_0 zeta_1right) \nPsi_110 =mathbfL Psi_020+mathbfF_20left(zeta_1 zeta_1right)\nendaligned","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"which gives","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"0=leftlanglePsi_200 zeta_1^*rightrangle + leftlanglemathbfF_20left(zeta_0 zeta_0right) zeta_0^*rightrangle","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"We conclude that","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"beginaligned\na=leftlanglemathbfF_20left(zeta_0 zeta_0right) zeta_1^*rightrangle \nb=2leftlangle  mathbfF_20left(zeta_0 zeta_1right) zeta_1^*rightrangle + 2leftlanglemathbfF_20left(zeta_0 zeta_0right) zeta_0^*rightrangle\nendaligned","category":"page"},{"location":"bt/#Computation-of-the-basis","page":"Bogdanov-Takens","title":"Computation of the basis","text":"","category":"section"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"To build the basis leftzeta_0 zeta_1right, we follow the procedure described in [AlHdaibat] on page 972.","category":"page"},{"location":"bt/#Computation-of-the-parameter-transform","page":"Bogdanov-Takens","title":"Computation of the parameter transform","text":"","category":"section"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"To invert the mapping muto (alpha_1(mu)alpha_2(mu)alpha_3(mu)), we follow the procedure described in [AlHdaibat] on page 956 forward.","category":"page"},{"location":"bt/#Normal-form-computation","page":"Bogdanov-Takens","title":"Normal form computation","text":"","category":"section"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"The normal form (E) can be automatically computed as follows","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"get_normal_form(br::ContResult, ind_bif::Int;\n    ζs = nothing, \n    autodiff = true, \n    detailed = true,\n    kwargs...)","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The option detailed controls the computation of a simplified version of the normal form. autodiff controls the use of ForwardDiff during the normal form computation.","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns an object of type BogdanovTakens.","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"bt/#Predictors","page":"Bogdanov-Takens","title":"Predictors","text":"","category":"section"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the method","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"BifurcationKit.predictor(bt::BifurcationKit.BifurcationKit.BogdanovTakens, ::Val{:HopfCurve}, ds::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"bt/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.BogdanovTakens, Val{:HopfCurve}, T}} where T","page":"Bogdanov-Takens","title":"BifurcationKit.predictor","text":"predictor(bt, , ds; verbose, ampfactor)\n\n\nCompute the predictor for the Hopf curve near the Bogdanov-Takens point.\n\n\n\n\n\n","category":"method"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"BifurcationKit.predictor(bt::BifurcationKit.BogdanovTakens, ::Val{:FoldCurve}, ds::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"bt/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.BogdanovTakens, Val{:FoldCurve}, T}} where T","page":"Bogdanov-Takens","title":"BifurcationKit.predictor","text":"predictor(bt, , ds; verbose, ampfactor)\n\n\nCompute the predictor for the Fold curve near the Bogdanov-Takens point.\n\n\n\n\n\n","category":"method"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"BifurcationKit.predictor(bt::BifurcationKit.BogdanovTakens, ::Val{:HomoclinicCurve}, ds::T; verbose = false, ampfactor = one(T)) where T","category":"page"},{"location":"bt/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.BogdanovTakens, Val{:HomoclinicCurve}, T}} where T","page":"Bogdanov-Takens","title":"BifurcationKit.predictor","text":"predictor(bt, , ds; verbose, ampfactor)\n\n\nCompute the predictor for the curve of homoclinic orbits near the Bogdanov-Takens point.\n\nReference\n\nAl-Hdaibat, B., W. Govaerts, Yu. A. Kuznetsov, and H. G. E. Meijer. “Initialization of Homoclinic Solutions near Bogdanov–Takens Points: Lindstedt–Poincaré Compared with Regular Perturbation Method.” SIAM Journal on Applied Dynamical Systems 15, no. 2 (January 2016): 952–80. https://doi.org/10.1137/15M1017491.\n\n\n\n\n\n","category":"method"},{"location":"bt/#References","page":"Bogdanov-Takens","title":"References","text":"","category":"section"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"[Haragus]: Haragus, Mariana, and Gérard Iooss. Local Bifurcations, Center Manifolds, and Normal Forms in Infinite-Dimensional Dynamical Systems. London: Springer London, 2011. https://doi.org/10.1007/978-0-85729-112-7.","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"[AlHdaibat]: Al-Hdaibat, B., W. Govaerts, Yu. A. Kuznetsov, and H. G. E. Meijer. “Initialization of Homoclinic Solutions near Bogdanov–Takens Points: Lindstedt–Poincaré Compared with Regular Perturbation Method.” SIAM Journal on Applied Dynamical Systems 15, no. 2 (January 2016): 952–80. https://doi.org/10.1137/15M1017491.","category":"page"},{"location":"bt/","page":"Bogdanov-Takens","title":"Bogdanov-Takens","text":"","category":"page"},{"location":"borderedlinearsolver/#Bordered-linear-solvers-(BLS)","page":"Bordered linear solvers","title":"Bordered linear solvers (BLS)","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The bordered linear solvers must be subtypes of AbstractBorderedLinearSolver <: AbstractLinearSolver.","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The methods provided here solve bordered linear equations. More precisely, one is interested in the solution u to Jcdot u = v where","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"tag E J=left(beginarrayll\nA  b \nc^T  d\nendarrayright) text  and  v=left(beginarrayl\nv_1 \nv_2\nendarrayright)","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"Such linear solver bdlsolve will be called like sol, success, itnumber = bdlsolve(A, b, c, d, v1, v2) throughout the package.","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"warning: Complex numbers\nIn the case where cinmathbb C^N, please note that the adjoint operator c^T involves a conjugate.","category":"page"},{"location":"borderedlinearsolver/#Full-matrix-MatrixBLS","page":"Bordered linear solvers","title":"Full matrix MatrixBLS","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"This easiest way to solve (E) is by forming the matrix J. In case it is sparse, it should be relatively efficient. You can create such bordered linear solver using bls = MatrixBLS(ls) where ls::AbstractLinearSolver is a linear solver (which defaults to \\) used to solve the linear problem associated to J. This is the default method used in the package. ","category":"page"},{"location":"borderedlinearsolver/#Bordering-method-BorderingBLS","page":"Bordered linear solvers","title":"Bordering method BorderingBLS","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"The general solution u=left(beginarrayl u_1 \nu_2 endarrayright) to (E) when A is non singular is","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"beginarrayl\nu_2 = frac1d - ccdot x_2(v_2 - ccdot x_1) \nu_1=x_1-u_2x_2\nendarray","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"where x_1=A^-1v_1 x_2=A^-1b. ","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"It is very efficient for large scale problems because it is entirely Matrix-Free and one can use preconditioners. You can create such bordered linear solver using bls = BorderingBLS(ls) where ls::AbstractLinearSolver is a linear solver which defaults to \\. The intermediate solutions x_1=A^-1v_1 x_2=A^-1b are formed using ls.","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"In the case where ls = DefaultLS(), the factorisation of A is cached so the second linear solve is very fast","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"There are more options to BorderingBLS. First, the residual can be checked using the option check_precision = true. If the residual is above a prescribed tolerance, an iterative method is used based on several bordering transformations. This is the BEC+k algorithm in [Govaerts].","category":"page"},{"location":"borderedlinearsolver/#Full-Matrix-Free-MatrixFreeBLS","page":"Bordered linear solvers","title":"Full Matrix-Free MatrixFreeBLS","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"In cases where A is singular but J is not, the bordering method may fail. It can thus be advantageous to form the Matrix-Free version of J and call a generic linear solver to find the solution to (E). You can create such bordered linear solver using bls = MatrixFreeBLS(ls) where ls::AbstractLinearSolver is a (Matrix Free) linear solver which is used to invert J.","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"For now, this linear solver only works with AbstractArray","category":"page"},{"location":"borderedlinearsolver/#References","page":"Bordered linear solvers","title":"References","text":"","category":"section"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"[Govaerts]: Govaerts, W. “Stable Solvers and Block Elimination for Bordered Systems.” SIAM Journal on Matrix Analysis and Applications 12, no. 3 (July 1, 1991): 469–83. https://doi.org/10.1137/0612034.","category":"page"},{"location":"borderedlinearsolver/","page":"Bordered linear solvers","title":"Bordered linear solvers","text":"","category":"page"},{"location":"capabilities/#Overview-of-capabilities","page":"Overview of capabilities","title":"Overview of capabilities","text":"","category":"section"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Pages = [\"capabilities.md\"]\nDepth = 3","category":"page"},{"location":"capabilities/#Main-features","page":"Overview of capabilities","title":"Main features","text":"","category":"section"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Newton-Krylov solver with generic linear / eigen preconditioned solver. Idem for the arc-length continuation.\nNewton-Krylov solver with nonlinear deflation and preconditioner. It can be used for branch switching for example. It is used for deflated continuation.\nContinuation written as an iterator\nMonitoring user functions along curves computed by continuation, see events\nContinuation methods: PALC, Moore Penrose, Multiple, Polynomial, Deflated continuation, ANM, ...\nBifurcation points / events located with bisection\nCompatible with GPU","category":"page"},{"location":"capabilities/#Capabilities-related-to-equilibria","page":"Overview of capabilities","title":"Capabilities related to equilibria","text":"","category":"section"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Detection of Branch, Fold, Hopf bifurcation points of stationary solutions and computation of their normal form.\nAutomatic branch switching at branch points (whatever the dimension of the kernel) to equilibria\nAutomatic computation of bifurcation diagrams of equilibria\nFold / Hopf continuation based on Minimally Augmented formulation, with Matrix Free / Sparse / Dense Jacobian.\nDetection of all codim 2 bifurcations of equilibria and computation of the normal forms of Bogdanov-Takens, Bautin, Cusp, Zero-Hopf. (Hopf-Hopf normal form not implemented)\nBranching from Bogdanov-Takens / Zero-Hopf / Hopf-Hopf points to Fold / Hopf curve","category":"page"},{"location":"capabilities/#(limited)-Capabilities-related-to-maps","page":"Overview of capabilities","title":"(limited) Capabilities related to maps","text":"","category":"section"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"continuation of fixed points of maps\ncomputation of normal form of Period-doubling, Neimark-Sacker, Branch point bifurcations.","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Note that you can combine most solvers, like use Deflation for Periodic orbit computation or Fold of periodic orbits family.","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Custom state means, you can use something else than AbstractArray, for example your own struct.","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Features Matrix Free Custom state Tutorial GPU\n(Deflated) Krylov-Newton Yes Yes link Yes\nContinuation PALC (Natural, Secant, Tangent, Polynomial) Yes Yes All Yes\nDeflated Continuation Yes Yes link Yes\nBifurcation / Fold / Hopf point detection Yes Yes All / All / link Yes\nFold Point continuation Yes Yes PDE, PDE, ODE Yes\nHopf Point continuation Yes AbstractArray ODE \nBranch point / Fold / Hopf normal form Yes Yes  Yes\nBranch switching at Branch points Yes AbstractArray link Yes\nAutomatic bifurcation diagram computation of equilibria Yes AbstractArray link \nBogdanov-Takens / Bautin / Cusp / Zero-Hopf / Hopf-Hopf point detection Yes Yes ODE \nBogdanov-Takens / Bautin / Cusp normal forms Yes AbstractArray ODE Yes\nBranching from Bogdanov-Takens / Zero-Hopf / Hopf-Hopf to Fold / Hopf curve Yes AbstractArray ODE ","category":"page"},{"location":"capabilities/#Capabilities-related-to-Periodic-orbits-(PO)","page":"Overview of capabilities","title":"Capabilities related to Periodic orbits (PO)","text":"","category":"section"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"PO computation and continuation using parallel (Standard or Poincaré) Shooting, Finite Differences or Orthogonal Collocation (mesh adaptive).\nAutomatic branch switching from simple Hopf points to PO\nAutomatic branch switching from simple Period-Doubling points to PO\nAssisted branch switching from simple Branch points to PO\nDetection of Branch, Fold, Neimark-Sacker (NS), Period Doubling (PD) bifurcation points of PO.\nFold / PD / NS continuation based on Minimally Augmented formulation (for shooting and collocation). Trapezoid method only allows continuing Fold of PO.\nDetection of all codim 2 bifurcations of PO (R1, R2, R3, R4, GPD, NS-NS, Chenciner, Fold-Flip, Fold-NS, PD-NS)\nComputation of the normal forms of PD, NS (for shooting and collocation) using the method based on Poincaré return map or the Iooss normal form (more precise).\nautomatic branching from Bautin to curve of Fold of PO\nautomatic branching from Zero-Hopf to curve of NS of PO\nautomatic branching from Hopf-Hopf to curve of NS of PO","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Legend for the table: Standard shooting (SS), Poincaré shooting (PS), Orthogonal collocation (OC), trapezoid (T).","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Features Method Matrix Free Custom state Tutorial GPU\nBranch switching at Hopf points SS/PS/OC/T See each  ODE \nNewton / continuation T Yes AbstractVector PDE, PDE Yes\nNewton / continuation OC  AbstractVector ODE \nNewton / continuation SS Yes AbstractArray ODE Yes\nNewton / continuation PS Yes AbstractArray PDE Yes\nFold, Neimark-Sacker, Period doubling detection SS/PS/OC/T See each AbstractVector link \nBranch switching at Branch point SS/PS/OC/T See each  ODE \nBranch switching at PD point SS/PS/OC/T See each  ODE \nContinuation of Fold points SS/PS/OC/T See each AbstractVector ODE PDE Yes\nContinuation of Period-doubling points SS/OC  AbstractVector ODE \nContinuation of Neimark-Sacker points SS/OC  AbstractVector ODE \ndetection of codim 2 bifurcations of periodic orbits SS/OC  AbstractVector ODE \nBranch switching at Bautin point to curve of Fold of periodic orbits SS/OC  AbstractVector ODE \nBranch switching at ZH/HH point to curve of NS of periodic orbits SS/OC  AbstractVector ODE ","category":"page"},{"location":"capabilities/#Capabilities-related-to-Homoclinic-orbits","page":"Overview of capabilities","title":"Capabilities related to Homoclinic orbits","text":"","category":"section"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"This is available through the plugin HclinicBifurcationKit.jl. Please see the specific docs for more information.","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"compute Homoclinic to Hyperbolic Saddle Orbits (HomHS) using Orthogonal collocation or Standard shooting\ncompute bifurcation of HomHS\nstart HomHS from a direct simulation\nautomatic branch switching to HomHS from Bogdanov-Takes bifurcation point","category":"page"},{"location":"capabilities/#List-of-detected-bifurcations","page":"Overview of capabilities","title":"List of detected bifurcations","text":"","category":"section"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"A left-to-right arrow in the following graph from E_1 to E_2 means that E_2 can be detected when continuing an object of type E_1.","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"A right-to-left arrow from E_2 to E_1 means that we can start the computation of object of type E_1 from E_2.","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"Each object of codim 0 (resp. 1) can be continued with 1 (resp. 2) parameters.","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"graph LR\n    S[  ]\n    C[ Equilibrium ]\n    PO[ Periodic orbit ]\n    BP[ Fold/simple branch point ]\n    H[ Hopf \\n :hopf]\n    CP[Cusp]\n    BT[ Bogdanov-Takens \\n :bt ]\n    ZH[Zero-Hopf \\n :zh]\n    GH[Bautin \\n :gh]\n    HH[Hopf-Hopf \\n :hh]\n    FPO[ Fold Periodic orbit ]\n    NS[ Neimark-Sacker \\n :ns]\n    PD[ Period Doubling \\n :pd ]\n    BPC[BPC]\n    CH[Chenciner \\n :ch]\n    GPD[Generalized period doubling \\n :gpd]\n    BPC[Branch point PO]\n    LPPD[Fold-Flip]\n    LPNS[Fold-NeimarkSacker]\n    R1[1:1 resonance point\\n :R1]\n    R2[1:2 resonance point\\n :R2]\n    R3[1:3 resonance point\\n :R3]    \n    R4[1:4 resonance point\\n :R4]\n\n    S --> C\n    S --> PO\n    C --> nBP[ non simple\\n branch point ]\n    C --> BP\n    C --> H\n\n    BP --> CP\n    BP <--> BT\n\n    PO --> H\n    PO --> FPO\n    PO --> NS\n    PO --> PD\n\n    FPO <--> GH\n    FPO <--> BPC\n    FPO --> R1\n\n    NS --> R1\n    NS --> R3\n    NS --> R4\n    NS --> CH\n    NS --> LPNS\n    NS --> NSNS\n    NS --> R2\n    NS --> PDNS\n\n    PD --> PDNS\n    PD --> R2\n    PD --> LPPD\n    PD --> GPD\n\n    H <--> BT\n    H <--> ZH\n    BP <--> ZH\n    H <--> HH\n    H <--> GH\n    NS <--> ZH\n    PO <--> BPC\n    NS <--> HH\n    FPO --> LPNS\n    FPO --> LPPD\n\n    _ --> Codim0 --> Codim1 --> Codim2","category":"page"},{"location":"capabilities/","page":"Overview of capabilities","title":"Overview of capabilities","text":"","category":"page"},{"location":"migration/#Migration-from-previous-versions","page":"Migration from old versions","title":"Migration from previous versions","text":"","category":"section"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"Pages = [\"migration.md\"]\nDepth = 2","category":"page"},{"location":"migration/#Migration-from-v0.2.x-to-v0.3.x","page":"Migration from old versions","title":"Migration from v0.2.x to v0.3.x","text":"","category":"section"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"A new version v0.3 has been tagged in which the function names, keyword arguments,... follow the Julia convention. There are a lot of breaking changes. For example, callbackN has been changed to callback_newton.","category":"page"},{"location":"migration/#Migration-from-v0.1.x-to-v0.2.x","page":"Migration from old versions","title":"Migration from v0.1.x to v0.2.x","text":"","category":"section"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"New version of the package with modified interface. You are now required to define a BifurcationProblem to perform continuation or bifurcation analysis. You also need to pass your plot/record functions. ","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"The previous interface is available under the tag 0.1.12 which can be installed by doing","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"] add BifurcationKit@0.1.12","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"The new version provides many bugs fix though. (Please note that the docs are up to date).","category":"page"},{"location":"migration/#Don't-use-AD-yourself","page":"Migration from old versions","title":"Don't use AD yourself","text":"","category":"section"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"There is nothing wrong with doing so but this is done in the constructor of BifurcationPoblem, so if myJacAD is the jacobian computed using ForwardDiff, the declaration","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"prob = BifurcationProblem(F, x, p, lens ; J = myJacAD) ","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"should be ","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"prob = BifurcationProblem(F, x, p, lens) ","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"There is nothing wrong in passing your own jacobian though","category":"page"},{"location":"migration/#Error:-no-method-matching-iterate(::BifurcationKit.ContResult","page":"Migration from old versions","title":"Error: no method matching iterate(::BifurcationKit.ContResult","text":"","category":"section"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"This is because you use the old syntax ","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"br, = continuation(...)","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"instead of (no comma)","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"br = continuation(...)","category":"page"},{"location":"migration/#Arguments-to-continuation","page":"Migration from old versions","title":"Arguments to continuation","text":"","category":"section"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"recordFromSolution and plotFromSolution should be passed to BifurcationProblem instead of continuation.","category":"page"},{"location":"migration/","page":"Migration from old versions","title":"Migration from old versions","text":"","category":"page"},{"location":"gettingstarted/#Getting-Started-with-BifurcationKit","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"This tutorial will introduce you to the functionalities for computing bifurcation diagrams and follow branches of solutions.","category":"page"},{"location":"gettingstarted/#Example-1:-solving-the-perturbed-pitchfork-equation","page":"Getting Started with BifurcationKit","title":"Example 1: solving the perturbed pitchfork equation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"In this example, we will solve the equation","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"mu + x-fracx^33=0","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"as function of mu by looking at the solutions in the connected component of (x_0mu_0)approx(-2-1). Here xinmathbb R is the state variable and mu is our parameter. The general workflow is to define a problem, solve the problem, and then analyze the solution. The full code for solving this problem is:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"using BifurcationKit, Plots\nF(x, p) = @. p.μ + x - x^3/3\nprob = BifurcationProblem(F, [-2.], (μ = -1.,), (@lens _.μ);\n        record_from_solution = (x,p) -> (x = x[1]))\nbr = continuation(prob, PALC(), ContinuationPar(p_min = -1., p_max = 1.))\nplot(br)\nscene = plot(br) #hide","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"where the pieces are described below.","category":"page"},{"location":"gettingstarted/#Step-1:-Defining-a-problem","page":"Getting Started with BifurcationKit","title":"Step 1: Defining a problem","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"To solve this numerically, we define a problem type by giving it the equation, the initial condition, the parameters and the parameter axis to solve over:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"using BifurcationKit\nF(x, p) = @. p.μ + x - x^3/3\nprob = BifurcationProblem(F, [-2.], (μ = -1.,), (@lens _.μ);\n        record_from_solution = (x,p) -> (x = x[1]))","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"Note that BifurcationKit.jl will choose the types for the problem based on the types used to define the problem type. For our example, notice that u0 is a Vector{Float64}, and therefore this will solve with the dependent variables being Vector{Float64}. You can use this to choose to solve with Float32 for example to run this on the GPU (see example).","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"You can customize a few scalar indicators for each step (for example if you don't want to save all solutions) by providing a function record_from_solution. You can also control how the solution is plotted during a continuation run by providing a function plot_solution. This is especially useful when studying PDE for example.","category":"page"},{"location":"gettingstarted/#Step-2:-Solving-a-problem","page":"Getting Started with BifurcationKit","title":"Step 2: Solving a problem","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"After defining a problem, you \"solve\" it using continuation.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"br = continuation(prob, PALC(), ContinuationPar(p_min = -1., p_max = 1.))\nnothing #hide","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"The solvers can be controlled using the available options ContinuationPar. For example, we can increase the maximum continuation step (in order to get a less points) by using the command dsmax = 0.25","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"using Plots\nopts = ContinuationPar(p_min = -1., p_max = 1., dsmax = 0.25, max_steps = 1000)\nbr = continuation(prob, PALC(), opts)\nscene = plot(br)","category":"page"},{"location":"gettingstarted/#Choosing-a-continuation-algorithm","page":"Getting Started with BifurcationKit","title":"Choosing a continuation algorithm","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"BifurcationKit.jl offers a much wider variety of continuation algorithms than traditional continuation softwares. Many of these algorithms are from recent research and have their own strengths and weaknesses. Each algoritm comes with a doc string, for example:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"PALC","category":"page"},{"location":"gettingstarted/#BifurcationKit.PALC","page":"Getting Started with BifurcationKit","title":"BifurcationKit.PALC","text":"struct PALC{Ttang<:BifurcationKit.AbstractTangentComputation, Tbls<:BifurcationKit.AbstractLinearSolver, T, Tdot} <: BifurcationKit.AbstractContinuationAlgorithm\n\nPseudo-arclength continuation algorithm.\n\nAdditional information is available on the website.\n\nFields\n\ntangent::BifurcationKit.AbstractTangentComputation: Tangent predictor, must be a subtype of AbstractTangentComputation. For example Secant() or Bordered(),  Default: Secant()\nθ::Any: θ is a parameter in the arclength constraint. It is very important to tune it. It should be tuned for the continuation to work properly especially in the case of large problems where the < x - x0, dx0 > component in the constraint equation might be favoured too much. Also, large thetas favour p as the corresponding term in N involves the term 1-theta. Default: 0.5\n_bothside::Bool: [internal],  Default: false\nbls::BifurcationKit.AbstractLinearSolver: Bordered linear solver used to invert the jacobian of the newton bordered problem. It is also used to compute the tangent for the predictor Bordered(),  Default: MatrixBLS()\ndotθ::Any: dotθ = DotTheta(), this sets up a dot product (x, y) -> dot(x, y) / length(x) used to define the weighted dot product (resp. norm) (x p)^2_theta in the constraint N(x p) (see online docs on PALC). This argument can be used to remove the factor 1/length(x) for example in problems where the dimension of the state space changes (mesh adaptation, ...) Default: DotTheta()\n\n\n\n\n\n","category":"type"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"For example, you can chose a different tangent predictor in PALC","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"opts = ContinuationPar(p_min = -1., p_max = 1.)\nbr = continuation(prob, PALC(tangent = Bordered()), opts)\nscene = plot(br)","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"or you can use the Moore-Penrose continuation algorithm","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"opts = ContinuationPar(p_min = -1., p_max = 1.)\nbr = continuation(prob, MoorePenrose(), opts)\nscene = plot(br)","category":"page"},{"location":"gettingstarted/#Step-3:-Analyzing-the-solution","page":"Getting Started with BifurcationKit","title":"Step 3: Analyzing the solution","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"The result of continuation is a solution object. A summary of the result is provided by the show method:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"show(br) # this is equivalent to the REPL julia> br","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"From there, you can see that the branch has 55 points, the algorithm is also recalled because it can be modified internally. This summary shows that two bifurcation points where detected. At each such point, the couple δ indicates how many real/complex eigenvalues crossed the imaginary axis. This is useful for debugging or when non generic bifurcations are encountered.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"We can access the 5th value of the branch with:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"br[5]","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"The solution contains many other fields:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"propertynames(br)","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"Hence, the eigenelements are saved in br.eig, the solutions are saved in br.sol and the bifurcation points in br.specialpoint.","category":"page"},{"location":"gettingstarted/#Plotting-branches","page":"Getting Started with BifurcationKit","title":"Plotting branches","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"While one can directly plot solution time points using the tools given above, convenience commands are defined by recipes for Plots.jl. To plot the solution object, simply call plot:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"#]add Plots # You need to install Plots.jl before your first time using it!\nusing Plots\n#plotly() # You can optionally choose a plotting backend\nplot(br)\nscene = plot(br) #hide","category":"page"},{"location":"gettingstarted/#Example-2:-simple-branching","page":"Getting Started with BifurcationKit","title":"Example 2: simple branching","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"In this example, we will solve the equation","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"0 = xcdot(mu-x)","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"as function of mu. Here uinmathbb R is the state variable and mu is our parameter.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"In our example, we know by calculus that the solutions to this equation are u_0(mu)=0 and u_1(mu)=mu but we will use BifurcationKit.jl to solve this problem numerically, which is essential for problems where a symbolic solution is not known.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"In case we know there are many branches, the best is to use an automatic method to compute them all. We will focus on bifurcationdiagram which computes the connected component of the initial guess in the plane (xmu). An alternative is to use Deflated Continuation.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"We define a problem type by giving it the equation, the initial condition, the parameters and the parameter axis to solve over:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"using Plots\nusing BifurcationKit\n\nFbp(u, p) = @. u * (p.μ - u)\n\n# bifurcation problem\nprob = BifurcationProblem(Fbp, [0.0], (μ = -0.2,),\n\t# specify the continuation parameter\n\t(@lens _.μ), \n\trecord_from_solution = (x, p) -> x[1])","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"We then aim at calling bifurcationdiagram which will do the jobs of computing recursively the branches which are connected together. Compared to continuation, bifurcationdiagram requires the maximal level of recursion (in this case 2 because there are 2 branches) and a function providing the continuation parameters for each branch (which may differ from branch to branch if the user decides). This explains the following code: ","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"# options for continuation\nopts_br = ContinuationPar(\n\t# parameter interval\n\tp_max = 0.2, p_min = -0.2,\n\t# detect bifurcations with bisection method\n\t# we increase the precision of the bisection\n\tn_inversion = 4)\n\n# automatic bifurcation diagram computation\ndiagram = bifurcationdiagram(prob, PALC(),\n\t# very important parameter. This specifies the maximum amount of recursion\n\t# when computing the bifurcation diagram. It means we allow computing branches of branches\n\t# at most in the present case.\n\t2,\n\t(args...) -> opts_br,\n\t)","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"You can plot the diagram like","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"plot(diagram)","category":"page"},{"location":"gettingstarted/#gt-hopf","page":"Getting Started with BifurcationKit","title":"Example 3: continuing periodic orbits","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"In this example, we will compute periodic orbits of the Stuart-Landau oscillator:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"beginaligned\nfracdudt = r  u - nu v - (u^2+v^2)  (c_3  u - mu v) \nfracdvdt = r  v + nu u - (u^2+v^2)  (c_3 + mu  u)\nendaligned","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"The ODE is easily written with a function:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"using BifurcationKit, Parameters, Plots\n\nfunction Fsl(X, p)\n    @unpack r, μ, ν, c3 = p\n    u, v = X\n    ua = u^2 + v^2\n    [\n        r * u - ν * v - ua * (c3 * u - μ * v)\n        r * v + ν * u - ua * (c3 * v + μ * u)\n    ]\nend","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"and then we can use this to define a bifurcation problem:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"par_sl = (r = 0.1, μ = 0., ν = 1.0, c3 = 1.0)\nu0 = zeros(2)\nprob = BifurcationProblem(Fsl, u0, par_sl, (@lens _.r))","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"For this simple problem, we detect the existence of periodic orbits by locating a Hopf bifurcation. This is done as in the previous example by continuing the zero solution:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"br = continuation(prob, PALC(), ContinuationPar(), bothside = true)","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"In the result above, we see that a Hopf bifurcation has been detected: ","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"- #  2,     hopf at r ≈ -0.00595553 ∈ (-0.00595553,...","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"We compute the branch of periodic orbits which is nearby. We thus provide the branch br, the index of the special point we want to branch from: 2 in this case and a method PeriodicOrbitOCollProblem(20, 5) to compute periodic orbits. You can look at Periodic orbits computation for a list of all methods. Suffice it to say that PeriodicOrbitOCollProblem is the default method in the case of ODEs.","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"br_po = continuation(br, 2, ContinuationPar(),\n        PeriodicOrbitOCollProblem(20, 5)\n        )","category":"page"},{"location":"gettingstarted/#Analyzing-the-solution","page":"Getting Started with BifurcationKit","title":"Analyzing the solution","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"The branch of periodic orbits has been computed. You can look at what is recorded in the first point on the branch:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"br_po[1]","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"It shows that the maximum/minimum/amplitude/period of the periodic orbit are recorded by default. You can also plot all the branches as follows","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"plot(br, br_po, branchlabel = [\"equilibria\", \"periodic orbits\"])","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"Finally, if you are interested in the periodic orbits saved in br_po, for example to plot it, the method get_periodic_orbit is what you are looking for:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"sol = get_periodic_orbit(br_po, 10)\nplot(sol.t, sol[1,:], label = \"u\", xlabel = \"time\")\nplot!(sol.t, sol[2,:], label = \"v\", xlabel = \"time\")","category":"page"},{"location":"gettingstarted/#Plotting-the-periodic-orbit-during-continuation","page":"Getting Started with BifurcationKit","title":"Plotting the periodic orbit during continuation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"If you plot the solution during continuation, you see that the right bottom panel is empty ; this panel is used to plot the solution at the current continuation step:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"br_po = continuation(br, 2, opts,\n        PeriodicOrbitOCollProblem(20, 5);\n        plot = true,\n        )\nscene = title!(\"\") #hide","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"(Note that the bottom panel is a plot of the eigenvalues of the jacobian in the complex plane at the current continuation step. )","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"In order to plot the periodic solution during continuation, you need to supply a periodic_solution to continuation. This is not done by default because in some cases, obtaining the solution is costly (e.g. for Shooting methods). Based on the previous paragraph, it is straightforward to implement this plotting function:","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"br_po = continuation(br, 2, opts,\n        PeriodicOrbitOCollProblem(20, 5);\n        plot = true,\n        plot_solution = (x, par; k...) -> begin\n                # par is a Named tuple which contains \n                # the problem for computing periodic orbits\n                # and the value of the parameter at the current step\n                sol = get_periodic_orbit(par.prob, x, par.p)\n                plot!(sol.t, sol.u'; xlabel = \"time\", label=\"\", k...)\n        end\n        )\nscene = title!(\"\") #hide","category":"page"},{"location":"gettingstarted/","page":"Getting Started with BifurcationKit","title":"Getting Started with BifurcationKit","text":"","category":"page"},{"location":"interfaceFlow/#Interface-for-Flow-of-Cauchy-problem","page":"Flow","title":"Interface for Flow of Cauchy problem","text":"","category":"section"},{"location":"interfaceFlow/","page":"Flow","title":"Flow","text":"Here is a description of the interface that is used to specify flows or semigroups of solutions of a Cauchy problem fracdudt = F(u p)quad u(0) = u_0","category":"page"},{"location":"interfaceFlow/","page":"Flow","title":"Flow","text":"More precisely, we call flow the mapping Flow(x p t) = u(t).","category":"page"},{"location":"interfaceFlow/","page":"Flow","title":"Flow","text":"The flow fl must be a subtype of the abstract type AbstractFlow. Note that in most cases, we only need u(t). However, for plotting, we need optionally the full trajectory with time stamps in 0T.","category":"page"},{"location":"interfaceFlow/","page":"Flow","title":"Flow","text":"Another point is the need for implementing serial versions of multithreaded flows.","category":"page"},{"location":"interfaceFlow/","page":"Flow","title":"Flow","text":"Required methods Brief description\nvf(fl, x, p) The vector field F(x, p) associated to a Cauchy problem. Used for the differential of the shooting problem. Must return F(x, p)\nevolve(fl, x, par, t; k...) the function implements the flow (or semigroup) (x, p, t) -> flow(x, p, t) associated to an autonomous Cauchy problem. Only the last time point must be returned in the form Named Tuple (u = ..., t = t). In the case of Poincaré Shooting, one must be able to call the flow like evolve(fl, x, par, Inf).\nOptional methods Brief description\nevolve(fl, x, par, t; k...) Same as above but for t::AbstractVector of some length M and x a matrix of size N x M. In this case, you are asked to compute several flows flow(x[:, i],p,t[i]). This can be done in parallel.\nevolve(fl, x, par, dx, t; k...) The differential dflow of the flow w.r.t. x, (x, p, dx, t) -> dflow(x, p, dx, t). One important thing is that we require dflow(x, dx, t) to return a Named Tuple: (t = t, u = flow(x, p, t), du = dflow(x, p, dx, t)), the last component being the value of the derivative of the flow.\nevolve(fl, ::Val{:Full}, x, par, t; k...) The function implements the flow (or semigroup) associated to an autonomous Cauchy problem (x, p, t) -> flow(x, p, t). The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, it is mainly used for plotting on the user side. In the case of Poincaré Shooting, one must be able to call the flow like evolve(fl, Val(:Full), x, par, Inf).\nevolve(fl, ::Val{:SerialTimeSol}, x, par, t; k...) Serial version of the flow. Used for Matrix based jacobian (Shooting and Poincaré Shooting) and diffPoincareMap\nevolve(fl, ::Val{:TimeSol}, x, par, t = Inf; k...) Flow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side.\nevolve(fl, ::Val{:SerialdFlow}, x, par, dx, t; k...) Serial version of dflow. Used internally when using parallel multiple shooting. Named Tuple (u = ..., du = ..., t = t).","category":"page"},{"location":"interfaceFlow/","page":"Flow","title":"Flow","text":"","category":"page"},{"location":"deflatedproblem/#Deflated-problems","page":"Deflated problems","title":"Deflated problems","text":"","category":"section"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"unknown: References\nP. E. Farrell, A. Birkisson, and S. W. Funke. Deflation techniques for finding distinct solutions of nonlinear partial differential equations. SIAM J. Sci. Comput., 2015.,","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"Assume you want to solve F(x)=0 with a Newton algorithm but you want to avoid the algorithm to return some already known solutions x_i i=1cdots n.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"The idea proposed in the paper quoted above is to penalize these solutions by looking for the zeros of the function G(x)=F(x)M(x) where","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"M(x) = prod_i=1^nleft(x - x_i^-2p + alpharight)","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"and alpha0. Obviously F and G have the same zeros away from the x_is but the factor M penalizes the residual of the Newton iterations of G, effectively producing zeros of F different from x_i.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"tip: Tip\nIn some case, you may want to use a custom distance, in place of the squared norm cdot^2. Please see DeflationOperator for how to do this.","category":"page"},{"location":"deflatedproblem/#Encoding-of-the-functional","page":"Deflated problems","title":"Encoding of the functional","text":"","category":"section"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"A composite type DeflationOperator implements this functional. Given a deflation operator M = DeflationOperator(p, dot, α, xis), you can build a deflated functional pb = DeflatedProblem(F, J, M) which you can use to access the values of G by doing pb(x). A Matrix-Free / Sparse linear solver is implemented which works on the GPU.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"the dot argument in DeflationOperator lets you specify a dot product from which the norm is derived in the expression of M.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"See example Snaking computed with deflation.","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"Note that you can add new solution x0 to M by doing push!(M, x0). Also M[i] returns xi.","category":"page"},{"location":"deflatedproblem/#Computation-with-newton","page":"Deflated problems","title":"Computation with newton","text":"","category":"section"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"Most newton functions can be used with a deflated problem, see for example Snaking computed with deflation. The idea is to pass the deflation operator M. For example, we have the following overloaded method, which works on GPUs:","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"newton(prob::BifurcationKit.AbstractBifurcationProblem,\n\t\tdefOp::DeflationOperator,\n\t\toptions::NewtonPar,\n\t\t_linsolver = DefProbCustomLinearSolver();\n\t\tkwargs...)","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"We refer to the regular newton for more information. This newton penalises the roots saved in defOp.roots. ","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"Compared to newton, the only different arguments are","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"defOp::DeflationOperator deflation operator\nlinsolver linear solver used to invert the Jacobian of the deflated functional.\ncustom solver DefProbCustomLinearSolver() with requires solving two linear systems J⋅x = rhs.\nFor other linear solvers <: AbstractLinearSolver, a matrix free method is used for the deflated functional.\nif passed Val(:autodiff), then ForwardDiff.jl is used to compute the jacobian of the deflated problem\nif passed Val(:fullIterative), then a full matrix free method is used.","category":"page"},{"location":"deflatedproblem/#Simple-example","page":"Deflated problems","title":"Simple example","text":"","category":"section"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"In this basic example, we show how to get the different roots of F","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"using BifurcationKit, LinearAlgebra\nF(x, p) = @. (x-1) * (x-2)\n# define a deflation operator which deflates the \n# already know solution x = 1\ndeflationOp = DeflationOperator(2, dot, 0.1, [ones(1)])\n# define a problem, this compute jacobian automatically\nprob = BifurcationProblem(F, zeros(1), nothing)\n# call deflated newton\nsol = newton(prob, deflationOp, NewtonPar())\nif BifurcationKit.converged(sol)\n    println(\"We found the additional root: \", sol.u)\nelse\n    println(\"Deflated newton did not converge!\")\nend","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"tip: Tip\nYou can use this method for periodic orbits as well by passing the deflation operator M to the newton method","category":"page"},{"location":"deflatedproblem/","page":"Deflated problems","title":"Deflated problems","text":"","category":"page"},{"location":"BifProblem/#Bifurcation-problems","page":"Bifurcation Problem","title":"Bifurcation problems","text":"","category":"section"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"Pages = [\"BifProblem.md\"]\nDepth = 3","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"The idea behind BifurcationKit is to compute bifurcation diagrams in memory limited environments where the device can barely hold the current continuation state. We thus disable by default saving all solutions along the branch and all eigenvectors (see ContinuationPar to change this behaviour). Still, one needs to save a few solution indicators, like for plotting. This is the reason for the function record_from_solution (see below).","category":"page"},{"location":"BifProblem/#Generic-bifurcation-problem","page":"Bifurcation Problem","title":"Generic bifurcation problem","text":"","category":"section"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"BifurcationProblem is the basic / generic structure for encoding a bifurcation problem ; it holds the following fields:","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"the vector field\nan initial guess\na set of parameters\na parameter axis","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"as well as user defined functions for ","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"plotting, plot_solution\nrecording (record_from_solution) indicators about the solution when this one is too large to be saved at every continuation step.","category":"page"},{"location":"BifProblem/#Example","page":"Bifurcation Problem","title":"Example","text":"","category":"section"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"f(x,p) = @. sin(x * p.a)\nu0 = zeros(100_000_000) \nparams = (a = 1.0, b = 2.0)\n\n# record a few components / indicators about x \nmyRecord(x,p) = (x1 = x[1], max = maximum(x), nrm = norm(x, Inf))\n\nprob = BifurcationProblem(f, u0, p, (@lens _.a);\n\trecord_from_solution = myRecord\n\t)","category":"page"},{"location":"BifProblem/#Problem-modification","page":"Bifurcation Problem","title":"Problem modification","text":"","category":"section"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"In case you want to modify an existing problem, you should use the following method","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"re_make(prob::BifurcationKit.AbstractBifurcationProblem;\n\t\tu0 = prob.u0,\n\t\tparams = prob.params,\n\t\tlens::Lens = prob.lens,\n\t\trecord_from_solution = prob.record_from_solution,\n\t\tplot_solution = prob.plot_solution,\n       J = missing,\n       d2F = missing,\n\t\td3F = missing)","category":"page"},{"location":"BifProblem/#BifurcationKit.re_make-Tuple{BifurcationKit.AbstractBifurcationProblem}","page":"Bifurcation Problem","title":"BifurcationKit.re_make","text":"re_make(\n    prob;\n    u0,\n    params,\n    lens,\n    record_from_solution,\n    plot_solution,\n    J,\n    Jᵗ,\n    d2F,\n    d3F\n)\n\n\nThis function changes the fields of a problem ::AbstractBifurcationProblem. For example, you can change the initial condition by doing\n\nre_make(prob; u0 = new_u0)\n\n\n\n\n\n","category":"method"},{"location":"BifProblem/#Example-2","page":"Bifurcation Problem","title":"Example","text":"","category":"section"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"using BifurcationKit, Setfield\nF(x,p) = @. p.a + x^2\n# parameters\npar = (a = 0., b = 2)\nprob = BifurcationProblem(F, zeros(3), par, (@lens _.a))\n# change u0\nprob2 = BifurcationKit.re_make(prob, u0 = rand(3))","category":"page"},{"location":"BifProblem/","page":"Bifurcation Problem","title":"Bifurcation Problem","text":"","category":"page"},{"location":"periodicOrbitCollocation/#Periodic-orbits-based-on-orthogonal-collocation","page":"Collocation","title":"Periodic orbits based on orthogonal collocation","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"Pages = [\"periodicOrbitCollocation.md\"]\nDepth = 3","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We compute Ntst time slices of a periodic orbit using orthogonal collocation. This is implemented in the structure PeriodicOrbitOCollProblem.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"tip: Large scale\nThe current implementation is optimized for ODE and for large scale problems for which the jacobian is sparse.     ","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The general method is very well exposed in [Dankowicz],[Doedel] and we adopt the notations of [Dankowicz]. However our implementation is based on [Doedel] because it is more economical (less equations) when it enforces the continuity of the solution.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We look for periodic orbits as solutions (x(0) T) of","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"dot x = Tcdot F(x) x(0)=x(1)inmathbb R^n","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We focus on the differential equality and consider a partition of the time domain","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"0=tau_1cdotstau_jcdotstau_N_tst+1=1","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"where the points are referred to as mesh points. On each mesh interval tau_jtau_j+1 for j=1cdotsN_tst, we define the affine transformation","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"tau=tau^(j)(sigma)=tau_j+frac(1+sigma)2left(tau_j+1-tau_jright) sigma in-11","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The functions x^(j) defined on -11 by x^(j)(sigma) equiv x(tau_j(sigma)) satisfies the following equation on -11:","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"dot x^(j) = Tfractau_j+1-tau_j2cdot F(x^(j))tagE_j","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"with the continuity equation x^(j+1)(-1) = x^(j)(1).","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We now aim at  solving (E_j) by using an approximation with a polynomial of degree m. Following [Dankowicz], we define a (uniform) partition:","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"-1=sigma_1cdotssigma_icdotssigma_m+1=1","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The points tau_ij = tau^(i)(sigma_j) are called the base points: they serve as collocation points.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The associated m+1 Lagrange polynomials of degree m are:","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"mathcalL_i(sigma)=prod_k=1 k neq i^m+1 fracsigma-sigma_ksigma_i-sigma_k i=1 ldots m+1","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We then introduce the approximation p_j of x^(j):","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"mathcal p_j(sigma)equiv sumlimits_k=1^m+1mathcal L_k(sigma)x_jk","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"and the problem to be solved at the nodes z_l, l=1cdotsm:","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"forall 1leq lleq mquad 1leq jleq N_tstquad dot p_j(z_l) = Tfractau_j+1-tau_j2cdot F(p_j(z_l))tagE_j^2","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The nodes (z_l) are associated with a Gauss–Legendre quadrature.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"In order to have a unique solution, we need to remove the phase freedom. This is done by imposing a phase condition.","category":"page"},{"location":"periodicOrbitCollocation/#Number-of-unknowns","page":"Collocation","title":"Number of unknowns","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"Putting the period unknown aside, we have to find the x_jk which gives ntimes N_tsttimes (m+1) unknowns. ","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The equations E_j^2 provides ntimes N_tsttimes m plus the (N_tst-1)times n equations for the continuity equations. This makes a total of (N_tst-1)times mtimes n+ntimes N_tsttimes m = nN_tst(m+1)-1 equations to which we add the n equations for the periodic boundary condition. In total, we have","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"ntimes N_tsttimes (m+1)","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"equations which matches the number of unknowns.","category":"page"},{"location":"periodicOrbitCollocation/#Phase-condition","page":"Collocation","title":"Phase condition","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"To ensure uniqueness of the solution to the functional, we use the following phase condition","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"frac1T int_0^Tleftlangle x(s) dot x_0(s)rightrangle d s =0","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"During continuation at step k, we use frac1T int_0^Tleftlangle x(s) dot x_k-1(s)rightrangle d s","category":"page"},{"location":"periodicOrbitCollocation/#Discretization-of-the-BVP-and-jacobian","page":"Collocation","title":"Discretization of the BVP and jacobian","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We only focus on the differential part. Summing up, we obtained the following equations for the x_jlinmathbb R^n:","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"sumlimits_k=1^m+1mathcal L_k(z_l)x_jk = Fleft(sumlimits_k=1^m+1mathcal L_k(z_l)x_jkright)","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The jacobian in the case m=2 is given by: ","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"beginarrayllllllll\nx_00  x_01  x_10  x_11  x_20  x_21  x_30 quad mathbfT\nendarray\n\nleft(beginarrayllllllll\nH_00^0  H_01^0  H_10^0      * \nH_00^1  H_01^1  H_10^1      * \n  H_10^0  H_11^0  H_20^0    * \n  H_10^1  H_11^1  H_20^1    * \n    H_20^0  H_21^0  H_30^0  * \n    H_20^1  H_21^1  H_30^1  * \n       * \nI       -I  * \n*  *  *  *  *  *  *  *\nendarrayright)","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"where","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"H_kl^l_2 = mathcal L_l_2lcdot I_n - Tfractau_j+1-tau_j2cdotmathcal L_l_2lcdot dFleft(x_klright)inmathbb R^n","category":"page"},{"location":"periodicOrbitCollocation/#Interpolation","page":"Collocation","title":"Interpolation","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"BifurcationKit.POSolution","category":"page"},{"location":"periodicOrbitCollocation/#BifurcationKit.POSolution","page":"Collocation","title":"BifurcationKit.POSolution","text":"Structure to encode the solution associated to a functional like ::PeriodicOrbitOCollProblem or ::ShootingProblem. In the particular case of ::PeriodicOrbitOCollProblem, this allows to use the collocation polynomials to interpolate the solution. Hence, if sol::POSolution, one can call\n\nsol = BifurcationKit.POSolution(prob_coll, x)\nsol(t)\n\non any time t.\n\n\n\n\n\n","category":"type"},{"location":"periodicOrbitCollocation/#Mesh-adaptation","page":"Collocation","title":"Mesh adaptation","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The goal of this method[Russell] is to adapt the mesh tau_i in order to minimize the error. It is particularly helpful near homoclinic solutions where the period diverge. It can also be useful in order to use a smaller N_tst.","category":"page"},{"location":"periodicOrbitCollocation/#Encoding-of-the-functional","page":"Collocation","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The functional is encoded in the composite type PeriodicOrbitOCollProblem. See the link for more information, in particular on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitCollocation/#Jacobian-and-linear-solvers","page":"Collocation","title":"Jacobian and linear solvers","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We provide many different linear solvers to take advantage of the formulations or the dimensionality. These solvers are available through the argument jacobian in the constructor of PeriodicOrbitOCollProblem. For example, you can pass jacobian  = FullSparse(). Note that all the internal linear solvers and jacobians are set up automatically so you don't need to do anything. However, for the sake of explanation, we detail how this works.\t","category":"page"},{"location":"periodicOrbitCollocation/#1.-DenseAnalytical()","page":"Collocation","title":"1. DenseAnalytical()","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The jacobian is computed with an analytical formula, works for dense matrices. This is the default algorithm.","category":"page"},{"location":"periodicOrbitCollocation/#2.-AutoDiffDense()","page":"Collocation","title":"2. AutoDiffDense()","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The jacobian is computed with automatic differentiation, works for dense matrices. Can be used for debugging.","category":"page"},{"location":"periodicOrbitCollocation/#3.-FullSparse()","page":"Collocation","title":"3. FullSparse()","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The jacobian is computed with an analytical formula, works for sparse matrices.","category":"page"},{"location":"periodicOrbitCollocation/#3.-FullSparseInplace()","page":"Collocation","title":"3. FullSparseInplace()","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The sparse jacobian is computed in place, limiting memory allocations, with an analytical formula when the sparsity of the jacobian of the vector field is constant. This is much faster than FullSparse().","category":"page"},{"location":"periodicOrbitCollocation/#Floquet-multipliers-computation","page":"Collocation","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We provide two methods to compute the Floquet coefficients.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The algorithm (Default) FloquetColl is based on the condensation of parameters described in [Doedel]. It is the fastest method.\nThe algorithm FloquetCollGEV is a simplified version of the procedure described in [Fairgrieve]. It boils down to solving a large generalized eigenvalue problem. There is clearly room for improvements here but this can be used to check the results of the previous method.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"These methods allow to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. However they may be imprecise[Lust].","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The state of the art method is based on a Periodic Schur decomposition. It is available through the package PeriodicSchurBifurcationKit.jl. For more information, have a look at FloquetPQZ.","category":"page"},{"location":"periodicOrbitCollocation/#Computation-with-newton","page":"Collocation","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"newton(prob::PeriodicOrbitOCollProblem, orbitguess, options::NewtonPar; kwargs...)","category":"page"},{"location":"periodicOrbitCollocation/#BifurcationKit.newton-Tuple{PeriodicOrbitOCollProblem, Any, NewtonPar}","page":"Collocation","title":"BifurcationKit.newton","text":"newton(probPO, orbitguess, options; kwargs...)\n\n\nThis is the Newton Solver for computing a periodic orbit using orthogonal collocation method. Note that the linear solver has to be apropriately set up in options.\n\nArguments\n\nSimilar to newton except that prob is a PeriodicOrbitOCollProblem.\n\nprob a problem of type <: PeriodicOrbitOCollProblem encoding the shooting functional G.\norbitguess a guess for the periodic orbit.\noptions same as for the regular newton method.\n\nOptional argument\n\njacobian Specify the choice of the linear algorithm, which must belong to (AutoDiffDense(), ). This is used to select a way of inverting the jacobian dG\nFor AutoDiffDense(). The jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using options. The jacobian is formed inplace.\nFor DenseAnalytical() Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\n\n\n\n\n\n","category":"method"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We provide a simplified call to newton to locate the periodic orbits. newton will look for prob.jacobian in order to select the requested way to compute the jacobian.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"The docs for this specific newton are located at newton.","category":"page"},{"location":"periodicOrbitCollocation/#Continuation","page":"Collocation","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"We refer to continuation for more information regarding the arguments. continuation will look for prob.jacobian in order to select the requested way to compute the jacobian.","category":"page"},{"location":"periodicOrbitCollocation/#References","page":"Collocation","title":"References","text":"","category":"section"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"[Dankowicz]: Dankowicz, Harry, and Frank Schilder. Recipes for Continuation. Computational Science and Engineering Series. Philadelphia: Society for Industrial and Applied Mathematics, 2013.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"[Doedel]: Doedel, Eusebius, Herbert B. Keller, and Jean Pierre Kernevez. “NUMERICAL ANALYSIS AND CONTROL OF BIFURCATION PROBLEMS (II): BIFURCATION IN INFINITE DIMENSIONS.” International Journal of Bifurcation and Chaos 01, no. 04 (December 1991): 745–72.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"[Fairgrieve]: Fairgrieve, Thomas F., and Allan D. Jepson. “O. K. Floquet Multipliers.” SIAM Journal on Numerical Analysis 28, no. 5 (October 1991): 1446–62. https://doi.org/10.1137/0728075.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"[Russell]: Russell, R. D., and J. Christiansen. “Adaptive Mesh Selection Strategies for Solving Boundary Value Problems.” SIAM Journal on Numerical Analysis 15, no. 1 (February 1978): 59–80. https://doi.org/10.1137/0715004.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"[Lust]: Lust, Kurt. “Improved Numerical Floquet Multipliers.” International Journal of Bifurcation and Chaos 11, no. 09 (September 2001): 2389–2410. https://doi.org/10.1142/S0218127401003486.","category":"page"},{"location":"periodicOrbitCollocation/","page":"Collocation","title":"Collocation","text":"","category":"page"},{"location":"codim3Continuation/#Bogdanov-Takens-refinement","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement","text":"","category":"section"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"In this page, we explain how to perform precise localisation of Bogdanov-Takens (BT) points. This is an unusual feature of numerical continuation libraries. We chose to implement it because the localisation of the BT points on the Hopf bifurcation curves is rather imprecise.","category":"page"},{"location":"codim3Continuation/#Method","page":"Bogdanov-Takens refinement (3 params)","title":"Method","text":"","category":"section"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"The continuation of BT bifurcation points is based on a Minimally Augmented[Govaerts],[Blank],[Bindel] formulation which is an efficient way to detect singularities. The continuation of BT points is based on the formulation","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"G(up) = (F(up) g_1(up) g_2(up))inmathbb R^n+2quadquad (F_bt)","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"where the test functions g_1g_2 are solutions of","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"leftbeginarraycc\ndF(up)  w \nv^top  0\nendarrayrightleftbeginarrayc\nv_1 \ng_1(up)\nendarrayright=leftbeginarrayc0_n 1endarrayrightquadquad (M_bt)","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"and","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"leftbeginarraycc\ndF(up)  w \nv^top  0\nendarrayrightleftbeginarrayc\nv_2 \ng_2(up)\nendarrayright=leftbeginarraycv_1 0endarrayrightquadquad (M_bt)","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"and where wv are chosen in order to have a non-singular matrix (M_bt). More precisely, v (resp. w) should be close to a null vector of dF(u,p) (resp. dF(u,p)').","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"note that there are very simplified calls for this, see Newton refinement below. In particular, you don't need to set up the Minimally Augmented problem yourself. This is done in the background.","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"warning: Linear Method\nYou can pass the bordered linear solver to solve (M_bt) using the option bdlinsolver (see below). Note that the choice bdlinsolver = BorderingBLS() can lead to singular systems. Indeed, in this case, (M_bt) is solved by inverting dF(u,p) which is singular at Fold points.","category":"page"},{"location":"codim3Continuation/#Setting-the-jacobian","page":"Bogdanov-Takens refinement (3 params)","title":"Setting the jacobian","text":"","category":"section"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"In order to apply the newton algorithm to F_bt, one needs to invert the jacobian. This is not completely trivial as one must compute this jacobian and then invert it. You can select the following jacobians for your computations (see below):","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"[Default] for jacobian_ma = :autodiff, automatic differentiation is applied to F_bt and the matrix is then inverted using the provided linear solver. In particular, the jacobian is formed. This is very well suited for small dimensions  (say < 100)\nfor jacobian_ma = :minaug, a specific procedure for evaluating the jacobian F_bt and inverting it (without forming the jacobian!) is used. This is well suited for large dimensions.","category":"page"},{"location":"codim3Continuation/#Example","page":"Bogdanov-Takens refinement (3 params)","title":"Example","text":"","category":"section"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"using Revise, BifurcationKit\nFbt(x, p) = [x[2], p.β1 + p.β2 * x[2] + p.a * x[1]^2 + p.b * x[1] * x[2]]\npar = (β1 = 0.01, β2 = -0.3, a = -1., b = 1.)\nprob  = BifurcationProblem(Fbt, [0.01, 0.01], par, (@lens _.β1))\nopts_br = ContinuationPar(p_max = 0.5, p_min = -0.5, detect_bifurcation = 3, nev = 2)\n\nbr = continuation(prob, PALC(), opts_br; bothside = true)\n\n# compute branch of Hopf points\nhopf_codim2 = continuation(br, 3, (@lens _.β2), ContinuationPar(opts_br, detect_bifurcation = 1, max_steps = 40, max_bisection_steps = 25) ;\n\tdetect_codim2_bifurcation = 2,\n\tupdate_minaug_every_step = 1,\n\tbothside = true,\n\t)\n\n# refine BT point\nsolbt = BifurcationKit.newton_bt(hopf_codim2, 2)\nsolbt.u","category":"page"},{"location":"codim3Continuation/#Newton-refinement","page":"Bogdanov-Takens refinement (3 params)","title":"Newton refinement","text":"","category":"section"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"Once a Bogdanov-Takens point has been detected after a call to br = continuation(...), it can be refined using newton iterations. Let us say that ind_bif is the index in br.specialpoint of a Bogdanov-Takens point. This guess can be refined as follows:","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"outfold = newton(br::AbstractBranchResult, ind_bif::Int;  \n\tnormN = norm,\n\toptions = br.contparams.newton_options,\n\tbdlinsolver = BorderingBLS(options.linsolver),\n\tjacobian_ma = :autodiff,\n\tstart_with_eigen = false, kwargs...)","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"For the options parameters, we refer to Newton.","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"It is important to note that for improved performances, a function implementing the expression of the hessian should be provided. This is by far the fastest. BifurcationProblem provides it by default using AD though.","category":"page"},{"location":"codim3Continuation/#Advanced-use","page":"Bogdanov-Takens refinement (3 params)","title":"Advanced use","text":"","category":"section"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"Here, we expose the solvers that are used to perform newton refinement. This is useful in case it is too involved to expose the linear solver options.","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"BifurcationKit.newton_bt","category":"page"},{"location":"codim3Continuation/#BifurcationKit.newton_bt","page":"Bogdanov-Takens refinement (3 params)","title":"BifurcationKit.newton_bt","text":"newton_bt(\n    prob,\n    btpointguess,\n    par,\n    lens2,\n    eigenvec,\n    eigenvec_ad,\n    options;\n    normN,\n    jacobian_ma,\n    usehessian,\n    bdlinsolver,\n    bdlinsolver_adjoint,\n    bdlinsolver_block,\n    kwargs...\n)\n\n\nThis function turns an initial guess for a BT point into a solution to the BT problem based on a Minimally Augmented formulation. The arguments are as follows\n\nprob::AbstractBifurcationFunction\nbtpointguess initial guess (x0, p0) for the BT point. It should be a BorderedArray as returned by the function BTPoint\npar parameters used for the vector field\neigenvec guess for the 0 eigenvector\neigenvec_ad guess for the 0 adjoint eigenvector\noptions::NewtonPar options for the Newton-Krylov algorithm, see NewtonPar.\n\nOptional arguments:\n\nnormN = norm\nbdlinsolver bordered linear solver for the constraint equation\njacobian_ma::Symbol = true specify the way the (newton) linear system is solved. Can be (:autodiff, :finitedifferences, :minaug)\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\nSimplified call\n\nSimplified call to refine an initial guess for a BT point. More precisely, the call is as follows\n\nnewton(br::AbstractBranchResult, ind_bt::Int; options = br.contparams.newton_options, kwargs...)\n\nThe parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine. You can pass newton parameters different from the ones stored in br by using the argument options.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian will be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the option jacobian_ma = :autodiff\n\n\n\n\n\nnewton_bt(\n    br,\n    ind_bt;\n    probvf,\n    normN,\n    options,\n    nev,\n    start_with_eigen,\n    bdlinsolver,\n    bdlinsolver_adjoint,\n    kwargs...\n)\n\n\nThis function turns an initial guess for a Bogdanov-Takens point into a solution to the Bogdanov-Takens problem based on a Minimally Augmented formulation.\n\nArguments\n\nbr results returned after a call to continuation\nind_bif bifurcation index in br\n\nOptional arguments:\n\noptions::NewtonPar, default value br.contparams.newton_options\nnormN = norm\noptions You can pass newton parameters different from the ones stored in br by using this argument options.\njacobian_ma::Symbol = true specify the way the (newton) linear system is solved. Can be (:autodiff, :finitedifferences, :minaug)\nbdlinsolver bordered linear solver for the constraint equation\nstart_with_eigen = false whether to start the Minimally Augmented problem with information from eigen elements.\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\ntip: ODE problems\nFor ODE problems, it is more efficient to pass the option jacobian = :autodiff\n\ntip: start_with_eigen\nFor ODE problems, it is more efficient to pass the option start_with_eigen = true\n\n\n\n\n\n","category":"function"},{"location":"codim3Continuation/#References","page":"Bogdanov-Takens refinement (3 params)","title":"References","text":"","category":"section"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"[Govaerts]: Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"[Blank]: Blank, H. J. de, Yu. A. Kuznetsov, M. J. Pekkér, and D. W. M. Veldman. “Degenerate Bogdanov–Takens Bifurcations in a One-Dimensional Transport Model of a Fusion Plasma.” Physica D: Nonlinear Phenomena 331 (September 15, 2016): 13–26. https://doi.org/10.1016/j.physd.2016.05.008.","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"[Bindel]: Bindel, D., M. Friedman, W. Govaerts, J. Hughes, and Yu.A. Kuznetsov. “Numerical Computation of Bifurcations in Large Equilibrium Systems in Matlab.” Journal of Computational and Applied Mathematics 261 (May 2014): 232–48. https://doi.org/10.1016/j.cam.2013.10.034.","category":"page"},{"location":"codim3Continuation/","page":"Bogdanov-Takens refinement (3 params)","title":"Bogdanov-Takens refinement (3 params)","text":"","category":"page"},{"location":"guidelines/#Guidelines","page":"Guidelines","title":"Guidelines","text":"","category":"section"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"The goal of this package is to find solutions x to nonlinear equations ","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"F(xp) = 0 quadtagE","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"in large dimensions as function of a real parameter p. We want to be able to do so on GPU, distributed systems...","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"The core of the package is built around a Newton-Krylov solver (see newton) which allows to solve equations of the form F(x)=0, or find a solution x_0 to (E) for a particular p_0.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"Once such a solution (or several) (x_0p_0) is known, we can continue it by computing a 1d curve of solutions gamma = (x(s)p(s))_sin I passing through (x_0p_0) (see continuation and Deflated Continuation).","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"In practice, you don't need to know exactly (x_0p_0) to compute gamma. Indeed, continuation will call newton to refine any initial guess that you pass.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"tip: Textbook\nOnly the basics of bifurcation theory is underlined here. We refer to [Kuznetsov],[haragus] for a more thorough description.","category":"page"},{"location":"guidelines/#Bifurcation-analysis-of-Equilibria","page":"Guidelines","title":"Bifurcation analysis of Equilibria","text":"","category":"section"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"We can detect if the curve of solutions gamma crosses another curve of solutions gamma^bif without knowing gamma^bif! The intersection point (x^bp^b)ingamma is called a bifurcation point and is such that partial_xF(x^bp^b) is non invertible. When calling γ = continuation(...) with the option detect_bifurcation > 1 inside ContinuationPar, the bifurcation points are automatically detected.","category":"page"},{"location":"guidelines/#Branch-switching","page":"Guidelines","title":"Branch switching","text":"","category":"section"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"In the simple case where dimker partial_xF(x^bp^b) = 1, we can compute automatically the bifurcated branch gamma^bif by calling continuation and passing gamma. This is explained in Branch switching from simple branch point to equilibria. ","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"Recursively, we can compute the curves of solutions which are connected to (x_0p_0), this is called a bifurcation diagram. This bifurcation diagram can be automatically computed using the function bifurcationdiagram. More information is provided in Automatic Bifurcation diagram computation and a simple example is provided.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"When dequiv dimker partial_xF(x^bp^b)  1, you can still compute automatically the bifurcated branches gamma^bifs by calling continuation. It is based on a reduction of (E) to a small system of d dimensional multivariate polynomial equations in d.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"In the case d=1, the reduced equation can be further simplified into a normal form. This is also automatically computed by the package.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"tip: Branch switching\nMany more branch switching procedures are available. They are all listed in Branch switching","category":"page"},{"location":"guidelines/#Bifurcation-analysis-of-Cauchy-problems","page":"Guidelines","title":"Bifurcation analysis of Cauchy problems","text":"","category":"section"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"The goal of this part is to study the dynamics of the Cauchy problem","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"fracddtx - F(xp) = 0 quadtagC","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"The equilibria are time independent solutions of (C) hence satisfying (E). The previous part can be applied to compute curves of equilibria. However, we can do more and look for time dependent solutions as well. ","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"We can detect the existence of periodic solutions close to gamma. This is done automatically and those bifurcation points are called  Hopf bifurcation points.  ","category":"page"},{"location":"guidelines/#Branch-switching-at-Hopf-points","page":"Guidelines","title":"Branch switching at Hopf points","text":"","category":"section"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"We focus on computing the branch of periodic solutions branching from a Hopf point. This is done automatically by calling continuation, passing gamma and choosing a time discretization algorithm (see Periodic orbits computation). Some details about this branch switching are given in From Hopf point to periodic orbits.","category":"page"},{"location":"guidelines/#Branch-switching-at-bifurcation-points-of-periodic-orbits","page":"Guidelines","title":"Branch switching at bifurcation points of periodic orbits","text":"","category":"section"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"Let us consider the case where a branch of periodic orbits gamma^po have been computed (see for example previous section) and several bifurcation points have been detected (branch point, period doubling and Neimark Sacker). We can compute the bifurcated branches from gamma^po automatically.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"We do not provide an automatic branch switching for those points and for all methods (Shooting, Finite differences). However, for branch points of periodic orbits, you can call continuation by passing gamma^po and some simple arguments (amplitude of the periodic orbits) to perform branch switching in a semi-automatic way. For the case of Periodic orbits based on Trapezoidal rule, see From Branch / Period-doubling point of curve of periodic orbits.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"tip: Branch switching\nMany more branch switching procedures are available. They are all listed in Branch switching","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"tip: Manual Branch switching\nYou can perform manual branch switching by computing the nearby solutions close to a bifurcation point using a deflated newton (see Deflated problems), which provides a way to compute solutions other than a set of already known solutions.  You can then use these solutions to compute branches by calling continuation. Many, if not all tutorials give example of doing so like 2d Bratu–Gelfand problem or 1d Brusselator.","category":"page"},{"location":"guidelines/#References","page":"Guidelines","title":"References","text":"","category":"section"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"[Kuznetsov]: Kuznetsov, Yuri A. Elements of Applied Bifurcation Theory. Vol. 112. Applied Mathematical Sciences. Cham: Springer International Publishing, 2023. https://doi.org/10.1007/978-3-031-22007-4.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"[haragus]: Haragus, Mariana, and Gérard Iooss. Local Bifurcations, Center Manifolds, and Normal Forms in Infinite-Dimensional Dynamical Systems. London: Springer London, 2011. https://doi.org/10.1007/978-0-85729-112-7.","category":"page"},{"location":"guidelines/","page":"Guidelines","title":"Guidelines","text":"","category":"page"},{"location":"periodicOrbit/#Periodic-orbits-computation","page":"Introduction","title":"Periodic orbits computation","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"Consider the Cauchy problem","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"fracdudt=F(up)","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"A periodic solution with period T satisfies","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"beginalign\nfracdudt=F(up)\nu(0)=u(T)\nendalign","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"We provide 4 methods for computing periodic orbits (PO):","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"one (Trapezoid) based on finite differences to discretize a Cauchy problem,\none (Collocation) based on orthogonal collocation to discretize a Cauchy problem,\ntwo (Shooting) based on the flow associated to a Cauchy problem.","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"It is important to understand the pros and cons of each method to compute PO in large dimensions.","category":"page"},{"location":"periodicOrbit/#Trapezoid-method","page":"Introduction","title":"Trapezoid method","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"The Trapezoid method (or the Collocation one) is usually faster than the ones based on Shooting but it requires more memory as it saves the whole orbit. However the main drawback of this method is that the associated linear solver is not \"nice\", being composed of a cyclic matrix for which no generic Matrix-free preconditioner is known. Hence, the Trapezoid method is often used with an ILU preconditioner which is severely constrained by memory. Also, when the period of the cycle is large, finer time discretization (or mesh adaptation which is not yet implemented) must be employed which is also a limiting factor both in term of memory and preconditioning.","category":"page"},{"location":"periodicOrbit/#Collocation-method","page":"Introduction","title":"Collocation method","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"The Collocation method is (for now) the slowest of the three methods implemented for computing periodic orbits. However, it is by far the most precise one. Additionally, the mesh can be automatically adapted during the continuation. The implementation will be improved for large dimensional systems like the Trapezoid method one.","category":"page"},{"location":"periodicOrbit/#Shooting-method","page":"Introduction","title":"Shooting method","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"The methods based on Shooting do not share the same drawbacks because the associated linear system is usually well conditioned, at least in the simple shooting case. They are thus often used without preconditioner at all. Even in the case of multiple shooting, this can be alleviated by a simple generic preconditioner based on deflation of eigenvalues (see Linear solvers (LS)). Also, the time stepper will automatically adapt to the stiffness of the problem, putting more time points where needed unlike the method based on finite differences which requires an adaptive (time) meshing to provide a similar property. Finally, we can use parallel Shooting to greatly increase the speed of computation.","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"The main drawback of the method is to find a fast time stepper, at least to compete with the method based on finite differences. The other drawback is the precision of the method which cannot compete with the collocation method.","category":"page"},{"location":"periodicOrbit/#Important-notes","page":"Introduction","title":"Important notes","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"We regroup here some important notes which are valid for all methods above. ","category":"page"},{"location":"periodicOrbit/#1.-Accessing-the-periodic-orbit","page":"Introduction","title":"1. Accessing the periodic orbit","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"In record_from_solution, plot_solution or after the computation of a branch of periodic orbits, how do I obtain the periodic orbit, for plotting purposes for example? If x is the solution from newton for the parameter p, you can obtain the periodic orbit as follows","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"xtt = get_periodic_orbit(x, p)","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"where xtt.t contains the time mesh and xtt[:,:] contains the different components. Note that for Trapezoid and collocation methods, calling get_periodic_orbit is essentially free as it is a reshape of x. However, in the case of Shooting methods, this requires recomputing the periodic orbit which can be costly for large scale problems.","category":"page"},{"location":"periodicOrbit/#2.-Finaliser","page":"Introduction","title":"2. Finaliser","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"If you pass a finalise_solution function to continuation, the following occurs:","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"If the newton solve was successful, we update the phase condition every update_section_every_step\nwe call the user defined finalizer finalise_solution","category":"page"},{"location":"periodicOrbit/#3.-Record-from-solution","page":"Introduction","title":"3. Record from solution","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"You can pass your own function to continuation. In the particular case of periodic orbits, the method is called like record_from_solution(x, opt; k...) where opt.p is the current value of the continuation parameter and opt.prob is the current state of the continuation problem. You can then obtain the current periodic orbit using (see above)","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"xtt = get_periodic_orbit(x, opt.p)","category":"page"},{"location":"periodicOrbit/#4.-Plot-solution","page":"Introduction","title":"4. Plot solution","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"Similarly to record_from_solution, the method is called like plot_solution(x, opt; k...) where opt.p is the current value of the continuation parameter and opt.prob is the current state of the continuation problem.","category":"page"},{"location":"periodicOrbit/#5.-Most-precise-method-for-Floquet-coefficients","page":"Introduction","title":"5. Most precise method for Floquet coefficients","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"The state of the art method is based on a Periodic Schur decomposition. It is available through the package PeriodicSchurBifurcationKit.jl. For more information, have a look at FloquetPQZ.","category":"page"},{"location":"periodicOrbit/#6.-Misc","page":"Introduction","title":"6. Misc","text":"","category":"section"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"set_params_po generate_ci_problem generate_solution","category":"page"},{"location":"periodicOrbit/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"nonsimplebp/#Non-simple-branch-point","page":"Non-simple branch point","title":"Non-simple branch point","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"tip: Example\nAn example of use of the methods presented here is provided in 2d generalized Bratu–Gelfand problem.    ","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"We expose our method to study non-simple branch points. Such branch point (x_0p_0) for the problem F(xp)=0 satisfies d=dim ker dF(x_0p_0)  1 and the eigenvalues have zero imaginary part. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a d-dimensional polynomial equation, called the reduced equation.","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"More precisely, it is possible to write x = u + v where uin ker dF(x_0p_0) and vapprox 0 belongs to a vector space complement of ker dF(x_0p_0). It can be shown that u solves Phi(udelta p)=0 with Phi(udelta p) = (I-Pi)F(u+psi(udelta p)p_0+delta p) where psi is known implicitly and Pi is the spectral projector on ker dF(x_0p_0). Fortunately, one can compute the Taylor expansion of Phi up to order 3. Computing the bifurcation diagram of this d-dimensional multivariate polynomials can be done using brute force methods.","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once the zeros of Phi have been located, we can use them as initial guess for continuation but for the original F !!","category":"page"},{"location":"nonsimplebp/#Reduced-equation-computation","page":"Non-simple branch point","title":"Reduced equation computation","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"get_normal_form(br::ContResult, ind_bif::Int ; verbose = false, ζs = nothing, lens = getlens(br))","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"where prob is a bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. It returns a point with all requested information:","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"mutable struct NdBranchPoint{Tv, T, Tevl, Tevr, Tnf} <: BranchPoint\n\t\"bifurcation point\"\n\tx0::Tv\n\n\t\"Parameter value at the bifurcation point\"\n\tp::T\n\n\t\"Right eigenvectors\"\n\tζ::Tevr\n\n\t\"Left eigenvectors\"\n\tζstar::Tevl\n\n\t\"Normal form coefficients\"\n\tnf::Tnf\n\n\t\"Type of bifurcation point\"\n\ttype::Symbol\nend","category":"page"},{"location":"nonsimplebp/#Using-the-reduced-equation","page":"Non-simple branch point","title":"Using the reduced equation","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"Once a branch point has been computed bp = get_normal_form(...), you can do all sort of things. ","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"For example, quoted from the file test/testNF.jl, you can print the 2d reduced equation as follows:","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"julia> BifurcationKit.nf(bp2d)\n2-element Array{String,1}:\n \" + (3.23 + 0.0im) * x1 * p + (-0.123 + 0.0im) * x1^3 + (-0.234 + 0.0im) * x1 * x2^2\"\n \" + (-0.456 + 0.0im) * x1^2 * x2 + (3.23 + 0.0im) * x2 * p + (-0.123 + 0.0im) * x2^3\"","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"You can evaluate the reduced equation as bp2d(Val(:reducedForm), rand(2), 0.2). This can be used to find all the zeros of the reduced equation by sampling on a grid or using a general solver like  Roots.jl. \nFinally, given a d-dimensional vector x and a parameter delta p, you can have access to an initial guess u (see above) by calling bp2d(rand(2), 0.1)","category":"page"},{"location":"nonsimplebp/#Predictor","page":"Non-simple branch point","title":"Predictor","text":"","category":"section"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the method","category":"page"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"BifurcationKit.predictor(bp::BifurcationKit.NdBranchPoint, δp::T;\n        verbose::Bool = false,\n        ampfactor = T(1),\n        nbfailures = 30,\n        maxiter = 100,\n        perturb = identity,\n        J = nothing,\n        normN = norminf,\n        optn::NewtonPar) where T","category":"page"},{"location":"nonsimplebp/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.NdBranchPoint, T}} where T","page":"Non-simple branch point","title":"BifurcationKit.predictor","text":"predictor(\n    bp,\n    δp;\n    verbose,\n    ampfactor,\n    nbfailures,\n    maxiter,\n    perturb,\n    J,\n    normN,\n    optn\n)\n\n\nThis function provides prediction for what the zeros of the reduced equation / normal form should be for the parameter value δp. The algorithm for finding these zeros is based on deflated newton.\n\nOptional arguments\n\nJ jacobian of the normal form. It is evaluated with ForwardDiff otherwise.\nperturb perturb function used in Deflated newton\nnormN norm used for newton.\n\n\n\n\n\n","category":"method"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"BifurcationKit.predictor(bp::BifurcationKit.NdBranchPoint, ::Val{:exhaustive}, δp::T;\n                verbose::Bool,\n                ampfactor,\n                nbfailures,\n                maxiter,\n                perturb,\n                J,\n                igs,\n                normN,\n                optn::NewtonPar) where T","category":"page"},{"location":"nonsimplebp/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.NdBranchPoint, Val{:exhaustive}, T}} where T","page":"Non-simple branch point","title":"BifurcationKit.predictor","text":"predictor(\n    bp,\n    ,\n    δp;\n    verbose,\n    ampfactor,\n    nbfailures,\n    maxiter,\n    perturb,\n    J,\n    igs,\n    normN,\n    optn\n)\n\n\nThis function provides prediction for what the zeros of the reduced equation / normal form should be should be for the parameter value δp. The algorithm for finding these zeros is based on deflated newton. The initial guesses are the vertices of the hypercube.\n\nOptional arguments\n\nJ jacobian of the normal form. It is evaluated with ForwardDiff otherwise.\nperturb perturb function used in Deflated newton\nnormN norm used for newton.\nigs vector of initial guesses. If not passed, these are the vertices of the hypercube.\n\n\n\n\n\n","category":"method"},{"location":"nonsimplebp/","page":"Non-simple branch point","title":"Non-simple branch point","text":"","category":"page"},{"location":"DeflatedContinuation/#Deflated-Continuation","page":"Deflated continuation","title":"Deflated Continuation","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"unknown: References\nFarrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. The Computation of Disconnected Bifurcation Diagrams. ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"Deflated continuation allows to compute branches of solutions to the equation F(xp)=0. It is based on the Deflated Newton (see Deflated problems) algorithm.","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"See DefCont for more information.","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"However, unlike the regular continuation method, deflated continuation allows to compute disconnected bifurcation diagrams, something that is impossible for our Automatic Bifurcation diagram computation which is limited to the connected component of the initial point.","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"You can find an example of use of the method in Carrier Problem. We reproduce below the result of the computation which shows various disconnected components arising form Fold bifurcations that  are found seemingly by the method.","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"(Image: )","category":"page"},{"location":"DeflatedContinuation/#Algorithm","page":"Deflated continuation","title":"Algorithm","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"Input: Initial parameter value λmin.\nInput: Final parameter value λmax > λmin. Input: Step size ∆λ > 0.\nInput: Nonlinear residual f(u,λ).\nInput: Deflation operator M(u; u∗).\nInput: Initial solutions S(λmin) to f(·,λmin).\nλ ← λmin\nwhile λ < λmax do\n\tF(·) ← f(·,λ+∆λ) \t\t\t\t\t\t# Fix the value of λ to solve for.\n\tS(λ+∆λ) ← ∅\n\tfor u0 ∈ S(λ) do \t\t\t\t\t\t# Continue known branches.\n\t\tapply Newton’s method to F from initial guess u0.\n\t\tif solution u∗ found then\n\t\t\tS(λ + ∆λ) ← S(λ + ∆λ) ∪ {u∗}  # Record success\n\t\t\tF(·) ← M(·;u∗)F(·)\t\t\t  # Deflate solution\n\n\tfor u0 ∈ S(λ) do \t\t\t\t\t  # Seek new branches.\n\t\tsuccess ← true\n\t\twhile success do\n\t\t\tapply Newton’s method to F from initial guess u0.\n\t\t\tif solution u∗ found then\t\t # New branch found\n\t\t\t\tS(λ + ∆λ) ← S(λ + ∆λ) ∪ {u∗} # Record success\n\t\t\t\tF(·) ← M(·;u∗)F(·)\t\t     # Deflate solution\n\t\telse\n\t\t\tsuccess ← false\n\tλ←λ+∆λ\nreturn S","category":"page"},{"location":"DeflatedContinuation/#Tips","page":"Deflated continuation","title":"Tips","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"The following piece of information is valuable in order to get the algorithm working in various conditions (see also here) especially for small systems (e.g. dim<20):","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"newton is quite good and it is convenient to limit it otherwise it will be able to bypass the deflation. For example, you can use maxIter = 10 in NewtonPar\ntry to limit the newton residual by using the argument callback_newton = BifurcationKit.cbMaxNorm(1e7). This will likely remove the occurrence of ┌ Error: Same solution found for identical parameter value!!\nfinally, you can try some aggressive shift (here 0.01 in the deflation operator, like DeflationOperator(2, dot, 0.01, [sol]) but use it wisely.","category":"page"},{"location":"DeflatedContinuation/#Basic-example","page":"Deflated continuation","title":"Basic example","text":"","category":"section"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"We show a quick and simple example of use. Note in particular that the algorithm is able to find the disconnected branch. The starting points are marked with crosses","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"using BifurcationKit, LinearAlgebra, Setfield, SparseArrays, Plots\nconst BK = BifurcationKit\n\nk = 2\nN = 1\nF(x, p) = @. p * x + x^(k+1)/(k+1) + 0.01\nJac_m(x, p) = diagm(0 => p .+ x.^k)\n\n# bifurcation problem\nprob = BifurcationProblem(F, [0.], 0.5, (@lens _), J = Jac_m)\n\n# continuation options\nopts = BK.ContinuationPar(dsmax = 0.051, dsmin = 1e-3, ds=0.001, max_steps = 140, p_min = -3., newton_options = NewtonPar(tol = 1e-8), save_eigenvectors = false)\n\n# algorithm\nalg = BK.DefCont(deflation_operator = DeflationOperator(2, .001, [[0.]]), perturb_solution = (x,p,id) -> (x  .+ 0.1 .* rand(length(x))))\n\nbrdc = continuation(prob, alg,\n\tContinuationPar(opts, ds = -0.001, max_steps = 800, newton_options = NewtonPar(verbose = false, max_iterations = 6), plot_every_step = 40),\n\t; plot=true, verbosity = 0,\n\tcallback_newton = BK.cbMaxNorm(1e3) # reject newton step if residual too large\n\t)\nplot(brdc)","category":"page"},{"location":"DeflatedContinuation/","page":"Deflated continuation","title":"Deflated continuation","text":"","category":"page"},{"location":"Predictors/#Predictors-Correctors","page":"Predictors / correctors","title":"Predictors - Correctors","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"Pages = [\"Predictors.md\"]\nDepth = 3","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"The continuation method works with the following pattern (see [Allgower1990]):","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"compute tangent\ncall predictor (based on tangent, mostly)\ncall corrector","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"There are several couples predictor-tangent/corrector which can be used in BifurcationKit.jl as we now explain. The tangent computation is formally included in the predictor whereas it is a distinct function in the code.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"info: Corrector\nNote that setting the predictor also sets the corresponding corrector: it selects the couple predictor-corrector. You don't have (in fact cannot) set them independently.","category":"page"},{"location":"Predictors/#1.-Natural,-zeroth-order-predictor","page":"Predictors / correctors","title":"1. Natural, zeroth order predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This is the dumbest predictor based on the formula (x_1p_1) = (x_0 p_0 + ds) with Newton corrector ; it fails at Turning points. This is set by the algorithm Natural() in continuation. For matrix based jacobian, it is not faster than the pseudo-arclength predictor because the factorisation of the jacobian is cached. For Matrix-free methods, this predictor can be faster than the following ones until it hits a Turning point.","category":"page"},{"location":"Predictors/#2.-First-order-predictor","page":"Predictors / correctors","title":"2. First order predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is based on a computation of the tangent tau = (dxdp) to the curve of solutions, it is given by (x_1p_1) = (x_0p_0) + dscdot tau. This predictor passes Turning points when used with PALC Newton corrector. BifurcationKit.jl provides two ways to compute the tangent (dx dp).","category":"page"},{"location":"Predictors/#2a.-Secant-predictor","page":"Predictors / correctors","title":"2a. Secant predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor is called secant and is parametrized by the algorithm PALC(tangent = Secant()) in continuation with Secant .  It is computed with tau = (x_1 p_1) - (x_0 p_0) and normalized with the norm (x p)^2_theta = fracthetalength(x) langle xxrangle + (1 - theta)cdot p^2 for some 0theta1.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"warning: Parameter `θ`\nThe parameter θ in the norm above (see also the struct ContinuationPar) is very important. It should be tuned for the continuation to work properly especially in the case of large problems where the langle x - x_0 dx_0rangle component in the [Pseudo arclength continuation","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"](@ref) constraint might be favored too much. Also, large θs favour p as the corresponding term in the constraint N involves the term 1-θ.","category":"page"},{"location":"Predictors/#2b.-Bordered-predictor","page":"Predictors / correctors","title":"2b. Bordered predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This predictor departs from the previous one in the way the tangent tau is estimated. It computes tau=(dx dp) by solving solving the bordered linear system beginbmatrix F_x  F_p\t fracthetalength(x)dx_0  (1-theta)dp_0endbmatrixbeginbmatrixdx   dpendbmatrix =beginbmatrix0  1endbmatrix","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"where tau_0=(dx_0 dp_0) is the tangent at the previous continuation step.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"The predictor is set by the option PALC(tangent = Bordered()) in continuation with Bordered. The linear solver for the linear problem in (dx dp) is set by the option bls in PALC: it is one of Bordered linear solvers (BLS).","category":"page"},{"location":"Predictors/#3.-Polynomial-predictor","page":"Predictors / correctors","title":"3. Polynomial predictor","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"The polynomial predictor is based on a fit (least square regression) of an nth-order polynomial P on the last k solution vectors, where n  k. The arclength s is used for the polynomial which then fits the solution (x_ip_is_i) as P(s_i)approx (x_ip_i). To keep s in suitable range (see [Waugh]), we rescale it as sto fracs-bar ssigma where sigma is the standard deviation of the s_i.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This algorithm is parametrized by alg = Polynomial(Fred, n, k, v0) where pred::AbstractTangentComputation is the tangent predictor used only for the first k solutions before the polynomial predictor is operational and v0 is an example of guess. More information is available in Polynomial.","category":"page"},{"location":"Predictors/#4.-Multiple-predictor-(aka-pmcont-in-pde2path)","page":"Predictors / correctors","title":"4. Multiple predictor (aka pmcont in pde2path)","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"The predictor is designed [Uecker2014] to avoid spurious branch switching and pass singular points especially in PDE where branch point density can be quite high. It is based on the use of many predictors with increasing \"jumps\" (x_ip_i) = (x_0p_0) + icdot dscdot tau ileq nb and use a corrector (PALC Newton) with the following twist. The criterion is that in each Newton step, the residual has to decrease by a factor 0alpha1:","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":" F(u_np_n)leq alpha  F(u_n-1p_n-1) ","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"otherwise the corrector fails. The solution that is returned is the one for the highest i. We refer to [Uecker2014] for an exposition of the step size adaption strategy.","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"This algorithm is parametrized by alg = Multiple(pred, x0, α, nb) where τ is an initial tangent vector (used to set the types) and pred::PALC is a predictor. The default value is pred = PALC(). More information is available in Multiple.","category":"page"},{"location":"Predictors/#References","page":"Predictors / correctors","title":"References","text":"","category":"section"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Allgower1990]: Allgower and Georg, Numerical Continuation Methods, 1990","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Uecker2014]: 1.Uecker, H. pde2path - A Matlab Package for Continuation and Bifurcation in 2D Elliptic Systems. NMTMA 7, 58–106 (2014).","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"[Waugh]: Waugh, Illingworth, and Juniper, “Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems.”","category":"page"},{"location":"Predictors/","page":"Predictors / correctors","title":"Predictors / correctors","text":"","category":"page"},{"location":"bautin/#Normal-form-of-the-Bautin-bifurcation","page":"Bautin","title":"Normal form of the Bautin bifurcation","text":"","category":"section"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"We follow the paper[Kuznetsov] and consider a Cauchy problem","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"dot x=mathbf F(xp)","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"We denote by mathbf L the jacobian of mathbf F at the bifurcation point (x_0p_0). We choose a basis such that:","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"mathbf L q=i omega_0 q quad mathbf L^T p=-i omega_0 p quad langle p qrangle=1","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"Under some conditions, x(t)approx x_0+2Re w(t)q where w satisfies the normal form:","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"dotw=i omega_0 w+frac12 G_21 ww^2+frac112 G_32 ww^4+Oleft(w^6right)tagE","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"The second Lyapunov coefficient is ","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"l_2=frac112 operatornameRe G_32","category":"page"},{"location":"bautin/#Normal-form-computation","page":"Bautin","title":"Normal form computation","text":"","category":"section"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"The normal form (E) can be automatically computed as follows","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"get_normal_form(br::ContResult, ind_bif::Int;\n    verbose = false, \n    ζs = nothing, \n    lens = getlens(br),\n    kwargs...)","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns an object of type Bautin.","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"bautin/#Predictor","page":"Bautin","title":"Predictor","text":"","category":"section"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the method","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"predictor(gh::BifurcationKit.Bautin, ::Val{:FoldPeriodicOrbitCont}, ϵ::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"bautin/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.Bautin, Val{:FoldPeriodicOrbitCont}, T}} where T","page":"Bautin","title":"BifurcationKit.predictor","text":"predictor(gh, , ϵ; verbose, ampfactor)\n\n\nCompute the predictor for the curve of Folds of periodic orbits near the Bautin bifurcation point.\n\nReference\n\nKuznetsov, Yu A., H. G. E. Meijer, W. Govaerts, and B. Sautois. “Switching to Nonhyperbolic Cycles from Codim 2 Bifurcations of Equilibria in ODEs.” Physica D: Nonlinear Phenomena 237, no. 23 (December 2008): 3061–68. https://doi.org/10.1016/j.physd.2008.06.006.\n\n\n\n\n\n","category":"method"},{"location":"bautin/#References","page":"Bautin","title":"References","text":"","category":"section"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"[Kuznetsov]: Kuznetsov, Yu. A. “Numerical Normalization Techniques for All Codim 2 Bifurcations of Equilibria in ODE’s.” SIAM Journal on Numerical Analysis 36, no. 4 (January 1, 1999): 1104–24. https://doi.org/10.1137/S0036142998335005.","category":"page"},{"location":"bautin/","page":"Bautin","title":"Bautin","text":"","category":"page"},{"location":"PALC/#Pseudo-arclength-continuation","page":"PALC","title":"Pseudo arclength  continuation","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"Pages = [\"PALC.md\"]\nDepth = 3","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"This is one of the continuation methods implemented in the package. It is set by the option PALC(tangent = Bordered()) or PALC(tangent = Secant()) in continuation. See also PALC for more information.","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"For solving","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"mathbb R^nni F(xp) = 0 quadtagE","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"using a Newton algorithm, we miss an equation. The simplest way is to select an hyperplane in the space mathbb R^ntimes mathbb R passing through (x_0p_0):","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"N(x p) = fracthetan langle x - x_0 dx_0rangle + (1 - theta)cdot(p - p_0)cdot dp_0 - ds = 0tagN","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"with thetain01 and where ds is the pseudo arclength (see [Keller]).","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"warning: Parameter `θ`\nThe parameter θ in ContinuationPar is very important. It should be tuned for continuation to work properly especially in the case of large problems where the langle x - x_0 dx_0rangle component in the constraint might be favored too much. Also, large θs favour p as the corresponding term in the constraint N involves the term 1-θ.","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"(Image: )","category":"page"},{"location":"PALC/#Predictor","page":"PALC","title":"Predictor","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"The possible predictors are listed in Predictors - Correctors.","category":"page"},{"location":"PALC/#Corrector","page":"PALC","title":"Corrector","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"The corrector is the newton algorithm for finding the roots (xp) of","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"beginbmatrix F(xp) \tN(xp)endbmatrix = 0tagPALC","category":"page"},{"location":"PALC/#Linear-Algebra","page":"PALC","title":"Linear Algebra","text":"","category":"section"},{"location":"PALC/#Norm","page":"PALC","title":"Norm","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"First, the option normC continuation specifies the norm used to evaluate the residual in the following way:","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"max(normC(F(xp)) N(xp))tol","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"It is thus used as a stopping criterion for the corrector. The dot product (resp. norm) used in N and in the (iterative) linear solvers is LinearAlgebra.dot (resp. LinearAlgebra.norm). It can be changed by importing these functions and redefining it. Note that by default, the mathcal L^2 norm is used. ","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"These details are important because the constraint N incorporates the factor length. For some custom type implementing a Vector space, the dot product could already incorporates the length factor in which case you should either redefine the dot product or change theta.","category":"page"},{"location":"PALC/#Dot-product","page":"PALC","title":"Dot product","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"In the constraint N above, the scalar product is in fact saved in BifurcationKit.jl as dotp(x,y) -> dot(x,y)/length(y). This is used in the bordered linear solvers associated to PALC. If you want to use your own dot product, you can pass","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"dotPALC = BK.DotTheta(mydot),","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"to continuation. Additionally, you may want to provide the linear operator P such that mydot(x,y) = dot(x, A*y), especially if you intend too use the linear solver MatrixBLS. We refer to BifurcationKit.DotTheta for more details.","category":"page"},{"location":"PALC/#Linear-problem","page":"PALC","title":"Linear problem","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"Pseudo arclength continuation is based on a newton solver applied to the enlarged problem (PALC). We thus need to solve a linear system of size n+1 whereas the user passed a linear solver (in ContinuationPar().newton_options) for a system of size n.","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"The linear solver for the linear problem associated to (PALC) is set by the option linear_algo in continuation: it is one of Bordered linear solvers (BLS).","category":"page"},{"location":"PALC/#Step-size-control","page":"PALC","title":"Step size control","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"Each time the corrector fails, the step size ds is halved. This has the disadvantage of having lost Newton iterations (which costs time) and imposing small steps (which can be slow as well). To prevent this, the step size is controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor a in ContinuationPar.","category":"page"},{"location":"PALC/#References","page":"PALC","title":"References","text":"","category":"section"},{"location":"PALC/","page":"PALC","title":"PALC","text":"[Keller]: Keller, Herbert B. Lectures on Numerical Methods in Bifurcation Problems. Springer, 1988","category":"page"},{"location":"PALC/","page":"PALC","title":"PALC","text":"","category":"page"},{"location":"iterator/#Iterator-Interface","page":"Iterator Interface","title":"Iterator Interface","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The iterator interface gives the possibility of stepping through the numerical steps of the continuation procedure. It thus allows to inject custom monitoring function (saving, plotting, bifurcation detection, ...) at will and during the continuation run. In short, it allows to completely re-write the continuation algorithm as one sees fit and this, in a straightforward manner.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The general method continuation is built upon this iterator interface and we refer to the source code for a complete example of use.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"warning: Warning\nThe iterator provided below does not compute eigenvalues nor performs bifurcations detection. ","category":"page"},{"location":"iterator/#Initialization","page":"Iterator Interface","title":"Initialization","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"More information about iterators can be found on the page of julialang.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The interface is set by defining an iterator, pretty much in the same way one calls continuation:","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"iter = ContIterable(prob, alg, opts; kwargs...)","category":"page"},{"location":"iterator/#Stepping","page":"Iterator Interface","title":"Stepping","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"Once an iterator iter has been defined, one can step through the numerical continuation using a for loop:","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"for state in iter\n\tprintln(\"Continuation step = \", state.step)\nend","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The state::ContState has the following description. It is a mutable object which holds the current state of the continuation procedure from which one can step to the next state.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"The for loop stops when done(iter, state) returns false. The condition which is implemented is basically that the number of iterations should be smaller than maxIter, that the parameters should be in (p_min, p_max)...","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"ContState","category":"page"},{"location":"iterator/#BifurcationKit.ContState","page":"Iterator Interface","title":"BifurcationKit.ContState","text":"mutable struct ContState{Tv, T, Teigvals, Teigvec, Tcb} <: BifurcationKit.AbstractContinuationState{Tv}\n\nStructure containing the state of the continuation procedure. The fields are meant to change during the continuation procedure. \n\ndanger: Danger\nIf you mutate these fields yourself, you can break the continuation procedure. Use the methods below to access the fields knowing that they do not yield copies.\n\nArguments\n\nz_pred current solution on the branch\nconverged Boolean for newton correction\nτ tangent predictor\nz previous solution\nitnewton Number of newton iteration (in corrector)\nstep current continuation step\nds step size\nstopcontinuation Boolean to stop continuation\n\nUseful functions\n\ncopy(state) returns a copy of state\ncopyto!(dest, state)  copy state into dest\ngetsolution(state) returns the current solution (x, p)\ngettangent(state) return the tangent at the current solution\ngetpredictor(state) return the predictor at the current solution\ngetx(state) returns the x component of the current solution\ngetp(state) returns the p component of the current solution\nget_previous_solution(state) returns the previous solution (x, p)\ngetpreviousx(state) returns the x component of the previous solution\ngetpreviousp(state) returns the p component of the previous solution\nis_stable(state) whether the current state is stable\n\n\n\n\n\n","category":"type"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"tip: continuation\nYou can also call continuation(iter) to have access to the regular continuation method used throughout the tutorials.","category":"page"},{"location":"iterator/#Basic-example","page":"Iterator Interface","title":"Basic example","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"We show a quick and simple example of use. Note that it is not very optimized because of the use of global variables.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"using BifurcationKit, Plots\nconst BK = BifurcationKit\n\nk = 2\n\n# functional we want to study\nF(x, p) = (@. p + x - x^(k+1)/(k+1))\n\n# bifurcation problem\nprob = BifurcationProblem(F, [0.8], 1., (@lens _))\n\n# parameters for the continuation\nopts = ContinuationPar(dsmax = 0.1, dsmin = 1e-3, ds = -0.001, max_steps = 130, p_min = -3., p_max = 3., newton_options = NewtonPar(tol = 1e-8))\n\n# we define an iterator to hold the continuation routine\niter = BK.ContIterable(prob, PALC(), opts; verbosity = 2)\n\nresp = Float64[]\nresx = Float64[]\n\n# this is the PALC algorithm\nfor state in iter\n\t# we save the current solution on the branch\n\tpush!(resx, getx(state)[1])\n\tpush!(resp, getp(state))\nend\n\n# plot the result\nplot(resp, resx; label = \"\", xlabel = \"p\")","category":"page"},{"location":"iterator/#Additional-information","page":"Iterator Interface","title":"Additional information","text":"","category":"section"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"If you want to customize the iterator to your needs, perhaps the best source of inspiration is the code of the function continuation!(it::ContIterable, state::ContState, contRes::ContResult) where the iterator is used at its fullest. You will see how the eigen-elements and the stability are computed, how bifurcations are detected and how results are saved.","category":"page"},{"location":"iterator/","page":"Iterator Interface","title":"Iterator Interface","text":"","category":"page"},{"location":"bppo/#Branch-point-of-periodic-orbit","page":"Simple branch point","title":"Branch point of periodic orbit","text":"","category":"section"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"Pages = [\"bppo.md\"]\nDepth = 3","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"At a Branch point (BP) of a periodic orbit gamma (with period T)  for the Cauchy problem at parameter value p_0:","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"fracdudt=F(up)tagE","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"the eigenvalues (Floquet coefficients) of the monodromy operator mathcal M=Y(T) solution to","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"fracdYdt=A(t)Y(t) Y(0)=I_n","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"contain the eigenvalue 1 with algebraic multiplicity 2. There are two ways to compute the normal form of this bifurcation","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"using the Poincaré return map [Kuznetsov]\nusing the method of [Iooss], see also [Kuz2]","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"You can obtain the normal form of a BP bifurcation using ","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"pd = get_normal_form(br, ind; prm = false)","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"where prm indicates whether you want to use the method based on Poincaré return map (PRM) or the one based on Iooss method.","category":"page"},{"location":"bppo/#Predictor","page":"Simple branch point","title":"Predictor","text":"","category":"section"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the method","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"predictor(hp::BifurcationKit.BranchPointPO{ <: ShootingProblem }, δp, \n                    ampfactor; \n                    override = false)","category":"page"},{"location":"bppo/#BifurcationKit.predictor-Tuple{BifurcationKit.BranchPointPO{<:ShootingProblem}, Any, Any}","page":"Simple branch point","title":"BifurcationKit.predictor","text":"predictor(nf, δp, ampfactor; override)\n\n\nCompute the predictor for the simple branch point of periodic orbit.\n\n\n\n\n\n","category":"method"},{"location":"bppo/#Which-method-to-use?","page":"Simple branch point","title":"Which method to use?","text":"","category":"section"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"Depending on the method used for computing the periodic orbits, you have several possibilities:","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"For shooting, you can only the PRM method. Shooting is the preferred way for large scale systems. Note that the PRM method is not very precise numerically.\nFor collocation, you can use PRM and Iooss methods. Note that the Iooss method is the most precise. This is not yet implemented.\nFor Trapezoid method, the normal form is not yet implemented.","category":"page"},{"location":"bppo/#Normal-form-based-on-Poincaré-return-map","page":"Simple branch point","title":"Normal form based on Poincaré return map","text":"","category":"section"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"Given a transversal section Sigma to gamma at gamma(0), the Poincaré return map mathcal P associates to each point xinSigma close to gamma(0) the first point mathcal P(xp)inSigma where the orbit of (E) with initial condition x intersects again Sigma at mathcal P(xp). Hence, the discrete map x_n+1=mathcal P(x_np) has normal form","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"x_n+1 = x_n+a_10delta p + a_11delta p x+a_02x^2+a_03x^3","category":"page"},{"location":"bppo/#References","page":"Simple branch point","title":"References","text":"","category":"section"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"[Kuznetsov]: Yu. A. Kuznetsov, \"Elements of Applied Bifurcation Theory\", 2nd ed., 1998.","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"[Kuz2]: Kuznetsov et al., “Numerical Periodic Normalization for Codim 1 Bifurcations of Limit Cycles.”","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"[Iooss]: Iooss, \"Global Characterization of the Normal Form for a Vector Field near a Closed Orbit.\", 1988","category":"page"},{"location":"bppo/","page":"Simple branch point","title":"Simple branch point","text":"","category":"page"},{"location":"intro-abs/#Branch-switching-page","page":"Introduction","title":"Branch switching","text":"","category":"section"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"Pages = [\"intro-abs.md\"]\nDepth = 3","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"The precise definition of the methods is given in Branch switching (branch point) and Branch switching (Hopf point).","category":"page"},{"location":"intro-abs/#(Automatic)-branch-switching-of-simple-bifurcation-points","page":"Introduction","title":"(Automatic) branch switching of simple bifurcation points","text":"","category":"section"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"Unlike other continuation softwares (Auto07p, MatCont, pde2path), BifurcationKit has methods for automatic branch switching where the user is only asked to provide the parameter distance from a point on the bifurcated branch to the bifurcation point. Let us explain this in more detail using the following figure.","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"Knowing a bifurcation point X_0 = (x_0p_0) on a branch br, we want to find the bifurcated (red) curve. To this, we need an initial guess X_1 on the bifurcated curve. Usually, the tangent vec v can be found which leaves two parameters δp, ampfactor to be determined. Note that both parameters needs to be small. For example, the default values are δp = ds (ds is in ContinuationPar ) and ampfactor = 0.1.","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"In case of manual branch switching, the user is asked to provide the couple δp, ampfactor. This can be tricky because minute errors in δp, ampfactor can imped newton correction. This is for example used in Lur'e problem for period-doubling with Trapezoid method. Thus, the general method is like","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"continuation(br, ind_bif, options_cont; \n    δp = 0.1, ampfactor = 0.1,\n    kwargs...)","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"In case of automatic branch switching, the user is only asked to provide δp while ampfactor is internally estimated using the normal form of the bifurcation point. When the user does not pass δp, the value of ds is in ContinuationPar is used. Thus, the general method is like","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"continuation(br, ind_bif, options_cont; kwargs...)","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"When the bifurcation diagram is very stiff, automatic branch switching may fail (for example BifurcationKit could return ampfactor=1e6 or ampfactor = 1e-10). In this case, one can override automatic branch switching and specify δp, ampfactor directly as for manual branch switching using","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"continuation(br, ind_bif, options_cont; \n    δp = 0.1, ampfactor = 0.1,\n    override = true,\n    kwargs...)","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"tip: Manual branch switching\nManual branch switching is automatically used by BifurcationKit when the normal form of the bifurcation point is not implemented (like PD normal form for Trapezoid method). You can force BifurcationKit to use it using the override key word.","category":"page"},{"location":"intro-abs/#Branch-switching-of-non-simple-bifurcation-points","page":"Introduction","title":"Branch switching of non-simple bifurcation points","text":"","category":"section"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"We refer to Branch switching for more details.","category":"page"},{"location":"intro-abs/#Graph-of-bifurcations","page":"Introduction","title":"Graph of bifurcations","text":"","category":"section"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"We provide a graph of bifurcations of equilibria and periodic orbits that can be detected in BifurcationKit. An arrow from say Equilibrium to Hopf means that Hopf bifurcations can be detected while continuing equilibria. Each object of codim 0 (resp. 1) can be continued in one (resp. 2) parameters.","category":"page"},{"location":"intro-abs/#Summary-of-branching-procedures","page":"Introduction","title":"Summary of branching procedures","text":"","category":"section"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"We collect in the following table the list of automatic branch switching (aBS) functions. Their detailed explanation follows in this page.","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"function ind-th bif. point Type T description\ncontinuation(br::ContResult{T}, ind::Int; kw...) :bp, :nd EquilibriumCont aBS from equilibria to equilibria\ncontinuation(br::ContResult{T}, ind::Int, lens2::Lens; kw...) :bp, :hopf EquilibriumCont Fold/Hopf continuation w.r.t. parameters getlens(br) and lens2\ncontinuation(br::ContResult{T}, ind::Int; kw...) :bt,:zh,:hh FoldCont,HopfCont switch to Fold/Hopf continuation from Hopf/Fold w.r.t. parameters of codim 2 br\ncontinuation(br::ContResult{T}, ind_hopf::Int, ::ContinuationPar, prob::AbstractPeriodicOrbitProblem) :hopf EquilibriumCont Branch switching from Hopf point to periodic orbits\ncontinuation(br::ContResult{T}, ind::Int, kw...) :bp,:pd PeriodicOrbitCont Branch switching from Branch / Period-doubling point of periodic orbits to curve of periodic orbits\ncontinuation(br::ContResult{T}, ind::Int, kw...) :gh,:zh,:hh TwoParamCont Branch switching from Bautin / Zero-Hopf/ Hopf-Hopf point to curve of Fold/NS of periodic orbits","category":"page"},{"location":"intro-abs/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"cusp/#Normal-form-of-the-Cusp-bifurcation","page":"Cusp","title":"Normal form of the Cusp bifurcation","text":"","category":"section"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"We follow the paper[Kuznetsov] and consider a Cauchy problem","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"dot x=mathbf F(xp)","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"We denote by mathbf L the jacobian of mathbf F at the bifurcation point (x_0p_0). We choose a basis such that:","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"mathbf L q=0 quad mathbf L^T p=0 quad langle p qrangle=1","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"Under some conditions, x(t)approx x_0+ w(t)q where w satisfies the normal form:","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"dotw=c w^3+Oleft(w^4right)tagE","category":"page"},{"location":"cusp/#Normal-form-computation","page":"Cusp","title":"Normal form computation","text":"","category":"section"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"The normal form (E) can be automatically computed as follows","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"get_normal_form(br::ContResult, ind_bif::Int ; \n    ζs = nothing,\n    lens = getlens(br)\n    )","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns an object of type Cusp.","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"cusp/#References","page":"Cusp","title":"References","text":"","category":"section"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"[Kuznetsov]: Kuznetsov, Yu. A. “Numerical Normalization Techniques for All Codim 2 Bifurcations of Equilibria in ODE’s.” SIAM Journal on Numerical Analysis 36, no. 4 (January 1, 1999): 1104–24. https://doi.org/10.1137/S0036142998335005.","category":"page"},{"location":"cusp/","page":"Cusp","title":"Cusp","text":"","category":"page"},{"location":"ANM/#Asymptotic-numerical-method-(ANM)","page":"ANM","title":"Asymptotic numerical method (ANM)","text":"","category":"section"},{"location":"ANM/","page":"ANM","title":"ANM","text":"warning: Dimensions\nThis is a method for small dimensions, less than several thousands.","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"To access this algorithm, you have to use the package AsymptoticNumericalMethod.jl   ","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"The method [Rubbert],[Charpentier] seeks a Taylor approximation of the solutions of","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"mathbf F(Xp)=0inmathbb R^n","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"where Xinmathbb R^n pinmathbb R. The solution is found by solving","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"F(x(s)p(s))= 0","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"langle x(s)-x(0)fracpartial upartial s(0)rangle + (p(s)-p(0))fracpartial ppartial s(0) = s","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"where","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"x(s)=sumlimits_k=0^K x_ks^kquad p(s)=sumlimits_k=0^K p_ks^k","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"for some user passed K0. It gives","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"F(x(s)p(s)) = sumlimits_k=0^K F_ks^k+hot","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"from which we deduce the equations F_k=0. We then find:","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"F_1 x_1=Id p_1=1(x_kp_k) = -F_kx_k=0p_k=0","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"The validity range of the solution can be estimated by","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"r_K = left(fracepsilonlvertlvert F_Klvertlvertright)^1K","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"This allows to iterate and find a sequence of series which spans the parameter range.","category":"page"},{"location":"ANM/#Implementation","page":"ANM","title":"Implementation","text":"","category":"section"},{"location":"ANM/","page":"ANM","title":"ANM","text":"The method is based on the package TaylorSeries.jl which makes it easy to manipulate Taylor series based on Automatic Differentiation.","category":"page"},{"location":"ANM/#Method","page":"ANM","title":"Method","text":"","category":"section"},{"location":"ANM/","page":"ANM","title":"ANM","text":"See AsymptoticNumericalMethod.ANM for more information.","category":"page"},{"location":"ANM/#Example","page":"ANM","title":"Example","text":"","category":"section"},{"location":"ANM/","page":"ANM","title":"ANM","text":"We provide an example of use. We define a BifurcationProblem as usual and pass the continuation algorithm ANM.","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"using AsymptoticNumericalMethod, Plots, Parameters\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction F(x, p)\n\t@unpack α = p\n\tf = similar(x)\n\n\tf[1] = (-2x[1]+x[2]) + α * exp(x[1])\n\tf[2] = ( x[1]-2x[2]) + α * exp(x[2])\n\n\treturn f\nend\n\nsol0 = zeros(2)\npar = (α = 0.0, )\nprob = BifurcationProblem(F, sol0, par, (@lens _.α); record_from_solution = (x,p) -> norminf(x))","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"optanm = ContinuationPar(dsmin = 0.01, dsmax = 0.15, detect_bifurcation = 3, ds= 0.01, newton_options = NewtonPar(tol = 1e-9), n_inversion = 6, max_bisection_steps = 15, max_steps = 15, )\n\nbranm = continuation(prob, ANM(20, 1e-8), optanm, normC = norminf, verbosity = 2)","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"You can plot the result as usual:","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"plot(branm)","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"You can also show the radius of convergence of each series:","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"plot(branm, plotseries = true)","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"Finally, for each series, we ca evaluate the residual norm:","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"plot()\nfor ii in eachindex(branm.polU)\n\ts = LinRange(-0*branm.radius[ii], branm.radius[ii], 20)\n\tplot!([branm.polp[ii].(s)], [norminf(F(branm.polU[ii](_s), BK.setparam(prob,branm.polp[ii](_s)))) for _s in s], legend = false, linewidth=5)#, marker=:d)\nend\ntitle!(\"\")","category":"page"},{"location":"ANM/#References","page":"ANM","title":"References","text":"","category":"section"},{"location":"ANM/","page":"ANM","title":"ANM","text":"[Charpentier]: Charpentier, Isabelle, Bruno Cochelin, and Komlanvi Lampoh. “Diamanlab - An Interactive Taylor-Based Continuation Tool in MATLAB,” n.d., 12.","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"[Rubbert]: Rubbert, Lennart, Isabelle Charpentier, Simon Henein, and Pierre Renaud. “Higher-Order Continuation Method for the Rigid-Body Kinematic Design of Compliant Mechanisms”,  n.d., 18.","category":"page"},{"location":"ANM/","page":"ANM","title":"ANM","text":"","category":"page"},{"location":"ns/#Neimark-Sacker-point","page":"Neimark-Sacker","title":"Neimark-Sacker point","text":"","category":"section"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"Pages = [\"ns.md\"]\nDepth = 2","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"At a Neimark-Sacker (NS) bifurcation of a periodic orbit gamma (with period T) for parameter value p_0 for the Cauchy problem ","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"fracdudt=F(up)tagE","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"the eigenvalues (Floquet coefficients) of the monodromy operator mathcal M=Y(T) solution to","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"fracdYdt=A(t)Y(t) Y(0)=I_n","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"contain the eigenvalues e^pm i theta with theta and ","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"e^i q theta-1 neq 0 quad q=1234 text  (no strong resonances) ","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"There are two ways to compute the normal form of this bifurcation","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"using the Poincaré return map [Kuznetsov]\nusing the method of [Iooss], see also [Kuz2]","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"You can obtain the normal form of a NS bifurcation using ","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"pd = get_normal_form(br, ind; prm = false)","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"where prm indicates whether you want to use the method based on Poincaré return map (PRM) or the one based on Iooss method.","category":"page"},{"location":"ns/#Which-method-to-use?","page":"Neimark-Sacker","title":"Which method to use?","text":"","category":"section"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"Depending on the method used for computing the periodic orbits, you have several possibilities:","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"For shooting, you can only the PRM method. Shooting is the preferred way for large scale systems. Note that the PRM method is not very precise numerically.\nFor collocation, you can use PRM and Iooss methods. Note that the Iooss method is the most precise.\nFor Trapezoid method, NS normal form is not yet implemented.","category":"page"},{"location":"ns/#Normal-form-based-on-Poincaré-return-map","page":"Neimark-Sacker","title":"Normal form based on Poincaré return map","text":"","category":"section"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"Given a transversal section Sigma to gamma at gamma(0), the Poincaré return map mathcal P associates to each point xinSigma close to gamma(0) the first point mathcal P(xp)inSigma where the orbit of (E) with initial condition x intersects again Sigma at mathcal P(xp). Hence, the discrete map x_n+1=mathcal P(x_np) has normal form","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"z_n+1 = z_ne^itheta(1+dz_n^2)","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"where[Kuz2]","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"d=frac12 e^-i thetaleftlangle v^* mathcalC(v v barv)+2 mathcalBleft(vleft(I_n-1-mathcalAright)^-1 mathcalB(v barv)right)+mathcalBleft(barvleft(e^2 i theta I_n-1-mathcalAright)^-1 mathcalB(v v)right)rightrangle","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"where mathcal C=d^3mathcal P(gamma(0)), mathcal B = d^2mathcal P(gamma(0)) and mathcal A = dmathcal P(gamma(0)). Also:","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"mathcalA v=e^i theta v mathcalA^mathrmT v^*=e^-i theta v^* text  and leftlangle v^* vrightrangle=1","category":"page"},{"location":"ns/#Normal-form-based-on-Iooss-method","page":"Neimark-Sacker","title":"Normal form based on Iooss method","text":"","category":"section"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"This is based on [Iooss],[Kuz2]. Suppose that the T periodic orbit gamma(tau) has a Neimark-Sacker bifurcation for a parameter value p_0. We also assume that there are no strong resonances. Locally, the orbits can be represented by ","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"x(tau) = gamma(tau)+Q_0(tau)xi+Phi(tau xi)","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"where ","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"leftbeginaligned\nfracd taud t  =1+axi^2+cdots \nfracd xid t  =fraci thetaT xi+d xixi^2+cdots\nendalignedright","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"with center manifold correction Phi(tau xi) being T periodic in tau and Q_0(tau) is the Floquet operator.","category":"page"},{"location":"ns/#References","page":"Neimark-Sacker","title":"References","text":"","category":"section"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"[Kuznetsov]: Yu. A. Kuznetsov, \"Elements of Applied Bifurcation Theory\", 2nd ed., 1998.","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"[Kuz2]: Kuznetsov et al., “Numerical Periodic Normalization for Codim 1 Bifurcations of Limit Cycles.”","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"[Iooss]: Iooss, \"Global Characterization of the Normal Form for a Vector Field near a Closed Orbit.\", 1988","category":"page"},{"location":"ns/","page":"Neimark-Sacker","title":"Neimark-Sacker","text":"","category":"page"},{"location":"overview/#Overview-of-BifurcationKit.jl","page":"Overview","title":"Overview of BifurcationKit.jl","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The general workflow for using the package is as follows:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Define a problem\nSolve the problem\nAnalyze the output","category":"page"},{"location":"overview/#Defining-Problems","page":"Overview","title":"Defining Problems","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Problems are specified via a type interface. The problem types are designed to contain the necessary information to fully define their associated continuation method. For example, a bifurcation problem is defined by","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"F(u pars) = 0","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"with some parameters pars, some initial guess u0, and scalar parameter axis lens contained in pars. Therefore the BifurcationProblem is defined by those components:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"prob = BifurcationProblem(F, u0, pars, lens)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that the number types in the solution will match the types you designate in the problem. However complex types are not advised as they mess up the detection of bifurcation points.","category":"page"},{"location":"overview/#Continuing-from-the-initial-guess","page":"Overview","title":"Continuing from the initial guess","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Each type of bifurcation problem has its own problem type which allow the solvers to dispatch to the right methods. The common interface for calling the solvers is:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"br = continuation(prob, alg; kwargs)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Into the command, one passes the bifurcation problem that was defined prob, choose an algorithm alg, and change the properties of the solver using keyword arguments.  The solver returns a branch object br which holds all the details for the branch.","category":"page"},{"location":"overview/#Analyzing-the-branch","page":"Overview","title":"Analyzing the branch","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The solution type has a common interface, which makes handling the solution similar between the different types of bifurcation problems. Tools such as interpolations are seamlessly built into the solution interface to make analysis easy. This interface is described in the ContResult.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Plotting functionality is provided by a recipe to Plots.jl. To use plot branches, simply call the plot(br) and the plotter will generate appropriate plots. Plots can be customized using all the keyword arguments provided by Plots.jl. Please see Plots.jl's documentation for more information.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"#BifurcationKit.jl","page":"Home","title":"BifurcationKit.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package aims at performing automatic bifurcation analysis of possibly large dimensional equations F(u, λ)=0 where λ is real by taking advantage of iterative methods, dense / sparse formulation and specific hardwares (e.g. GPU).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It incorporates continuation algorithms (PALC, deflated continuation, ...) based on a Newton-Krylov method to correct the predictor step and a Matrix-Free/Dense/Sparse eigensolver is used to compute stability and bifurcation points.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Despite initial focus on large scale problems, the package can easily handle low dimensional problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package can also seek for periodic orbits of Cauchy problems . It is by now, one of the only softwares which provides shooting methods and methods based on finite differences or collocation to compute periodic orbits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hence, it is possible to study large scale nonlinear problems on different hardwares. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"One design choice is that we try not to require u to be a subtype of an AbstractArray as this would forbid the use of spectral methods like the one from ApproxFun.jl. For now, our implementation does not allow this for all methods of the package.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package requires Julia >= v1.3.0 because of the use of methods added to abstract types (see #31916).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install it, please run","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add BifurcationKit","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the bleeding edge version, please run","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add BifurcationKit#master","category":"page"},{"location":"#Citing-this-work","page":"Home","title":"Citing this work","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package for your work, we ask that you cite the following paper!! Open source development strongly depends on this. It is referenced on HAL-Inria as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{veltz:hal-02902346,\n  TITLE = {{BifurcationKit.jl}},\n  AUTHOR = {Veltz, Romain},\n  URL = {https://hal.archives-ouvertes.fr/hal-02902346},\n  INSTITUTION = {{Inria Sophia-Antipolis}},\n  YEAR = {2020},\n  MONTH = Jul,\n  KEYWORDS = {pseudo-arclength-continuation ; periodic-orbits ; floquet ; gpu ; bifurcation-diagram ; deflation ; newton-krylov},\n  PDF = {https://hal.archives-ouvertes.fr/hal-02902346/file/354c9fb0d148262405609eed2cb7927818706f1f.tar.gz},\n  HAL_ID = {hal-02902346},\n  HAL_VERSION = {v1},\n}","category":"page"},{"location":"#Other-softwares","page":"Home","title":"Other softwares","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are many good softwares already available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For continuation in small dimension, most softwares are listed on DSWeb. One can mention the widely used AUTO-07p, or also, XPPAUT, MATCONT, PyDSTool and COCO. All these are very reliable and some address high codimensional bifurcations.\nFor large scale problems, there is the versatile and feature full pde2path but also Trilinos-LOCA, CL_MATCONTL, COCO, GetFEM and the python libraries pyNCT and pacopy. There are also some nice lectures by D. Avitabile et al. on matrix free secant continuation based on a concise Matlab implementation which are used in the influential paper [Rankin]. At the time of initial release of BifurcationKit.jl, these lectures provided one of the only libraries for matrix-free continuation, much easier to use than Trilinos-LOCA.\nFor deflated continuation, there is defcont (by the inventor of the algo. P. E. Farrell) and this code by N. M. Evstigneev.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia, we have the following tools:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bifurcations.jl which is unmaintained.\nNumericalContinuation.jl by David Barton.","category":"page"},{"location":"#A-word-on-performance","page":"Home","title":"A word on performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The tutorials have not all been written with the goal of performance but rather simplicity (except maybe 2d Ginzburg-Landau equation and Langmuir–Blodgett model). One could surely turn them into more efficient codes. The intricacies of PDEs make the writing of efficient code highly problem dependent and one should take advantage of every particularity of the problem under study.","category":"page"},{"location":"#Requested-methods-for-custom-arrays","page":"Home","title":"Requested methods for custom arrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Needless to say, if you use \"regular\" arrays, you don't need to worry about what follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We make the same requirements as KrylovKit.jl. Hence, we refer to its docs for more information. We additionally require the following methods to be available:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base.length(x): it is used in the constraint equation of the pseudo arclength continuation method (see continuation for more details). If length is not available for your \"vector\", define length(x) = 1 and adjust the parameter θ in PALC.\nBase.copyto!(dest, in) this is required to reduce the allocations\nBase.eltype must be extended to your vector type.","category":"page"},{"location":"#Citations","page":"Home","title":"Citations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The papers citing this work are collected on google scholar.","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of BifurcationKit was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/bifurcationkit/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/bifurcationkit/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[Rankin]: J. Rankin et al., \"Continuation of localized coherent structures in nonlocal neural field equations\", SIAM J. Scientific Computing 36, pp. B70–B93 (2014): https://epubs.siam.org/doi/10.1137/130918721","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"diffeq/#Wrapper-to-the-package-DifferentialEquations.jl","page":"DiffEq wrapper","title":"Wrapper to the package DifferentialEquations.jl","text":"","category":"section"},{"location":"diffeq/","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"warning: Warning\nThis is work in progress.  ","category":"page"},{"location":"diffeq/","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"The current package will provide basic methods to wrap some of the functionality of DifferentialEquations.jl. ","category":"page"},{"location":"diffeq/","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"Basically, the ultimate idea is that you provide a prob::ODEProblem to our newton, continuation... and they will use the expression of the jacobians, the linear solvers... that you already provided for the construction of prob.","category":"page"},{"location":"diffeq/","page":"DiffEq wrapper","title":"DiffEq wrapper","text":"","category":"page"},{"location":"NSContinuationPO/#Continuation-of-Neimark-Sacker-(NS)-bifurcations-of-periodic-orbits","page":"Neimark-Sacker continuation (2 params)","title":"Continuation of Neimark-Sacker (NS) bifurcations of periodic orbits","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"In this page, we explain how to perform continuation of NS points of periodic orbits and detect the associated codim 2 bifurcations.","category":"page"},{"location":"NSContinuationPO/#List-of-detected-codim-2-bifurcation-points","page":"Neimark-Sacker continuation (2 params)","title":"List of detected codim 2 bifurcation points","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"Bifurcation symbol used Multipliers\nStrong resonance 1:1 bifurcation R1 {1,1,1}\nStrong resonance 1:2 bifurcation R2 {1,-1,-1}\nStrong resonance 1:3 bifurcation R3 {1,e^pm 2ipi3}\nStrong resonance 1:4 bifurcation R4 {1,e^pm ipi2}\nFold / Neimark-Sacker foldNS {1,1,e^pm ialpha}\nDouble Niemark-Sacker nsns {e^pm ialpha, e^pm ibeta}\nChenciner ch {1,e^pm ialpha}","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"In a nutshell, all you have to do (see below) is to call continuation(br, ind_bif, lens2) to continue the bifurcation point stored in br.specialpoint[ind_bif] and set proper options.","category":"page"},{"location":"NSContinuationPO/#Neimark-Sacker-continuation","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"The continuation of Neimark-Sacker bifurcation points is based on a Minimally Augmented[Govaerts] formulation which is an efficient way to detect singularities (see Fold / Hopf Continuation). All the methods (see Periodic orbits computation), except the Trapezoid one, for computing periodic orbits are compatible with this algorithm. In particular, you can perform these computations in large dimensions.","category":"page"},{"location":"NSContinuationPO/#Detection-of-codim-2-bifurcation-points","page":"Neimark-Sacker continuation (2 params)","title":"Detection of codim 2 bifurcation points","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"You can detect the following codim 2 bifurcation points by using the keyword argument detect_codim2_bifurcation in the method continuation ","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"the detection of Chenciner bifurcation is done by the the computating the NS normal form\nthe detection the above bifurcation points is done by monitoring the number of eigenvalues lambda such that Relambda  minlimits_nuinSigma(dF)Renu and Imlambda  epsilon where epsilon is the Newton tolerance.","category":"page"},{"location":"NSContinuationPO/#Setting-the-jacobian","page":"Neimark-Sacker continuation (2 params)","title":"Setting the jacobian","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"In order to apply the newton algorithm to the PD functional, one needs to invert the jacobian. This is not completely trivial as one must compute this jacobian and then invert it. You can select the following jacobians for your computations (see below):","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"[Default] for jacobian_ma = :autodiff, automatic differentiation is applied to the PD functional and the matrix is then inverted using the provided linear solver. In particular, the jacobian is formed. This is very well suited for small dimensions  (say < 100)\nfor jacobian_ma = :finiteDifferences, same as jacobian_ma = :autodiff but the jacobian is computed using finite differences.","category":"page"},{"location":"NSContinuationPO/#Codim-2-continuation","page":"Neimark-Sacker continuation (2 params)","title":"Codim 2 continuation","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"To compute the codim 2 curve of Fold points of periodic orbits, one can call continuation with the following options","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":" continuation(br::BifurcationKit.AbstractBranchResult, ind_bif::Int64,\n\t\t\t\tlens2::Lens, options_cont::ContinuationPar = br.contparams ;\n\t\t\t\tkwargs...)","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"where br is a branch of periodic orbits and the options are as above except with have an additional parameter axis lens2 which is used to locate the bifurcation points.","category":"page"},{"location":"NSContinuationPO/#Algorithmic-details","page":"Neimark-Sacker continuation (2 params)","title":"Algorithmic details","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"The continuation of NS points is based on the formulation","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"G(upomega) = (F_po(upomega) Resigma(upomega) Imsigma(upomega))inmathbb R^n+2quadquad (mathcal F_ns)","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"where F_po is the functional for locating periodic orbits and the test function sigma is solution of","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"leftbeginarraycc\nN(upomega)  w \nv^top  0\nendarrayrightleftbeginarrayc\nr \nsigma(uomegap)\nendarrayright=leftbeginarrayc\n0_n \n1\nendarrayright","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"The jacobian of the NS functional to use for the Newton algorithm","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"leftbeginarrayccc\npartial_uF_po  partial_pF_po  0 \npartial_usigma_r  partial_psigma_r  partial_omegasigma_r\npartial_usigma_i  partial_psigma_i  partial_omegasigma_i\nendarrayright","category":"page"},{"location":"NSContinuationPO/#Shooting","page":"Neimark-Sacker continuation (2 params)","title":"Shooting","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"In the case of Multiple Standard Shooting, the matrix N is based on the monodromy M(x_iT_i)","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"N=left(beginarraycccccc\nM_1  -I  0  cdots  0 \n0  M_2  -I  cdots  0 \nvdots    ddots  ddots  vdots \n0  cdots  cdots  ddots  -I \ne^iomegaI  cdots  cdots  0  M_m \nendarrayright)","category":"page"},{"location":"NSContinuationPO/#Orthogonal-collocation","page":"Neimark-Sacker continuation (2 params)","title":"Orthogonal collocation","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"In the case of orthogonal collocation, the matrix N is the jacobian of the periodic orbit functional stripped of the phase condition (m=2):","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"left(beginarraylllllll\nH_00^0  H_01^0  H_10^0     \nH_00^1  H_01^1  H_10^1     \n  H_10^0  H_11^0  H_20^0   \n  H_10^1  H_11^1  H_20^1   \n    H_20^0  H_21^0  H_30^0 \n    H_20^1  H_21^1  H_30^1 \n      \nI       e^iomegaI\nendarrayright)","category":"page"},{"location":"NSContinuationPO/#References","page":"Neimark-Sacker continuation (2 params)","title":"References","text":"","category":"section"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"[Govaerts]: Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.","category":"page"},{"location":"NSContinuationPO/","page":"Neimark-Sacker continuation (2 params)","title":"Neimark-Sacker continuation (2 params)","text":"","category":"page"},{"location":"abs-from-codim2-po/#From-codim-2-to-periodic-orbits","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"","category":"section"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"Pages = [\"abs-from-codim2-po.md\"]\nDepth = 3","category":"page"},{"location":"abs-from-codim2-po/#From-Bautin-point-to-curve-Folds-of-periodic-orbits","page":"From codim 2 to periodic orbits","title":"From Bautin point to curve Folds of periodic orbits","text":"","category":"section"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"From the Bautin normal form, we know that there is a curve of Fold of periodic orbits near the bifurcation point.","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"We provide an automatic branch switching method in this case which reads as follows:","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"continuation(br::HopfCont, ind_BAUTIN::Int, \n\t_contParams::ContinuationPar,\n    prob::AbstractPeriodicOrbitProblem ;\n    δp = nothing, ampfactor = 1, kwargs...)","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"where prob is a method to compute periodic orbits (see From Hopf point to periodic orbits for more information).","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"Note that the two parameters in br will be used for the continuation of Fold points of periodic orbits.","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"See ODE for an example of use.","category":"page"},{"location":"abs-from-codim2-po/#From-Zero-Hopf-(ZH)-point-to-curve-NS-of-periodic-orbits","page":"From codim 2 to periodic orbits","title":"From Zero-Hopf (ZH) point to curve NS of periodic orbits","text":"","category":"section"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"From the Zero-Hopf normal form, we know that there is a curve of Neimark-Sacker (NS) bifurcations of periodic orbits near the bifurcation point.","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"We provide an automatic branch switching method in this case which reads as follows:","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"continuation(br::TwoParamCont, ind_ZH::Int, \n\t_contParams::ContinuationPar,\n    prob::AbstractPeriodicOrbitProblem ;\n    δp = nothing, ampfactor = 1, kwargs...)","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"where prob is a method to compute periodic orbits (see From Hopf point to periodic orbits for more information).","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"Note that the two parameters in br will be used for the continuation of NS points of periodic orbits.","category":"page"},{"location":"abs-from-codim2-po/#From-Hopf-Hopf-(HH)-point-to-curve-NS-of-periodic-orbits","page":"From codim 2 to periodic orbits","title":"From Hopf-Hopf (HH) point to curve NS of periodic orbits","text":"","category":"section"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"From the Hopf-Hopf normal form, we know that there are two curves of Neimark-Sacker (NS) bifurcations of periodic orbits near the bifurcation point.","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"We provide an automatic branch switching method in this case which reads as follows:","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"continuation(br::TwoParamCont, ind_HH::Int, \n\t_contParams::ContinuationPar,\n    prob::AbstractPeriodicOrbitProblem ;\n    δp = nothing, ampfactor = 1, \n    whichns = 1,\n    kwargs...)","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"where prob is a method to compute periodic orbits (see From Hopf point to periodic orbits for more information). The option whichns which belongs to {1,2} controls which NS curve you want to compute. ","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"Note that the two parameters in br will be used for the continuation of NS points of periodic orbits.","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"See ODE for an example of use.","category":"page"},{"location":"abs-from-codim2-po/","page":"From codim 2 to periodic orbits","title":"From codim 2 to periodic orbits","text":"","category":"page"},{"location":"zh/#Normal-form-of-the-Zero-Hopf-bifurcation","page":"Zero-Hopf","title":"Normal form of the Zero-Hopf bifurcation","text":"","category":"section"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"We follow the paper[Kuznetsov],[Kuznetsov2] and consider a Cauchy problem","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"dot x=mathbf F(xp)","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"We denote by mathbf L the jacobian of mathbf F at the bifurcation point (x_0p_0). We choose a basis such that:","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"mathbf L q_0=0 quad mathbf L q_1=i omega_0 q_1","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"Under some conditions, x(t)approx x_0+2Re w_1(t)q_1+w_0(t)q_0 where w_i satisfy the normal form:","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"leftbeginaligned\ndotw_0=  frac12 G_200 w_0^2+G_011leftw_1right^2+frac16 G_300 w_0^3  +G_111 w_0leftw_1right^2+Oleft(leftleft(w_0 w_1 barw_1right)right^4right) \ndotw_1=  i omega_0 w_1+G_110 w_0 w_1+frac12 G_210 w_0^2 w_1+frac12 G_021 w_1leftw_1right^2  +Oleft(leftleft(w_0 w_1 barw_1right)right^4right) \nendalignedrighttagE","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"This normal form is usually computed in order to branch from a Zero-Hopf bifurcation point to curves of Neimark-Sacker bifurcations of periodic orbits (see [Kuznetsov2]). Not all coefficients in (E) are required for this branching procedure, that is why only a subset of the G_ijk is returned.","category":"page"},{"location":"zh/#Normal-form-computation","page":"Zero-Hopf","title":"Normal form computation","text":"","category":"section"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"The normal form (E) can be automatically computed as follows","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"get_normal_form(br::ContResult, ind_bif::Int ;  \n    ζs = nothing, \n    lens = getlens(br))","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns an object of type ZeroHopf.","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"zh/#Predictors","page":"Zero-Hopf","title":"Predictors","text":"","category":"section"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the methods","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"BifurcationKit.predictor(zh::BifurcationKit.ZeroHopf, ::Val{:HopfCurve}, ds::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"zh/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.ZeroHopf, Val{:HopfCurve}, T}} where T","page":"Zero-Hopf","title":"BifurcationKit.predictor","text":"predictor(zh, , ds; verbose, ampfactor)\n\n\nCompute the predictor for the curve of Hopf bifurcations near the Zero-Hopf bifurcation point.\n\n\n\n\n\n","category":"method"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"BifurcationKit.predictor(zh::BifurcationKit.ZeroHopf, ::Val{:FoldCurve}, ds::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"zh/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.ZeroHopf, Val{:FoldCurve}, T}} where T","page":"Zero-Hopf","title":"BifurcationKit.predictor","text":"predictor(zh, , ds; verbose, ampfactor)\n\n\nCompute the predictor for the curve of Fold bifurcations near the Zero-Hopf bifurcation point.\n\n\n\n\n\n","category":"method"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"BifurcationKit.predictor(zh::BifurcationKit.ZeroHopf, ::Val{:NS}, ϵ::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"zh/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.ZeroHopf, Val{:NS}, T}} where T","page":"Zero-Hopf","title":"BifurcationKit.predictor","text":"predictor(zh, , ϵ; verbose, ampfactor)\n\n\nCompute the predictor for the curve of Neimark-Sacker bifurcations near the Zero-Hopf bifurcation point.\n\nReference\n\nKuznetsov, Yu A., H. G. E. Meijer, W. Govaerts, and B. Sautois. “Switching to Nonhyperbolic Cycles from Codim 2 Bifurcations of Equilibria in ODEs.” Physica D: Nonlinear Phenomena 237, no. 23 (December 2008): 3061–68. https://doi.org/10.1016/j.physd.2008.06.006.\n\n\n\n\n\n","category":"method"},{"location":"zh/#References","page":"Zero-Hopf","title":"References","text":"","category":"section"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"[Kuznetsov]: Kuznetsov, Yu. A. “Numerical Normalization Techniques for All Codim 2 Bifurcations of Equilibria in ODE’s.” SIAM Journal on Numerical Analysis 36, no. 4 (January 1, 1999): 1104–24. https://doi.org/10.1137/S0036142998335005.","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"[Kuznetsov2]: Kuznetsov, Yu A., H. G. E. Meijer, W. Govaerts, and B. Sautois. “Switching to Nonhyperbolic Cycles from Codim 2 Bifurcations of Equilibria in ODEs.” Physica D: Nonlinear Phenomena 237, no. 23 (December 2008): 3061–68. https://doi.org/10.1016/j.physd.2008.06.006.","category":"page"},{"location":"zh/","page":"Zero-Hopf","title":"Zero-Hopf","text":"","category":"page"},{"location":"eigensolver/#Eigen-solvers-(Eig)","page":"Eigen solvers","title":"Eigen solvers (Eig)","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"The eigen solvers must be subtypes of AbstractEigenSolver. ","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"They provide a way of computing the eigen elements of the Jacobian J. Such eigen solver eigsolve will be called like ev, evecs, itnumber = eigsolve(J, nev; kwargs...) throughout the package, nev being the number of requested eigen elements of largest real part and kwargs being used to send information about the algorithm (perform bisection,...).","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"Here is an example of the simplest of them (see src/EigSolver.jl for the true implementation) to give you an idea:","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"struct DefaultEig <: AbstractEigenSolver end\n\nfunction (l::DefaultEig)(J, nev; kwargs...)\n\t# I put Array so we can call it on small sparse matrices\n\tF = eigen(Array(J))\n\tI = sortperm(F.values, by = real, rev = true)\n\tnev2 = min(nev, length(I))\n\treturn F.values[I[1:nev2]], F.vectors[:, I[1:nev2]], true, 1\nend","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"warning: Eigenvalues\nThe eigenvalues must be ordered by increasing real part for the detection of bifurcations to work properly.","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"warning: Eigenvectors\nYou have to implement the method geteigenvector(eigsolver, eigenvectors, i::Int) for newtonHopf to work properly.","category":"page"},{"location":"eigensolver/#Methods-for-computing-eigenvalues","page":"Eigen solvers","title":"Methods for computing eigenvalues","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"Like for the linear solvers, computing the spectrum of operators A associated to PDE is a highly non trivial task because of the clustering of eigenvalues. Most methods are based on the so-called power method but this only yields the eigenvalues with largest modulus. In case of the Laplacian operator, this can be disastrous and it is better to apply the power method to (sigma I-A)^-1 instead. ","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"This method, called Shift-invert, is readily available for the solvers EigArpack and EigArnoldiMethod, see below. It is mostly used to compute interior eigenvalues. For the solver EigKrylovKit, one must implement its own shift invert operator, using for example GMRESKrylovKit.","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"In some cases, it may be advantageous to consider the Cayley transform (sigma I-A)^-1(tau I+A) to focus on a specific part of the spectrum. As it is mathematically equivalent to the Shift-invert method, we did not implement it.","category":"page"},{"location":"eigensolver/#List-of-implemented-eigen-solvers","page":"Eigen solvers","title":"List of implemented eigen solvers","text":"","category":"section"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"Default eigen Julia eigensolver for matrices. You can create it via eig = DefaultEig(). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default). You can then compute 3 eigenelements of J like eig(J, 3).\nEigensolver from Arpack.jl. You can create one via eigsolver = EigArpack() and pass appropriate options (see Arpack.jl). For example, you can compute eigenvalues using Shift-Invert method with shift σ by using EigArpack(σ, :LR). Note that you can specify how the eigenvalues are ordered (by decreasing real part by default). Finally, this method can be used for (sparse) matrix or Matrix-Free formulation. For a matrix J, you can compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigArpack(v0 = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3). \nEigensolver from KrylovKit.jl. You create one via eig = EigKrylovKit() and pass appropriate options (see KrylovKit.jl). This method can be used for (sparse) matrix or Matrix-Free formulation. In the case of a matrix J, you can create a solver like this eig = EigKrylovKit(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigKrylovKit(x₀ = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3).\nEigensolver from ArnoldiMethod.jl. You can create one via eig = EigArnoldiMethod() and pass appropriate options (see ArnoldiMethod.jl). For example, you can compute eigenvalues using the Shift-Invert method with shift σ by using EigArnoldiMethod(σ, LR()). Note that you can also specify how the eigenvalues are ordered (by decreasing real part by default). In the case of a matrix J, you can create a solver like eig = EigArnoldiMethod(). Then, you compute 3 eigen-elements using eig(J, 3). In the case of a Matrix-Free jacobian dx -> J(dx), you need to tell the eigensolver the dimension of the state space by giving an example of vector: eig = EigArnoldiMethod(x₀ = zeros(10)). You can then compute 3 eigen-elements using eig(dx -> J(dx), 3). ","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"tip: Slow computations \nThis is probably due to iterative refinement conducted by SuiteSparse as explained in this blog post. You can disable this usingusing SuiteSparse\nSuiteSparse.UMFPACK.umf_ctrl[8] = 0","category":"page"},{"location":"eigensolver/","page":"Eigen solvers","title":"Eigen solvers","text":"","category":"page"},{"location":"interfaceLS/#Interface-for-Linear-Solvers","page":"Vector","title":"Interface for Linear Solvers","text":"","category":"section"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"The linear solver ls must be a subtype of the abstract type AbstractLinearSolver. It is then called as follows","category":"page"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"Required methods  Brief description\nls(J, rhs; a₀ = 0, a₁ = 1, kwargs...)  Compute the solution sol of the linear problem (a₀ * I + a₁ * J) * sol = rhs where J is the jacobian. Returns (sol, success::Bool, itnumber) where itnumber is the number of iterations for solving the problem.","category":"page"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"tip: Shifts\nTwo methods _axpy and _axpy_op are provided to help implementing this shift a₀ * I + a₁ * J","category":"page"},{"location":"interfaceLS/#Interface-for-Eigen-Solvers","page":"Vector","title":"Interface for Eigen Solvers","text":"","category":"section"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"The linear solver eig must be a subtype of the abstract type AbstractEigenSolver. It is then called as follows","category":"page"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"Required methods  Brief description\neig(J, nev::Int; kwargs...)  Compute the nev eigen-elements with largest real part. Returns (eigenvalues, eigenvectors, success:Bool, itnumber) where itnumber is the number of iterations for completing the computation. kwargs can be used to send information about the algorithm (perform bisection,...).\ngeteigenvector(eig, eigenvectors, i::Int)  Returns the ith eigenvectors from the set of eigenvectors.","category":"page"},{"location":"interfaceLS/#Interface-for-Bordered-Linear-Solvers","page":"Vector","title":"Interface for Bordered Linear Solvers","text":"","category":"section"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"The bordered linear solver bls must be a subtype of the abstract type AbstractBorderedLinearSolver (which is itself a subtype of AbstractLinearSolver). It is used to solve","category":"page"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"tagBLSleftbeginarrayll\ntextshiftcdot I+J  dR \n(xi_u cdot dz_u)^T  xi_p cdot dz_p\nendarrayright cdotleftbeginarrayl\ndX \ndl\nendarrayright = leftbeginarrayl\nR \nn\nendarrayright","category":"page"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"where xi_uxi_pinmathbb C and dRxi_uinmathbb C^N.","category":"page"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"Required methods  Brief description\nbls(J, dR, dzu, dzp, R, n, ξu::Number, ξp::Number; shift = nothing, kwargs...)  Compute the solution dX, dl of the linear problem (BLS) where J is the jacobian and dR, dzu are vectors (not necessarily subtypes of AbstractVector). shift = nothing is used in place of saying shift=0. Returns (dX, dl, success::Bool, itnumber) where itnumber is the number of iterations for solving the problem.","category":"page"},{"location":"interfaceLS/","page":"Vector","title":"Vector","text":"","category":"page"},{"location":"educational/#Educational-introduction-to-bifurcation-analysis-(contributed-by-G.-Datseris)","page":"Educational introduction","title":"Educational introduction to bifurcation analysis (contributed by G. Datseris)","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"This page is an educational introduction to bifurcation analysis and creation of bifurcation diagrams. It will show a completely self-contained approach, and its goal is to serve as an introduction to users not yet fully familiar with bifurcation analysis. ","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"The text here is based on Chapter 4 of Nonlinear Dynamics: a concise introduction interlaced with code and is presented in a shortened form. It is focusing on using the simplest possible method for bifurcation continuation (the secant method) and can only address fixed points (the standard version of Newton's algorithm). Of course, this does not reflect the full features and power of BifurcationKit.jl, but it shows the basic guiding principles.","category":"page"},{"location":"educational/#Newton's-method-for-finding-fixed-points","page":"Educational introduction","title":"Newton's method for finding fixed points","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"Let mathbfx be a D-dimensional vector participating in the continuous dynamical system dotmathbfx = f(mathbfx p) which also depends on some arbitrary parameter pinmathbb R. To identify fixed points, we want to find the roots mathbfx^* of f. Notice that everything that follows also applies to discrete dynamical systems where mathbfx_n+1 = g(mathbfx_n). The difference is that we simply define f = g - mathbfId and find the roots of f again.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"To find the roots we can use Newton's method. Starting for some point mathbfx_0, the following sequence will (typically) converge to a root:","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"mathbfx_j+1 = mathbfx_j - delta J_f^-1(mathbfx_j) f(mathbfx_j)","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"for 0le delta le 1 and with J_f the Dtimes D Jacobian matrix of f.","category":"page"},{"location":"educational/#Continuation-of-a-bifurcation-curve","page":"Educational introduction","title":"Continuation of a bifurcation curve","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"A bifurcation curve (in the simplified context of this page) is the location of fixed points versus a parameter p. The simplest, but also most brute force, way to compute such a curve would be to scan the parameter axis, and for each parameter value apply Newton's method to find the fixed point. Because there could be more than one fixed points at a given parameter, one needs several initial conditions plugged into Newton's method, to ensure all fixed points are found.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"A bit better approach would be to true and continue the curve of the fixed point mathbfx^*(p). To do this one needs two ingredients: (1) a predictor and (2) a corrector. The first estimates a new \"seed\" for Newton's method that attempts to continue the existing points we have found on the curve. The second corrects this prediction to a point in the state-parameter space that is on the bifurcation curve.","category":"page"},{"location":"educational/#The-secant-predictor","page":"Educational introduction","title":"The secant predictor","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"The simplest predictor is the secant. Let mathbfz = (mathbfx p). Assuming we have found at least two points mathbfz^*_m mathbfz^*_m-1 on the bifurcation curve, we can estimate a continuation tildemathbfz = 2mathbfz^*_m - mathbfz^*_m-1 (linear extrapolation). This is called the secant predictor.","category":"page"},{"location":"educational/#The-corrector","page":"Educational introduction","title":"The corrector","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"The prediction tildemathbfz of the secant needs to be corrected not only in the variable space mathbfx, which is what Newton's method currently does, but also on parameter space. To do this, we need to extend the function f to have one more element (because otherwise we would have 1 too many unknowns give the amount of equations we have to estimate the zero of f(mathbfz)). We will extend f so that its D+1 entry enforces the k-th element of the root to be the one suggested by the predictor. I.e., we define the function h","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"h(mathbfx) = (f_1(mathbfz) ldots f_D(mathbfz) mathbfzk - tildemathbfzk)","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"and will try to find the zeros of h now via Newton's method. Notice that now the Jacobian J_h is D+1 dimensional, with the last column being the derivatives of f towards the parameter p.","category":"page"},{"location":"educational/#Code:-Newton's-algorithm-in-mixed-space","page":"Educational introduction","title":"Code: Newton's algorithm in mixed space","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"Let's first write the code that will be performing Newton's algorithm for the function h in the mixed space of mathbfz. For convenience, we would expect the user to only provide the functions f J_f as functions f(x, p), J(x,p) with x a vector and p a number. We can do everything else using automatic differentiation.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"(Notice: for simplicity, and to be in style with BifurcationKit.jl we will make everything allocate and return new Vector instances. Performance-wise, the code written in this page is as bad as it can possibly get)","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"First, define a function that given f, J, the mixed state z and the index k it returns the mixed Jacobian J_h","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"using ForwardDiff # for auto-differentiation\nusing LinearAlgebra\n\nfunction mixed_jacobian(z, k, f, J)\n    x = z[1:end-1]; p = z[end]\n    # start creating the mixed space jacobian\n    j = J(x, p)\n    # to the state space jacobian add one more column, derivative towards p\n    pder = ForwardDiff.derivative(p -> f(x, p), p)\n    Jmixed = hcat(j, pder)\n    # add the last row, which is 1 for the `k` entry, 0 everywhere else\n    last_row = zeros(length(z)); last_row[k] = 1.0\n    Jfinal = vcat(Jmixed, last_row')\n    return Jfinal\nend","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"Then we write a function that takes one step of the Newton's algorithm:","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"using LinearAlgebra\n\nfunction newton_step!(zⱼ, zpred, i, f, J, δ)\n    Jfinal = mixed_jacobian(zⱼ, i, f, J)\n    xⱼ = zⱼ[1:end-1]; pⱼ = zⱼ[end]\n    g = f(xⱼ, pⱼ)\n    gz = vcat(g, zⱼ[i] - zpred[i])\n    zⱼ₊₁ = zⱼ - Jfinal \\ gz\n    return zⱼ₊₁\nend","category":"page"},{"location":"educational/#Code:-Corrector-function","page":"Educational introduction","title":"Code: Corrector function","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"And with this, we are ready to compose our corrector function, that takes a guess zpred and brings it to a point that is on the bifurcation curve. The keyword arguments help us give a convergence criterion to Newton's algorithm and also catch problematic cases where convergence never happens in time.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"function corrector(zpred, f, J; δ = 0.9, max_steps = 200, ε = 1e-6, k = 1)\n    c = 0\n    zⱼ = zpred\n    zⱼ₊₁ = newton_step!(zⱼ, zpred, k, f, J, δ)\n    while norm(zⱼ₊₁ - zⱼ) > ε\n        zⱼ = zⱼ₊₁\n        zⱼ₊₁ = newton_step!(zⱼ, zpred, k, f, J, δ)\n        c += 1\n        if c > max_steps\n            @warn(\"Newton did not converge.\")\n            return (zⱼ₊₁, false)\n        end\n    end\n    return zⱼ₊₁, true\nend","category":"page"},{"location":"educational/#Code:-Predictor-function","page":"Educational introduction","title":"Code: Predictor function","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"Coding the predictor is trivial. If we have no previous entries we start from the initial seed given by the user, otherwise we take do the linear extrapolation discussed above. A user also needs to provide an initial direction dmathbfz to go towards.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"function predictor(zs, dz0)\n    if length(zs) == 1\n        return zs[end]\n    elseif length(zs) == 2 # 1 entry is z0, 2nd entry is 1st found fixed point\n        return zs[end] .+ dz0\n    else\n        return 2zs[end] .- zs[end-1]\n    end\nend","category":"page"},{"location":"educational/#Code:-Continuation-function","page":"Educational introduction","title":"Code: Continuation function","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"Alright, now we can put it all together into the a single \"continuation\" function.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"function continuation!(zs, f, J; dz0, pmin, pmax)\n    zpred = predictor(zs, dz0)\n    (pmin ≤ zpred[end] ≤ pmax) || return false\n    zˣ, success = corrector(zpred, f, J)\n    push!(zs, zˣ)\n    return success\nend\n\nusing LinearAlgebra: eigvals\n\n# Continuation loop: do continuation for a given amount of steps\nfunction continuation(f, J, x0, p0; pmin, pmax, dp0, dx0, N = 1000)\n\n    z0 = vcat(x0, p0); zs = [z0]; dz0 = vcat(dx0, dp0)\n\n    ps = [p0]\n    xs = [x0]\n    stability = Bool[]\n    for i in 1:N\n        success = continuation!(zs, f, J; dz0, pmin, pmax)\n        # Stop iteration if we exceed given parameter margins\n        success || break\n        # Detect stability of found fixed point (needs `Array` coz of StaticArrays.jl)\n        eigenvalues = eigvals(J(zs[end][1:end-1], zs[end][end]))\n        isstable = maximum(real, eigenvalues) < 0\n        push!(stability, isstable)\n    end\n    xs = [z[1:end-1] for z in zs]\n    ps = [z[end] for z in zs]\n    popfirst!(xs); popfirst!(ps) # remove initial guess\n    return xs, ps, stability\nend","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"The code also returns the fixed point stability, although it does assume we have a continuous dynamical system. Adjusting for discrete systems is straightforward.","category":"page"},{"location":"educational/#Running-an-example","page":"Educational introduction","title":"Running an example","text":"","category":"section"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"Let's use the code we have defined to run an example. The following dynamical system has a single saddle node bifurcation, and a fixed point that is \"flat\" versus the parameter change.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"function maasch_rule(u, p)\n    x, y, z = u\n    q, r, s = 1.2, 0.8, 0.8\n    dx = -x - y\n    dy = -p*z + r*y + s*z^2 - z^2*y\n    dz = -q*(x + z)\n    return [dx, dy, dz]\nend\n\nfunction maasch_jacob(u, p)\n    x, y, z = u\n    q, r, s = 1.2, 0.8, 0.8\n    return [-1     -1  0;\n            0   (r - z^2)  (-p + 2z*s - 2z*y);\n            -q   0   -q]\nend","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"We now use it to get the bifurcation curve.","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"pmin = -0.1\npmax = 2\nδ = 0.9\np0 = 0.0\nx0 = [-1.4, -1.4, -1.4]\ndp0 = 0.02\ndx0 = [0.01, 0.01, 0.01]\n\nxs, ps, stability = continuation(maasch_rule, maasch_jacob, x0, p0;\n    pmin, pmax, dp0, dx0\n)","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"Let's plot this","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"using Plots\ncolors = [s ? :blue : :red for s in stability]\np = scatter(ps, [x[1] for x in xs]; color = colors, markerstrokecolor = colors, xlabel = \"p\", ylabel = \"x\", label = \"\")","category":"page"},{"location":"educational/","page":"Educational introduction","title":"Educational introduction","text":"","category":"page"},{"location":"periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method","page":"Shooting","title":"Periodic orbits based on the shooting method","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"Pages = [\"periodicOrbitShooting.md\"]\nDepth = 3","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"A set of shooting algorithms is provided which are called either Simple Shooting (SS) if a single shooting is used and Multiple Shooting (MS) otherwise. For the exposition, we follow the PhD thesis[Lust] and also [Umbria].","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We aim at finding periodic orbits for the Cauchy problem ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"tag1 fracd xd t=f(x)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"and we write phi^t(x_0) the associated flow (or semigroup of solutions).","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"tip: Tip about convenience functions\nFor convenience, we provide some functions plot_periodic_shooting for plotting, get_amplitude (resp. get_maximum) for getting the amplitude (resp. maximum) of the solution encoded by a shooting problem. See the tutorials for examples of use.","category":"page"},{"location":"periodicOrbitShooting/#Standard-Shooting","page":"Shooting","title":"Standard Shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/#Simple-shooting","page":"Shooting","title":"Simple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"A periodic orbit is found when we have a couple (x T) such that phi^T(x) = x and the trajectory is non constant. Therefore, we want to solve the equations G(xT)=0 given by","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"tagSS\nbeginarraylphi^T(x)-x=0  s(xT)=0endarray","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The section s(xT)=0 is a phase condition to remove the indeterminacy of the point on the limit cycle.","category":"page"},{"location":"periodicOrbitShooting/#Multiple-shooting","page":"Shooting","title":"Multiple shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"This case is similar to the previous one but more sections are used. To this end, we partition the unit interval with m+1 points 0=s_0s_1cdotss_m-1s_m=1 and consider the equations G(x_1cdotsx_mT)=0","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"beginaligned\nphi^delta s_1T(x_1)-x_2 =0  \nphi^delta s_2T(x_2)-x_3 =0   vdots  \nphi^delta s_m-1T(x_m-1)-x_m =0  \nphi^delta s_mT(x_m)-x_1 =0  s(x_1 T) =0 \nendalignedtagMS","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"where delta s_i=s_i+1-s_i. The Jacobian of the system of equations w.r.t. (xT) is given by ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"mathcalJ=left(beginarrayccmathcal J_c  partial_TG  star  dendarrayright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"where the cyclic matrix mathcal J_c is","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"mathcal J_c = \nleft(beginarrayccccc\nM_1  -I      \n  M_2  -I   \n    ddots  -I \n-I      M_m \nendarrayright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"and M_i=partial_xphi^delta s_i T(x_i).","category":"page"},{"location":"periodicOrbitShooting/#Section","page":"Shooting","title":"Section","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The periodic orbits solutions of (SS) or (MS) are not uniquely defined because of the phase invariance. A section s(xT)=0 (resp. s(x_1T)=0) for (SS) (resp. (MS)) must be provided. The default is the same for both $ s(x,T) = T\\cdot \\langle x-x_\\pi, \\phi\\rangle.$","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional","page":"Shooting","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The functional is encoded in the composite type ShootingProblem. In particular, the user can pass its own time stepper or one can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a solver tailored for the a specific problem. See the link ShootingProblem for more information ;  for example on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Poincaré-shooting","page":"Shooting","title":"Poincaré shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The algorithm is based on the one described in [Sanchez] and [Waugh]. ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We look for periodic orbits solutions of (1) using the hyperplanes Sigma_i=x   langle x-x^c_I n_irangle=0 for i=1cdotsM, centered on x^c_i, which intersect transversally an initial periodic orbit guess. We write Pi_iSigma_itoSigma_mod(i+1M), the Poincaré return map to Sigma_mod(i+1M). The main idea of the algorithm is to use the fact that the problem is (N-1)cdot M dimensional if x_iinmathbb R^N because each x_i lives in Sigma_i. Hence, one has to constrain the unknowns to these hyperplanes otherwise the Newton algorithm does not converge well.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We thus need to parametrize these hyperplanes.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"To this end, we introduce the projection operator R_imathbb R^Nto mathbb R^N-1 such that ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"R_ileft(x_1 x_2 ldots x_k_i-1 x_k_i x_k_i+1 ldots x_Nright)=left(x_1 x_2 ldots x_k_i-1 x_k_i+1 ldots x_Nright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"where k_i=argmax_p n_ip. The inverse operator E_imathbb R^N-1toSigma_i is defined by (where bar x=R_i(x))","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"E_i(bar x) = E_ileft(x_1 x_2 ldots x_k_i-1 x_k_i+1 ldots x_Nright)=\nleft(x_1 x_2 ldots x_k_i-1 x^c_ik_i-fracbarn_i cdotleft(overlinex-overlinex^c_iright)n_ik_i x_k_i+1 ldots x_Nright)","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We note that R_icirc E_i = I_mathbb R^N-1 and E_icirc R_i = I_mathbb R^N.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We then look for solutions of the following problem:","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"beginaligned \nbar x_1 - R_MPi_M(E_M(bar x_M))=0  \nbar x_2 - R_1Pi_1(E_i(bar x_1))=0   vdots  \nbar x_M - R_M-1Pi_M-1(E_M-1(bar x_M-1))=0 \nendaligned","category":"page"},{"location":"periodicOrbitShooting/#Encoding-of-the-functional-2","page":"Shooting","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The functional is encoded in the composite type PoincareShootingProblem. In particular, the user can pass their own time stepper or he can use the different ODE solvers in  DifferentialEquations.jl which makes it very easy to choose a tailored solver: the partial Poincaré return maps are implemented using callbacks. See the link PoincareShootingProblem for more information, in particular on how to access the underlying functional, its jacobian...","category":"page"},{"location":"periodicOrbitShooting/#Floquet-multipliers-computation","page":"Shooting","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitShooting/#Standard-shooting","page":"Shooting","title":"Standard shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The Floquet multipliers are computed as the eigenvalues of the monodromy matrix M=M_Mcdots M_1.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"Unlike the case with Finite differences, the matrices M_i are not sparse.","category":"page"},{"location":"periodicOrbitShooting/#Poincaré-shooting-2","page":"Shooting","title":"Poincaré shooting","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The (non trivial) Floquet exponents are eigenvalues of the Poincaré return map PiSigma_1toSigma_1. We have Pi = Pi_McircPi_M-1circcdotscircPi_2circPi_1. Its differential is thus","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"dPi(x)cdot h = dPi_M(x_M)dPi_M-1(x_M-1)cdots dPi_1(x_1)cdot h","category":"page"},{"location":"periodicOrbitShooting/#Numerical-method","page":"Shooting","title":"Numerical method","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We provide two methods to compute the Floquet coefficients.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"A not very precise algorithm for computing the Floquet multipliers is provided. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents. ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"It amounts to computing the eigenvalues of M=M_Mcdots M_1 (resp. dPi) for the Standard (resp. Poincaré) Shooting. The method allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaD.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The state of the art method is based on a Periodic Schur decomposition. It is available through the package PeriodicSchurBifurcationKit.jl. For more information, have a look at FloquetPQZ.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton","page":"Shooting","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We provide a simplified call to newton to locate the periodic orbit. Have a look at the tutorial Continuation of periodic orbits (Standard Shooting) for a simple example on how to use the above methods. ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The docs for this specific newton are located at newton.","category":"page"},{"location":"periodicOrbitShooting/#Computation-with-newton-and-deflation","page":"Shooting","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator:","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"newton(prob::BifurcationKit.AbstractShootingProblem,\n\t\t\t\torbitguess,\n\t\t\t\toptions::NewtonPar;\n\t\t\t\tlens::Union{Setfield.Lens, Nothing} = nothing,\n\t\t\t\tkwargs...)","category":"page"},{"location":"periodicOrbitShooting/#BifurcationKit.newton-Tuple{AbstractShootingProblem, Any, NewtonPar}","page":"Shooting","title":"BifurcationKit.newton","text":"newton(prob, orbitguess, options; lens, δ, kwargs...)\n\n\nThis is the Newton-Krylov Solver for computing a periodic orbit using the (Standard / Poincaré) Shooting method. Note that the linear solver has to be appropriately set up in options.\n\nArguments\n\nSimilar to newton except that prob is either a ShootingProblem or a PoincareShootingProblem. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.\n\nprob a problem of type <: AbstractShootingProblem encoding the shooting functional G.\norbitguess a guess for the periodic orbit. See ShootingProblem and See PoincareShootingProblem for information regarding the shape of orbitguess.\npar parameters to be passed to the functional\noptions same as for the regular newton method.\n\nOptional argument\n\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"and","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"newton(prob::BifurcationKit.AbstractShootingProblem,\n\t\t\t\torbitguess::vectype,\n\t\t\t\tdefOp::DeflationOperator{Tp, Tdot, T, vectype},\n\t\t\t\toptions::NewtonPar{T, S, E};\n\t\t\t\tlens::Union{Lens, Nothing} = nothing,\n\t\t\t\tkwargs...,\n\t\t\t) where {T, Tp, Tdot, vectype, S, E}","category":"page"},{"location":"periodicOrbitShooting/#Continuation","page":"Shooting","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"Have a look at the Continuation of periodic orbits (Standard Shooting) example for the Brusselator.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"In order to plot the orbit during continuation, one has to recompute the orbit inside a plotSolution function passed to continuation. This is simplified by the function get_periodic_orbit which returns a solution to be plotted. We refer to Period doubling in Lur'e problem for an example of use.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"The docs for this specific continuation are located at continuation.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"continuation(probPO::BifurcationKit.AbstractShootingProblem, orbitguess,\n\t\t\t\t\t\talg::BifurcationKit.AbstractContinuationAlgorithm,\n\t\t\t\t\t\tcontParams::ContinuationPar,\n\t\t\t\t\t\tlinear_algo::BifurcationKit.AbstractBorderedLinearSolver;\n\t\t\t\t\t\tδ = convert(eltype(orbitguess), 1e-8),\n\t\t\t\t\t\tkwargs...,\n\t\t\t\t\t)","category":"page"},{"location":"periodicOrbitShooting/#BifurcationKit.continuation-Tuple{AbstractShootingProblem, Any, BifurcationKit.AbstractContinuationAlgorithm, ContinuationPar, BifurcationKit.AbstractBorderedLinearSolver}","page":"Shooting","title":"BifurcationKit.continuation","text":"continuation(\n    probPO,\n    orbitguess,\n    alg,\n    contParams,\n    linear_algo;\n    δ,\n    eigsolver,\n    record_from_solution,\n    plot_solution,\n    kwargs...\n)\n\n\nThis is the continuation method for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar to continuation except that probPO is either a ShootingProblem or a PoincareShootingProblem. By default, it prints the period of the periodic orbit.\n\nOptional arguments\n\neigsolver specify an eigen solver for the computation of the Floquet exponents, defaults to FloquetQaD\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\n\n\n\n\n","category":"method"},{"location":"periodicOrbitShooting/#References","page":"Shooting","title":"References","text":"","category":"section"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"[Lust]: Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, Lust Kurt, 1997. ","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"[Umbria]: J. S. Umbría and M. Net. Numerical continuation methods for large-scale dissipative dynamical systems. The European Physical Journal Special Topics, 225(13):2465–2486, 2016.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"[Sanchez]: Sánchez, J., M. Net, B. Garcı́a-Archilla, and C. Simó. “Newton–Krylov Continuation of Periodic Orbits for Navier–Stokes Flows.” Journal of Computational Physics 201, no. 1 (November 20, 2004): 13–33. https://doi.org/10.1016/j.jcp.2004.04.018.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"[Waugh]: Waugh, Iain, Simon Illingworth, and Matthew Juniper. “Matrix-Free Continuation of Limit Cycles for Bifurcation Analysis of Large Thermoacoustic Systems.” Journal of Computational Physics 240 (May 2013): 225–47. https://doi.org/10.1016/j.jcp.2012.12.034.","category":"page"},{"location":"periodicOrbitShooting/","page":"Shooting","title":"Shooting","text":"","category":"page"},{"location":"codim2Continuation/#Fold-/-Hopf-Continuation","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"Pages = [\"codim2Continuation.md\"]\nDepth = 2","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"In this page, we explain how to perform continuation of Fold / Hopf points and detect the associated bifurcations.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"For this to work best, it is advised to have an analytical expression for the jacobian. See the tutorial Temperature model for more details although BifurcationProblem implement it with AD by default.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"A quite complete example for detection of codim 2 bifurcations of equilibria is Extended Lorenz-84 model (codim 2 + BT/ZH aBS).","category":"page"},{"location":"codim2Continuation/#List-of-detected-codim-2-bifurcation-points","page":"Fold / Hopf Continuation (2 params)","title":"List of detected codim 2 bifurcation points","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"Bifurcation symbol used\nBogdanov-Takens bt\nBautin gh\nCusp cusp\nZero-Hopf zh\nHopf-Hopf hh","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"In a nutshell, all you have to do (see below) is to call continuation(br, ind_bif, lens2) to continue the bifurcation point stored in br.specialpoint[ind_bif] and set proper options.","category":"page"},{"location":"codim2Continuation/#Fold-continuation","page":"Fold / Hopf Continuation (2 params)","title":"Fold continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"The continuation of Fold bifurcation points is based on a Minimally Augmented[Govaerts] formulation which is an efficient way to detect singularities. The continuation of Fold points is based on the formulation","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"G(up) = (F(up) sigma(up))inmathbb R^n+1quadquad (F_f)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"where the test function sigma is solution of","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"leftbeginarraycc\ndF(up)  w \nv^top  0\nendarrayrightleftbeginarrayc\nr \nsigma(up)\nendarrayright=leftbeginarrayc0_n 1endarrayrightquadquad (M_f)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"where wv are chosen in order to have a non-singular matrix (M_f). More precisely, v (resp. w) should be close to a null vector of dF(u,p) (resp. dF(u,p)'). During continuation, the vectors wv are updated so that the matrix (M_f) remains non-singular ; this is controlled with the argument update_minaug_every_step (see below).","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"note that there are very simplified calls for this, see Newton refinement below. In particular, you don't need to set up the Fold Minimally Augmented problem yourself. This is done in the background.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"warning: Linear Method\nYou can pass the bordered linear solver to solve (M_f) using the option bdlinsolver (see below). Note that the choice bdlinsolver = BorderingBLS() can lead to singular systems. Indeed, in this case, (M_f) is solved by inverting dF(u,p) which is singular at Fold points.","category":"page"},{"location":"codim2Continuation/#Detection-of-codim-2-bifurcation-points","page":"Fold / Hopf Continuation (2 params)","title":"Detection of codim 2 bifurcation points","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"You can detect the following codim 2 bifurcation points by using the option detect_codim2_bifurcation in the method continuation. Under the hood, the detection of these bifurcations is done by using Event detection as explained in Event Handling.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"the detection of Cusp (Cusp) is done by the detection of Fold bifurcation points along the curve of Folds by monitoring the parameter component of the tangent.\nthe detection of Bogdanov-Takens (BT) is performed using the test function[Bindel] psi_BT(p) = langle w(p)v(p)rangle\nthe detection of Zero-Hopf (ZH) is performed by monitoring the number of eigenvalues lambda such that Relambda  minlimits_nuinSigma(dF)Renu and Imlambda  epsilon where epsilon is the Newton tolerance.","category":"page"},{"location":"codim2Continuation/#Hopf-continuation","page":"Fold / Hopf Continuation (2 params)","title":"Hopf continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"The continuation of Fold bifurcation points is based on a Minimally Augmented (see [Govaerts] p. 87) formulation which is an efficient way to detect singularities. The continuation of Hopf points is based on the formulation","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"G(uomegap) = (F(uomegap) Resigma(uomegap) Imsigma(uomegap))inmathbb R^n+2quadquad (F_h)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"where the test function sigma is solution of","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"leftbeginarraycc\ndF(up)-iomega I_n  w \nv^top  0\nendarrayrightleftbeginarrayc\nr \nsigma(uomegap)\nendarrayright=leftbeginarrayc\n0_n \n1\nendarrayrightquadquad (M_h)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"where wv are chosen in order to have a non-singular matrix (M_h). More precisely, w (resp. v) should be a left (resp. right) approximate null vector of dF(up)-iomega I_n. During continuation, the vectors wv are updated so that the matrix (M_h) remains non-singular ; this is controlled with the argument update_minaug_every_step (see below).","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"note that there are very simplified calls to this, see Newton refinement below. In particular, you don't need to set up the Hopf Minimally Augmented problem yourself. This is done in the background.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"warning: Linear Method\nYou can pass the bordered linear solver to solve (M_h) using the option bdlinsolver (see below). Note that the choice bdlinsolver = BorderingBLS() can lead to singular systems. Indeed, in this case, (M_h) is solved by inverting dF(u,p)-iω I_n which is singular at Hopf points.","category":"page"},{"location":"codim2Continuation/#Detection-of-codim-2-bifurcation-points-2","page":"Fold / Hopf Continuation (2 params)","title":"Detection of codim 2 bifurcation points","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"You can detect the following codim 2 bifurcation points by using the option detect_codim2_bifurcation in the method continuation. Under the hood, the detection of these bifurcations is done by using Event detection as explained in Event Handling.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"the detection of Bogdanov-Takens (BT) is performed using the test function[Bindel],[Blank] psi_BT(p) = \tlangle w(p)v(p)rangle\nthe detection of Bautin (GH) is based on the test function psi_GH(p) = Re(l_1(p)) where l_1 is the Lyapunov coefficient defined in Simple Hopf point.\nthe detection of Zero-Hopf (ZH) is performed by monitoring the eigenvalues.\nthe detection of Hopf-Hopf (HH) is performed by monitoring the eigenvalues.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"The continuation of Hopf points is stopped at BT and when omega100epsilon where epsilon is the newton tolerance.","category":"page"},{"location":"codim2Continuation/#jac-fold","page":"Fold / Hopf Continuation (2 params)","title":"Setting the jacobian","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"In order to apply the newton algorithm to F_f or F_h, one needs to invert the jacobian. This is not completely trivial as one must compute this jacobian and then invert it. You can select the following jacobians for your computations (see below):","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"[Default] for jacobian_ma = :autodiff, automatic differentiation is applied to F_f (or F_h) and the matrix is then inverted using the provided linear solver. In particular, the jacobian is formed. This is very well suited for small dimensions  (say < 100)\nfor jacobian_ma = :minaug, a specific procedure for evaluating the jacobian F_f (or F_h) and inverting it (without forming the jacobian!) is used. This is well suited for large dimensions.","category":"page"},{"location":"codim2Continuation/#Newton-refinement","page":"Fold / Hopf Continuation (2 params)","title":"Newton refinement","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"Once a Fold / Hopf point has been detected after a call to br = continuation(...), it can be refined using newton iterations. Let us say that ind_bif is the index in br.specialpoint of a Fold / Hopf point. This guess can be refined as follows:","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"outfold = newton(br::AbstractBranchResult, ind_bif::Int;  \n\tnormN = norm, options = br.contparams.newton_options,\n\tbdlinsolver = BorderingBLS(options.linsolver),\n\tstart_with_eigen = false, kwargs...)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"For the options parameters, we refer to Newton.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"It is important to note that for improved performances, a function implementing the expression of the hessian should be provided. This is by far the fastest. BifurcationProblem provides it by default using AD though.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"Reader interested in this advanced usage should look at the code example/chan.jl of the tutorial Temperature model.","category":"page"},{"location":"codim2Continuation/#Codim-2-continuation","page":"Fold / Hopf Continuation (2 params)","title":"Codim 2 continuation","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"To compute the codim 2 curve of Fold / Hopf points, one can call continuation with the following options","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":" continuation(br::BifurcationKit.AbstractBranchResult, ind_bif::Int64,\n\t\t\t\tlens2::Lens, options_cont::ContinuationPar = br.contparams ;\n\t\t\t\tkwargs...)","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"where the options are as above except with have an additional parameter axis lens2 which is used to locate the bifurcation points.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"See Temperature model for an example of use.","category":"page"},{"location":"codim2Continuation/#Advanced-use","page":"Fold / Hopf Continuation (2 params)","title":"Advanced use","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"Here, we expose the solvers that are used to perform newton refinement or codim 2 continuation in case the above methods fails. This is useful in case it is too involved to expose the linear solver options. An example of advanced use is the continuation of Folds of periodic orbits, see Continuation of Fold of periodic orbits.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"newton_fold","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"newton_hopf","category":"page"},{"location":"codim2Continuation/#BifurcationKit.newton_hopf","page":"Fold / Hopf Continuation (2 params)","title":"BifurcationKit.newton_hopf","text":"newton_hopf(\n    prob,\n    hopfpointguess,\n    par,\n    eigenvec,\n    eigenvec_ad,\n    options;\n    normN,\n    bdlinsolver,\n    usehessian,\n    kwargs...\n)\n\n\nThis function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows\n\nprob::AbstractBifurcationProblem where p is a set of parameters.\nhopfpointguess initial guess (x0, p0) for the Hopf point. It should a BorderedArray as returned by the function HopfPoint.\npar parameters used for the vector field\neigenvec guess for the  iω eigenvector\neigenvec_ad guess for the -iω eigenvector\noptions::NewtonPar options for the Newton-Krylov algorithm, see NewtonPar.\n\nOptional arguments:\n\nnormN = norm\nbdlinsolver bordered linear solver for the constraint equation\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\nSimplified call:\n\nSimplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows\n\nnewton_hopf(br::AbstractBranchResult, ind_hopf::Int; normN = norm, options = br.contparams.newton_options, kwargs...)\n\nThe parameters / options are as usual except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of bifurcation point in br you want to refine. You can pass newton parameters different from the ones stored in br by using the argument options.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian will be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option bdlinsolver = MatrixBLS()\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"continuation_fold","category":"page"},{"location":"codim2Continuation/#BifurcationKit.continuation_fold","page":"Fold / Hopf Continuation (2 params)","title":"BifurcationKit.continuation_fold","text":"continuation_fold(\n    prob,\n    alg,\n    foldpointguess,\n    par,\n    lens1,\n    lens2,\n    eigenvec,\n    eigenvec_ad,\n    options_cont;\n    update_minaug_every_step,\n    normC,\n    bdlinsolver,\n    bdlinsolver_adjoint,\n    jacobian_ma,\n    compute_eigen_elements,\n    usehessian,\n    kind,\n    record_from_solution,\n    kwargs...\n)\n\n\nCodim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows\n\nprob::AbstractBifurcationFunction\nfoldpointguess initial guess (x0, p10) for the Fold point. It should be a BorderedArray as returned by the function foldpoint\npar set of parameters\nlens1 parameter axis for parameter 1\nlens2 parameter axis for parameter 2\neigenvec guess for the right null vector\neigenvec_ad guess for the left null vector\noptions_cont arguments to be passed to the regular continuation\n\nOptional arguments:\n\njacobian_ma::Symbol = :autodiff, how the linear system of the Fold problem is solved. Can be :autodiff, :finiteDifferencesMF, :finiteDifferences, :minaug\nbdlinsolver bordered linear solver for the constraint equation with top-left block J. Required in the linear solver for the Minimally Augmented Fold functional. This option can be used to pass a dedicated linear solver for example with specific preconditioner.\nbdlinsolver_adjoint bordered linear solver for the constraint equation with top-left block J^*. Required in the linear solver for the Minimally Augmented Fold functional. This option can be used to pass a dedicated linear solver for example with specific preconditioner.\nupdate_minaug_every_step update vectors a, b in Minimally Formulation every update_minaug_every_step steps\ncompute_eigen_elements = false whether to compute eigenelements. If options_cont.detect_event>0, it allows the detection of ZH points.\nkwargs keywords arguments to be passed to the regular continuation\n\nSimplified call\n\ncontinuation_fold(br::AbstractBranchResult, ind_fold::Int64, lens2::Lens, options_cont::ContinuationPar ; kwargs...)\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Fold point in br that you want to continue.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\ntip: ODE problems\nFor ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option bdlinsolver = MatrixBLS(). This is the default setting.\n\ntip: Detection of Bogdanov-Takens and Cusp bifurcations\nIn order to trigger the detection, pass detect_event = 1 or 2 in options_cont.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"continuation_hopf","category":"page"},{"location":"codim2Continuation/#BifurcationKit.continuation_hopf","page":"Fold / Hopf Continuation (2 params)","title":"BifurcationKit.continuation_hopf","text":"continuation_hopf(\n    prob_vf,\n    alg,\n    hopfpointguess,\n    par,\n    lens1,\n    lens2,\n    eigenvec,\n    eigenvec_ad,\n    options_cont;\n    update_minaug_every_step,\n    normC,\n    linsolve_adjoint,\n    bdlinsolver,\n    bdlinsolver_adjoint,\n    jacobian_ma,\n    compute_eigen_elements,\n    usehessian,\n    kind,\n    massmatrix,\n    record_from_solution,\n    kwargs...\n)\n\n\ncodim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\nprob::AbstractBifurcationProblem\nhopfpointguess initial guess (x0, p10) for the Hopf point. It should be a Vector or a BorderedArray\npar set of parameters\nlens1 parameter axis for parameter 1\nlens2 parameter axis for parameter 2\neigenvec guess for the iω eigenvector at p1_0\neigenvec_ad guess for the -iω eigenvector at p1_0\noptions_cont keywords arguments to be passed to the regular continuation\n\nOptional arguments:\n\njacobian_ma::Symbol = :autodiff, how the linear system of the Fold problem is solved. Can be :autodiff, :finiteDifferencesMF, :finiteDifferences, :minaug\nlinsolve_adjoint solver for (J+iω)^* ⋅sol = rhs\nbdlinsolver bordered linear solver for the constraint equation with top-left block (J-iω). Required in the linear solver for the Minimally Augmented Hopf functional. This option can be used to pass a dedicated linear solver for example with specific preconditioner.\nbdlinsolver_adjoint bordered linear solver for the constraint equation with top-left block (J-iω)^*. Required in the linear solver for the Minimally Augmented Hopf functional. This option can be used to pass a dedicated linear solver for example with specific preconditioner.\nupdate_minaug_every_step update vectors a,b in Minimally Formulation every update_minaug_every_step steps\ncompute_eigen_elements = false whether to compute eigenelements. If options_cont.detect_event>0, it allows the detection of ZH, HH points.\nkwargs keywords arguments to be passed to the regular continuation\n\nSimplified call:\n\ncontinuation_hopf(br::AbstractBranchResult, ind_hopf::Int, lens2::Lens, options_cont::ContinuationPar ;  kwargs...)\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Hopf point in br that you want to refine.\n\ntip: ODE problems\nFor ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option bdlinsolver = MatrixBLS(). This is the default setting.\n\ntip: Jacobian transpose\nThe adjoint of the jacobian J is computed internally when Jᵗ = nothing by using transpose(J) which works fine when J is an AbstractArray. In this case, do not pass the jacobian adjoint like Jᵗ = (x, p) -> transpose(d_xF(x, p)) otherwise the jacobian would be computed twice!\n\ntip: Detection of Bogdanov-Takens and Bautin bifurcations\nIn order to trigger the detection, pass detect_event = 1,2 in options_cont. Note that you need to provide d3F in prob.\n\n\n\n\n\n","category":"function"},{"location":"codim2Continuation/#Algorithmic-details-(Fold)","page":"Fold / Hopf Continuation (2 params)","title":"Algorithmic details (Fold)","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"If we write (ssigma) the solution of the adjoint problem associated to (M_f), one can show[Govaerts] that the differential of sigma satisfies:","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"partial sigma + langle spartial dF cdot rrangle = 0","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"This allows to compute the jacobian of the Fold functional to use for the Newton algorithm:","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"leftbeginarraycc\npartial_uF(up)  partial_pF(up) \npartial_xsigma(up)  partial_psigma(up)\nendarrayright","category":"page"},{"location":"codim2Continuation/#Algorithmic-details-(Hopf)","page":"Fold / Hopf Continuation (2 params)","title":"Algorithmic details (Hopf)","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"We recall that the unknowns are (xpomega). The jacobian of the Hopf functional to use for the Newton algorithm is","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"leftbeginarrayccc\npartial_uF  partial_pF  0 \npartial_xsigma_r  partial_psigma_r  partial_omegasigma_r\npartial_xsigma_i  partial_psigma_i  partial_omegasigma_i\nendarrayright","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"using a similar formula for partialsigma as in the Fold case.","category":"page"},{"location":"codim2Continuation/#References","page":"Fold / Hopf Continuation (2 params)","title":"References","text":"","category":"section"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"[Govaerts]: Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"[Blank]: Blank, H. J. de, Yu. A. Kuznetsov, M. J. Pekkér, and D. W. M. Veldman. “Degenerate Bogdanov–Takens Bifurcations in a One-Dimensional Transport Model of a Fusion Plasma.” Physica D: Nonlinear Phenomena 331 (September 15, 2016): 13–26. https://doi.org/10.1016/j.physd.2016.05.008.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"[Bindel]: Bindel, D., M. Friedman, W. Govaerts, J. Hughes, and Yu.A. Kuznetsov. “Numerical Computation of Bifurcations in Large Equilibrium Systems in Matlab.” Journal of Computational and Applied Mathematics 261 (May 2014): 232–48. https://doi.org/10.1016/j.cam.2013.10.034.","category":"page"},{"location":"codim2Continuation/","page":"Fold / Hopf Continuation (2 params)","title":"Fold / Hopf Continuation (2 params)","text":"","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Parameters","page":"Library","title":"Parameters","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"NewtonPar","category":"page"},{"location":"library/#BifurcationKit.NewtonPar","page":"Library","title":"BifurcationKit.NewtonPar","text":"struct NewtonPar{T, L<:BifurcationKit.AbstractLinearSolver, E<:AbstractEigenSolver}\n\nReturns a variable containing parameters to affect the newton algorithm when solving F(x) = 0.\n\nArguments (with default values):\n\ntol::Any: absolute tolerance for F(x) Default: 1.0e-12\nmax_iterations::Int64: number of Newton iterations Default: 25\nverbose::Bool: display Newton iterations? Default: false\nlinsolver::BifurcationKit.AbstractLinearSolver: linear solver, must be <: AbstractLinearSolver Default: DefaultLS()\neigsolver::AbstractEigenSolver: eigen solver, must be <: AbstractEigenSolver Default: DefaultEig()\nlinesearch::Bool: Default: false\nα::Any: Default: convert(typeof(tol), 1.0)\nαmin::Any: Default: convert(typeof(tol), 0.001)\n\nArguments for line search (Armijo)\n\nlinesearch = false: use line search algorithm (i.e. Newton with Armijo's rule)\nα = 1.0: initial value of α (damping) parameter for line search algorithm\nαmin  = 0.001: minimal value of the damping alpha\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See the tutorials for examples.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ContinuationPar","category":"page"},{"location":"library/#BifurcationKit.ContinuationPar","page":"Library","title":"BifurcationKit.ContinuationPar","text":"options = ContinuationPar(dsmin = 1e-4,...)\n\nReturns a variable containing parameters to affect the continuation algorithm used to solve F(x, p) = 0.\n\nArguments\n\ndsmin, dsmax are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.\nds = 0.01 is the initial arclength.\np_min, p_max allowed parameter range for p\nmax_steps = 100 maximum number of continuation steps\nnewton_options::NewtonPar: options for the Newton algorithm\nsave_to_file = false: save to file. A name is automatically generated or can be defined in continuation. This requires using JLD2.\nsave_sol_every_step::Int64 = 0 at which continuation steps do we save the current solution\nplot_every_step = 10 at which continuation steps do we plot the current solution\n\nHandling eigen elements, their computation is triggered by the argument detect_bifurcation (see below)\n\nnev = 3 number of eigenvalues to be computed. It is automatically increased to have at least nev unstable eigenvalues. To be set for proper  bifurcation detection. See Detection of bifurcation points of Equilibria for more informations.\nsave_eig_every_step = 1 record eigen vectors every specified steps. Important for memory limited resource, e.g. GPU.\nsave_eigenvectors = true Important for memory limited resource, e.g. GPU.\n\nHandling bifurcation detection\n\ntol_stability = 1e-10 lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits\ndetect_fold = true detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)\ndetect_bifurcation::Int ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)\ndsmin_bisection = 1e-16 dsmin for the bisection algorithm for locating bifurcation points\nn_inversion = 2 number of sign inversions in bisection algorithm\nmax_bisection_steps = 15 maximum number of bisection steps\ntol_bisection_eigenvalue = 1e-16 tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps\n\nHandling ds adaptation (see continuation for more information)\n\na  = 0.5 aggressiveness factor. It is used to adapt ds in order to have a number of newton iterations per continuation step roughly constant. The higher a is, the larger the step size ds is changed at each continuation step.\n\nHandling event detection\n\ndetect_event::Int ∈ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are sought during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).\ntol_param_bisection_event = 1e-16 tolerance on parameter to locate event\n\nMisc\n\nη = 150. parameter to estimate tangent at first point with parameter  p₀ + ds / η\ndetect_loop [WORK IN PROGRESS] detect loops in the branch and stop the continuation\n\ntip: Mutating\nFor performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package Setfield.jl to drastically simplify the mutation of different fields. See tutorials for more examples.\n\n\n\n\n\n","category":"type"},{"location":"library/#Results","page":"Library","title":"Results","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"NonLinearSolution","category":"page"},{"location":"library/#BifurcationKit.NonLinearSolution","page":"Library","title":"BifurcationKit.NonLinearSolution","text":"Structure which holds the solution from application of Newton-Krylov algorithm to a nonlinear problem.\n\nFor example\n\nsol = newton(prob, NewtonPar())\n\nFields\n\nu::Any: solution\nprob::Any: nonlinear problem, typically a BifurcationProblem\nresiduals::Any: sequence of residuals\nconverged::Bool: has algorithm converged?\nitnewton::Int64: number of newton steps\nitlineartot::Any: total number of linear iterations\n\nmethods\n\nconverged(sol) return whether the solution has converged.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ContResult","category":"page"},{"location":"library/#BifurcationKit.ContResult","page":"Library","title":"BifurcationKit.ContResult","text":"struct ContResult{Tkind<:BifurcationKit.AbstractContinuationKind, Tbr, Teigvals, Teigvec, Biftype, Tsol, Tparc, Tprob, Talg} <: BifurcationKit.AbstractResult{Tkind<:BifurcationKit.AbstractContinuationKind, Tprob}\n\nStructure which holds the results after a call to continuation.\n\nYou can see the propertynames of a result br by using propertynames(br) or propertynames(br.branch).\n\nFields\n\nbranch::StructArrays.StructArray: holds the low-dimensional information about the branch. More precisely, branch[i+1] contains the following information (record_from_solution(u, param), param, itnewton, itlinear, ds, θ, n_unstable, n_imag, stable, step) for each continuation step i.\nitnewton number of Newton iterations\nitlinear total number of linear iterations during newton (corrector)\nn_unstable number of eigenvalues with positive real part for each continuation step (to detect stationary bifurcation)\nn_imag number of eigenvalues with positive real part and non zero imaginary part at current continuation step (useful to detect Hopf bifurcation).\nstable stability of the computed solution for each continuation step. Hence, stable should match eig[step] which corresponds to branch[k] for a given k.\nstep continuation step (here equal i)\neig::Array{@NamedTuple{eigenvals::Teigvals, eigenvecs::Teigvec, converged::Bool, step::Int64}, 1} where {Teigvals, Teigvec}: A vector with eigen-elements at each continuation step.\nsol::Any: Vector of solutions sampled along the branch. This is set by the argument save_sol_every_step::Int64 (default 0) in ContinuationPar.\ncontparams::Any: The parameters used for the call to continuation which produced this branch. Must be a ContinuationPar\nkind::BifurcationKit.AbstractContinuationKind: Type of solutions computed in this branch. Default: EquilibriumCont()\nprob::Any: Bifurcation problem used to compute the branch, useful for branch switching. For example, when computing periodic orbits, the functional PeriodicOrbitTrapProblem, ShootingProblem... will be saved here. Default: nothing\nspecialpoint::Vector: A vector holding the set of detected bifurcation points. See SpecialPoint for a list of special points.\nalg::Any: Continuation algorithm used for the computation of the branch\n\nAssociated methods\n\nlength(br) number of the continuation steps\nshow(br) display information about the branch\neigenvals(br, ind) returns the eigenvalues for the ind-th continuation step\neigenvec(br, ind, indev) returns the indev-th eigenvector for the ind-th continuation step\nget_normal_form(br, ind) compute the normal form of the ind-th points in br.specialpoint\ngetlens(br) return the parameter axis used for the branch\ngetlenses(br) return the parameter two axis used for the branch when 2 parameters continuation is used (Fold, Hopf, NS, PD)\nbr[k+1] gives information about the k-th step. A typical run yields the following\n\njulia> br[1]\n(x = 0.0, param = 0.1, itnewton = 0, itlinear = 0, ds = -0.01, θ = 0.5, n_unstable = 2, n_imag = 2, stable = false, step = 0, eigenvals = ComplexF64[0.1 - 1.0im, 0.1 + 1.0im], eigenvecs = ComplexF64[0.7071067811865475 - 0.0im 0.7071067811865475 + 0.0im; 0.0 + 0.7071067811865475im 0.0 - 0.7071067811865475im])\n\nwhich provides the value param of the parameter of the current point, its stability, information on the newton iterations, etc. The fields can be retrieved using propertynames(br.branch). This information is stored in br.branch which is a StructArray. You can thus extract the vector of parameters along the branch as\n\njulia> br.param\n10-element Vector{Float64}:\n 0.1\n 0.08585786437626905\n 0.06464466094067263\n 0.03282485578727799\n-1.2623798512809007e-5\n-0.07160718539365075\n-0.17899902778635765\n-0.3204203840236672\n-0.4618417402609767\n-0.5\n\nget_solx(br, k) returns the k-th solution on the branch\nget_solp(br, k) returns the parameter  value associated with k-th solution on the branch\ngetparams(br) Parameters passed to continuation and used in the equation F(x, par) = 0.\nsetparam(br, p0) set the parameter value p0 according to ::Lens for the parameters of the problem br.prob\ngetlens(br) get the lens used for the computation of the branch\ncontinuation(br, ind) performs automatic branch switching (aBS) from ind-th bifurcation point. Typically branching from equilibrium to equilibrium, or periodic orbit to periodic orbit.\ncontinuation(br, ind, lens2) performs two parameters (getLens(br), lens2) continuation of the  ind-th bifurcation point.\ncontinuation(br, ind, probPO::AbstractPeriodicOrbitProblem) performs aBS from ind-th bifurcation point (which must be a Hopf bifurcation point) to branch of periodic orbits.\n\n\n\n\n\n","category":"type"},{"location":"library/#Problems","page":"Library","title":"Problems","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"BifFunction","category":"page"},{"location":"library/#BifurcationKit.BifFunction","page":"Library","title":"BifurcationKit.BifFunction","text":"struct BifFunction{Tf, Tdf, Tdfad, Tj, Tjad, Td2f, Td2fc, Td3f, Td3fc, Tsym, Tδ} <: BifurcationKit.AbstractBifurcationFunction\n\nStructure to hold the vector field and its derivatives. It should rarely be called directly. Also, in essence, it is very close to SciMLBase.ODEFunction.\n\nFields\n\nF::Any: Vector field. Function of type out-of-place result = f(x, p) or inplace f(result, x, p). For type stability, the types of x and result should match\ndF::Any: Differential of F with respect to x, signature dF(x,p,dx)\ndFad::Any: Adjoint of the Differential of F with respect to x, signature dFad(x,p,dx)\nJ::Any: Jacobian of F at (x, p). It can assume three forms.         1. Either J is a function and J(x, p) returns a ::AbstractMatrix. In this case, the default arguments of contparams::ContinuationPar will make continuation work.         2. Or J is a function and J(x, p) returns a function taking one argument dx and returning dr of the same type as dx. In our notation, dr = J * dx. In this case, the default parameters of contparams::ContinuationPar will not work and you have to use a Matrix Free linear solver, for example GMRESIterativeSolvers,         3. Or J is a function and J(x, p) returns a variable j which can assume any type. Then, you must implement a linear solver ls as a composite type, subtype of AbstractLinearSolver which is called like ls(j, rhs) and which returns the solution of the jacobian linear system. See for example examples/SH2d-fronts-cuda.jl. This linear solver is passed to NewtonPar(linsolver = ls) which itself passed to ContinuationPar. Similarly, you have to implement an eigensolver eig as a composite type, subtype of AbstractEigenSolver.\nJᵗ::Any: jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, transpose is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, Jᵗ should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass Jᵗ = (x, p) -> transpose(dF(x, p)).\nd2F::Any: Second Differential of F with respect to x, signature d2F(x,p,dx1,dx2)\nd3F::Any: Third Differential of F with respect to x, signature d3F(x,p,dx1,dx2,dx3)\nd2Fc::Any: [internal] Second Differential of F with respect to x which accept complex vectors dxi\nd3Fc::Any: [internal] Third Differential of F with respect to x which accept complex vectors dxi\nisSymmetric::Any: Whether the jacobian is auto-adjoint.\nδ::Any: used internally to compute derivatives (with finite differences), for example for normal form computation and codim 2 continuation.\ninplace::Bool: optionally sets whether the function is inplace or not\n\nMethods\n\nresidual(pb::BifFunction, x, p) calls pb.F(x,p)\njacobian(pb::BifFunction, x, p) calls pb.J(x, p)\ndF(pb::BifFunction, x, p, dx) calls pb.dF(x,p,dx)\netc\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationProblem","category":"page"},{"location":"library/#BifurcationKit.BifurcationProblem","page":"Library","title":"BifurcationKit.BifurcationProblem","text":"struct BifurcationProblem{Tvf, Tu, Tp, Tl<:Lens, Tplot, Trec} <: BifurcationKit.AbstractAllJetBifProblem\n\nStructure to hold the bifurcation problem.\n\nFields\n\nVF::Any: Vector field, typically a BifFunction\nu0::Any: Initial guess\nparams::Any: parameters\nlens::Lens: Typically a Setfield.Lens. It specifies which parameter axis among params is used for continuation. For example, if par = (α = 1.0, β = 1), we can perform continuation w.r.t. α by using lens = (@lens _.α). If you have an array par = [ 1.0, 2.0] and want to perform continuation w.r.t. the first variable, you can use lens = (@lens _[1]). For more information, we refer to SetField.jl.\nplotSolution::Any: user function to plot solutions during continuation. Signature: plot_solution(x, p; kwargs...) for Plot.jl and plot_solution(ax, x, p; kwargs...) for the Makie package(s).\nrecordFromSolution::Any: record_from_solution = (x, p) -> norm(x) function used record a few indicators about the solution. It could be norm or (x, p) -> x[1]. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU). This function can return pretty much everything but you should keep it small. For example, you can do (x, p) -> (x1 = x[1], x2 = x[2], nrm = norm(x)) or simply (x, p) -> (sum(x), 1). This will be stored in contres.branch where contres::ContResult is the continuation curve of the bifurcation problem. Finally, the first component is used for plotting in the continuation curve.\n\nMethods\n\nre_make(pb; kwargs...) modify a bifurcation problem\ngetu0(pb) calls pb.u0\ngetparams(pb) calls pb.params\ngetlens(pb) calls pb.lens\ngetparam(pb) calls get(pb.params, pb.lens)\nsetparam(pb, p0) calls set(pb.params, pb.lens, p0)\nrecord_from_solution(pb) calls pb.recordFromSolution\nplot_solution(pb) calls pb.plotSolution\nis_symmetric(pb) calls is_symmetric(pb.prob)\n\nConstructors\n\nBifurcationProblem(F, u0, params, lens) all derivatives are computed using ForwardDiff.\nBifurcationProblem(F, u0, params, lens; J, Jᵗ, d2F, d3F, kwargs...) and kwargs are the fields above. You can pass your own jacobian with J (see BifFunction for description of the jacobian function) and jacobian adjoint with Jᵗ. For example, this can be used to provide finite differences based jacobian using BifurcationKit.finiteDifferences.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"DeflationOperator","category":"page"},{"location":"library/#BifurcationKit.DeflationOperator","page":"Library","title":"BifurcationKit.DeflationOperator","text":"struct DeflationOperator{Tp<:Real, Tdot, T<:Real, vectype} <: BifurcationKit.AbstractDeflationFactor\n\nStructure for defining a custom distance.\n\nThis operator allows to handle the following situation. Assume you want to solve F(x)=0 with a Newton algorithm but you want to avoid the process to return some already known solutions roots_i. The deflation operator penalizes these roots. You can create a DeflationOperator to define a scalar function M(u) used to find, with Newton iterations, the zeros of the following function F(u) cdot Π_i(u - root_i^-2p + alpha) = F(u) cdot M(u) where u^2 = dot(u u). The fields of the struct DeflationOperator are as follows:\n\npower::Real: power p. You can use an Int for example\ndot::Any: function, this function has to be bilinear and symmetric for the linear solver to work well\nα::Real: shift\nroots::Vector: roots\ntmp::Any\nautodiff::Bool\nδ::Real\n\nGiven defOp::DeflationOperator, one can access its roots via defOp[n] as a shortcut for defOp.roots[n]. Note that you can also use defOp[end].\n\nAlso, one can add (resp. remove) a new root by using push!(defOp, newroot) (resp. pop!(defOp)). Finally length(defOp) is a shortcut for length(defOp.roots)\n\nConstructors\n\nDeflationOperator(p::Real, α::Real, roots::Vector{vectype}; autodiff = false)\nDeflationOperator(p::Real, dt, α::Real, roots::Vector{vectype}; autodiff = false)\nDeflationOperator(p::Real, α::Real, roots::Vector{vectype}, v::vectype; autodiff = false)\n\nThe option autodiff triggers the use of automatic differentiation for the computation of the gradient of the scalar function M. This works only on AbstractVector for now.\n\nCustom distance\n\nYou are asked to pass a scalar product like dot to build a DeflationOperator. However, in some cases, you may want to pass a custom distance dist(u, v). You can do this using\n\n`DeflationOperator(p, CustomDist(dist), α, roots)`\n\nNote that passing CustomDist(dist, true) will trigger the use of automatic differentiation for the gradient of M.\n\nLinear solvers\n\nWhen used with newton, you have access to the following linear solvers\n\ncustom solver DeflatedProblemCustomLS() which requires solving two linear systems J⋅x = rhs.\nFor other linear solvers <: AbstractLinearSolver, a matrix free method is used for the deflated functional.\nif passed Val(:autodiff), then ForwardDiff.jl is used to compute the jacobian Matrix of the deflated problem\nif passed Val(:fullIterative), then a full matrix free method is used for the deflated problem.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"DeflatedProblem","category":"page"},{"location":"library/#BifurcationKit.DeflatedProblem","page":"Library","title":"BifurcationKit.DeflatedProblem","text":"pb = DeflatedProblem(prob, M::DeflationOperator, jactype)\n\nCreate a DeflatedProblem.\n\nThis creates a deflated functional (problem) M(u) cdot F(u) = 0 where M is a DeflationOperator which encodes the penalization term. prob is an AbstractBifurcationProblem which encodes the functional. It is not meant not be used directly albeit by advanced users.\n\n\n\n\n\n","category":"type"},{"location":"library/#Periodic-orbits","page":"Library","title":"Periodic orbits","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PeriodicOrbitTrapProblem","category":"page"},{"location":"library/#BifurcationKit.PeriodicOrbitTrapProblem","page":"Library","title":"BifurcationKit.PeriodicOrbitTrapProblem","text":"This composite type implements Finite Differences based on a Trapezoidal rule (Order 2 in time) to locate periodic orbits. More details (maths, notations, linear systems) can be found here.\n\nFields\n\nprob a bifurcation problem\nM::Int number of time slices\nϕ used to set a section for the phase constraint equation, of size N*M\nxπ used in the section for the phase constraint equation, of size N*M\nlinsolver: = DefaultLS() linear solver for each time slice, i.e. to solve J⋅sol = rhs. This is only needed for the computation of the Floquet multipliers in a full matrix-free setting.\nongpu::Bool whether the computation takes place on the gpu (Experimental)\nmassmatrix a mass matrix. You can pass for example a sparse matrix. Default: identity matrix.\nupdate_section_every_step updates the section every update_section_every_step step during continuation\njacobian::Symbol symbol which describes the type of jacobian used in Newton iterations (see below).\n\nThe scheme is as follows. We first consider a partition of 01 given by 0s_0cdotss_m=1 and one looks for T = x[end] such that\n\nM_acdotleft(x_i - x_i-1right) - fracTcdot h_i2 left(F(x_i) + F(x_i-1)right) = 0 i=1cdotsm-1\n\nwith u_0 = u_m-1 and the periodicity condition u_m - u_1 = 0 and\n\nwhere h_1 = s_i-s_i-1. M_a is a mass matrix. Finally, the phase of the periodic orbit is constrained by using a section (but you could use your own)\n\nsum_ilangle x_i - x_pii phi_irangle=0\n\nConstructors\n\nThe structure can be created by calling PeriodicOrbitTrapProblem(;kwargs...). For example, you can declare such a problem without vector field by doing\n\nPeriodicOrbitTrapProblem(M = 100)\n\nOrbit guess\n\nYou will see below that you can evaluate the residual of the functional (and other things) by calling pb(orbitguess, p) on an orbit guess orbitguess. Note that orbitguess must be a vector of size M * N + 1 where N is the number of unknowns in the state space and orbitguess[M*N+1] is an estimate of the period T of the limit cycle. More precisely, using the above notations, orbitguess must be orbitguess = x_1x_2cdotsx_M T.\n\nNote that you can generate this guess from a function solution using generateSolution.\n\nFunctional\n\nA functional, hereby called G, encodes this problem. The following methods are available\n\npb(orbitguess, p) evaluates the functional G on orbitguess\npb(orbitguess, p, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\npb(Val(:JacFullSparse), orbitguess, p) return the sparse matrix of the jacobian dG(orbitguess) at orbitguess without the constraints. It is called A_γ in the docs.\npb(Val(:JacFullSparseInplace), J, orbitguess, p). Same as pb(Val(:JacFullSparse), orbitguess, p) but overwrites J inplace. Note that the sparsity pattern must be the same independently of the values of the parameters or of orbitguess. In this case, this is significantly faster than pb(Val(:JacFullSparse), orbitguess, p).\npb(Val(:JacCyclicSparse), orbitguess, p) return the sparse cyclic matrix Jc (see the docs) of the jacobian dG(orbitguess) at orbitguess\npb(Val(:BlockDiagSparse), orbitguess, p) return the diagonal of the sparse matrix of the jacobian dG(orbitguess) at orbitguess. This allows to design Jacobi preconditioner. Use blockdiag.\n\nJacobian\n\nSpecify the choice of the jacobian (and linear algorithm), jacobian must belong to [:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]. This is used to select a way of inverting the jacobian dG of the functional G.\n\nFor jacobian = :FullLU, we use the default linear solver based on a sparse matrix representation of dG. This matrix is assembled at each newton iteration. This is the default algorithm.\nFor jacobian = :FullSparseInplace, this is the same as for :FullLU but the sparse matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor jacobian = :DenseAD, evaluate the jacobian using ForwardDiff\nFor jacobian = :BorderedLU, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert dG using a bordered linear solver.\nFor jacobian = :BorderedSparseInplace, this is the same as for :BorderedLU but the cyclic matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :BorderedLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor jacobian = :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\nFor jacobian = :FullMatrixFreeAD, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.\n\nnote: GPU call\nFor these methods to work on the GPU, for example with CuArrays in mode allowscalar(false), we face the issue that the function extract_period_fdtrap won't be well defined because it is a scalar operation. Note that you must pass the option ongpu = true for the functional to be evaluated efficiently on the gpu.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"PeriodicOrbitOCollProblem","category":"page"},{"location":"library/#BifurcationKit.PeriodicOrbitOCollProblem","page":"Library","title":"BifurcationKit.PeriodicOrbitOCollProblem","text":"pb = PeriodicOrbitOCollProblem(kwargs...)\n\nThis composite type implements an orthogonal collocation (at Gauss points) method of piecewise polynomials to locate periodic orbits. More details (maths, notations, linear systems) can be found here.\n\nArguments\n\nprob a bifurcation problem\nϕ::AbstractVector used to set a section for the phase constraint equation\nxπ::AbstractVector used in the section for the phase constraint equation\nN::Int dimension of the state space\nmesh_cache::MeshCollocationCache cache for collocation. See docs of MeshCollocationCache\nupdate_section_every_step updates the section every update_section_every_step step during continuation\njacobian = DenseAnalytical() describes the type of jacobian used in Newton iterations. Can only be AutoDiffDense(), DenseAnalytical(), FullSparse(), FullSparseInplace().\nmeshadapt::Bool = false whether to use mesh adaptation\nverbose_mesh_adapt::Bool = true verbose mesh adaptation information\nK::Float64 = 500 parameter for mesh adaptation, control new mesh step size. More precisely, we set max(hᵢ) / min(hᵢ) ≤ K if hᵢ denotes the time steps.\n\nMethods\n\nHere are some useful methods you can apply to pb\n\nlength(pb) gives the total number of unknowns\nsize(pb) returns the triplet (N, m, Ntst)\ngetmesh(pb) returns the mesh 0 = τ0 < ... < τNtst+1 = 1. This is useful because this mesh is born to vary during automatic mesh adaptation\nget_mesh_coll(pb) returns the (static) mesh 0 = σ0 < ... < σm+1 = 1\nget_times(pb) returns the vector of times (length 1 + m * Ntst) at the which the collocation is applied.\ngenerate_solution(pb, orbit, period) generate a guess from a function t -> orbit(t) which approximates the periodic orbit.\nPOSolution(pb, x) return a function interpolating the solution x using a piecewise polynomials function\n\nOrbit guess\n\nYou can evaluate the residual of the functional (and other things) by calling pb(orbitguess, p) on an orbit guess orbitguess. Note that orbitguess must be of size 1 + N * (1 + m * Ntst) where N is the number of unknowns in the state space and orbitguess[end] is an estimate of the period T of the limit cycle.\n\nConstructors\n\nPeriodicOrbitOCollProblem(Ntst::Int, m::Int; kwargs) creates an empty functional with Ntst and m.\n\nNote that you can generate this guess from a function using generate_solution.\n\nFunctional\n\nA functional, hereby called G, encodes this problem. The following methods are available\n\npb(orbitguess, p) evaluates the functional G on orbitguess\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"ShootingProblem","category":"page"},{"location":"library/#BifurcationKit.ShootingProblem","page":"Library","title":"BifurcationKit.ShootingProblem","text":"pb = ShootingProblem(flow::Flow, ds, section; parallel = false)\n\nCreate a problem to implement the Simple / Parallel Multiple Standard Shooting method to locate periodic orbits. More details (maths, notations, linear systems) can be found here. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nds: vector of time differences for each shooting. Its length is written M. If M == 1, then the simple shooting is implemented and the multiple one otherwise.\nsection: implements a phase condition. The evaluation section(x, T) must return a scalar number where x is a guess for one point on the periodic orbit and T is the period of the guess. Also, the method section(x, T, dx, dT) must be available and which returns the differential of section. The type of x depends on what is passed to the newton solver. See SectionSS for a type of section defined as a hyperplane.\nparallel whether the shooting is computed in parallel (threading). Available through the use of Flows defined by EnsembleProblem (this is automatically set up for you).\npar parameters of the model\nlens parameter axis\nupdate_section_every_step updates the section every update_section_every_step step during continuation\njacobian::Symbol symbol which describes the type of jacobian used in Newton iterations (see below).\n\nA functional, hereby called G, encodes the shooting problem. For example, the following methods are available:\n\npb(orbitguess, par) evaluates the functional G on orbitguess\npb(orbitguess, par, du) evaluates the jacobian dG(orbitguess)⋅du functional at orbitguess on du.\npb(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.\npb(Val(:JacobianMatrix), x, par) same as above but out-of-place.\n\nYou can then call pb(orbitguess, par) to apply the functional to a guess. Note that orbitguess::AbstractVector must be of size M * N + 1 where N is the number of unknowns of the state space and orbitguess[M * N + 1] is an estimate of the period T of the limit cycle. This form of guess is convenient for the use of the linear solvers in IterativeSolvers.jl (for example) which only accept AbstractVectors. Another accepted guess is of the form BorderedArray(guess, T) where guess[i] is the state of the orbit at the ith time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example, use GMRESKrylovKit for the linear solver in this case.\n\nNote that you can generate this guess from a function solution using generate_solution.\n\nJacobian\n\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\nSimplified constructors\n\nThe first important constructor is the following which is used for branching to periodic orbits from Hopf bifurcation points:\n\npb = ShootingProblem(M::Int, prob::Union{ODEProblem, EnsembleProblem}, alg; kwargs...)\n\nA convenient way to build the functional is to use:\n\npb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, centers::AbstractVector; kwargs...)\n\nwhere prob is an ODEProblem (resp. EnsembleProblem) which is used to create a flow using the ODE solver alg (for example Tsit5()). centers is list of M points close to the periodic orbit, they will be used to build a constraint for the phase. parallel = false is an option to use Parallel simulations (Threading) to simulate the multiple trajectories in the case of multiple shooting. This is efficient when the trajectories are relatively long to compute. Finally, the arguments kwargs are passed to the ODE solver defining the flow. Look at DifferentialEquations.jl for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.\n\nAnother way to create a Shooting problem with more options is the following where in particular, one can provide its own scalar constraint section(x)::Number for the phase:\n\npb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; parallel = false, kwargs...)\n\nor\n\npb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, ds, section; parallel = false, kwargs...)\n\nThe next way is an elaboration of the previous one\n\npb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, M::Int, section; parallel = false, kwargs...)\n\nor\n\npb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, ds, section; parallel = false, kwargs...)\n\nwhere we supply now two ODEProblems. The first one prob1, is used to define the flow associated to F while the second one is a problem associated to the derivative of the flow. Hence, prob2 must implement the following vector field tilde F(xyp) = (F(xp) dF(xp)cdot y).\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"PoincareShootingProblem","category":"page"},{"location":"library/#BifurcationKit.PoincareShootingProblem","page":"Library","title":"BifurcationKit.PoincareShootingProblem","text":"pb = PoincareShootingProblem(flow::Flow, M, sections; δ = 1e-8, interp_points = 50, parallel = false)\n\nThis composite type implements the Poincaré Shooting method to locate periodic orbits by relying on Poincaré return maps. More details (maths, notations, linear systems) can be found here. The arguments are as follows\n\nflow::Flow: implements the flow of the Cauchy problem though the structure Flow.\nM: the number of Poincaré sections. If M == 1, then the simple shooting is implemented and the multiple one otherwise.\nsections: function or callable struct which implements a Poincaré section condition. The evaluation sections(x) must return a scalar number when M == 1. Otherwise, one must implement a function section(out, x) which populates out with the M sections. See SectionPS for type of section defined as a hyperplane.\nδ = 1e-8 used to compute the jacobian of the functional by finite differences. If set to 0, an analytical expression of the jacobian is used instead.\ninterp_points = 50 number of interpolation point used to define the callback (to compute the hitting of the hyperplane section)\nparallel = false whether the shooting are computed in parallel (threading). Only available through the use of Flows defined by EnsembleProblem.\npar parameters of the model\nlens parameter axis\nupdate_section_every_step updates the section every update_section_every_step step during continuation\njacobian::Symbol symbol which describes the type of jacobian used in Newton iterations (see below).\n\nJacobian\n\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\nSimplified constructors\n\nThe first important constructor is the following which is used for branching to periodic orbits from Hopf bifurcation points   pb = PoincareShootingProblem(M::Int, prob::Union{ODEProblem, EnsembleProblem}, alg; kwargs...)\nA convenient way is to create a functional is\n\npb = PoincareShootingProblem(prob::ODEProblem, alg, section; kwargs...)\n\nfor simple shooting or\n\npb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; kwargs...)\n\nfor multiple shooting . Here prob is an Union{ODEProblem, EnsembleProblem} which is used to create a flow using the ODE solver alg (for example Tsit5()). Finally, the arguments kwargs are passed to the ODE solver defining the flow. We refer to DifferentialEquations.jl for more information.\n\nAnother convenient call is\n\npb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)\n\nwhere normals (resp. centers) is a list of normals (resp. centers) which defines a list of hyperplanes Sigma_i. These hyperplanes are used to define partial Poincaré return maps.\n\nComputing the functionals\n\nA functional, hereby called G encodes this shooting problem. You can then call pb(orbitguess, par) to apply the functional to a guess. Note that orbitguess::AbstractVector must be of size M * N where N is the number of unknowns in the state space and M is the number of Poincaré maps. Another accepted guess is such that guess[i] is the state of the orbit on the ith section. This last form allows for non-vector state space which can be convenient for 2d problems for example.\n\nNote that you can generate this guess from a function solution using generate_solution.\n\npb(orbitguess, par) evaluates the functional G on orbitguess\npb(orbitguess, par, du) evaluates the jacobian dG(orbitguess).du functional at orbitguess on du\npb(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.\npb(Val(:JacobianMatrix), x, par) same as above but out-of-place.\n\ntip: Tip\nYou can use the function getperiod(pb, sol, par) to get the period of the solution sol for the problem with parameters par.\n\n\n\n\n\n","category":"type"},{"location":"library/#Waves","page":"Library","title":"Waves","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.TWProblem","category":"page"},{"location":"library/#BifurcationKit.TWProblem","page":"Library","title":"BifurcationKit.TWProblem","text":"TWProblem(prob, ∂::Tuple, u₀; DAE = 0, jacobian::Symbol = :AutoDiff)\n\nThis composite type implements a functional for freezing symmetries in order, for example, to compute travelling waves (TW). Note that you can freeze many symmetries, not just one, by passing many Lie generators. When you call pb(x, par), it computes:\n\n                ┌                   ┐\n                │ f(x, par) - s⋅∂⋅x │\n                │   <x - u₀, ∂⋅u₀>  │\n                └                   ┘\n\nArguments\n\nprob bifurcation problem with continuous symmetries\n∂::Tuple = (T1, T2, ⋯) tuple of Lie generators. In effect, each of these is an (differential) operator which can be specified as a (sparse) matrix or as an operator implementing LinearAlgebra.mul!.\nu₀ reference solution\n\nAdditional Constructor(s)\n\npb = TWProblem(prob, ∂, u₀; kw...)\n\nThis simplified call handles the case where a single symmetry needs to be frozen.\n\nUseful function\n\nupdatesection!(pb::TWProblem, u0) updates the reference solution of the problem using u0.\nnb_constraints(::TWProblem) number of constraints (or Lie generators)\n\n\n\n\n\n","category":"type"},{"location":"library/#Newton","page":"Library","title":"Newton","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"newton","category":"page"},{"location":"library/#BifurcationKit.newton","page":"Library","title":"BifurcationKit.newton","text":"    newton(prob::AbstractBifurcationProblem, options::NewtonPar; normN = norm, callback = (;x, fx, J, residual, step, itlinear, options, x0, residuals; kwargs...) -> true, kwargs...)\n\nThis is the Newton-Krylov Solver for F(x, p0) = 0 with Jacobian w.r.t. x written J(x, p0) and initial guess x0. It is important to set the linear solver options.linsolver properly depending on your problem. This linear solver is used to solve J(x p_0)u = -F(x p_0) in the Newton step. You can for example use linsolver = DefaultLS() which is the operator backslash: it works well for Sparse / Dense matrices. See Linear solvers (LS) for more informations.\n\nArguments\n\nprob a ::AbstractBifurcationProblem, typically a  BifurcationProblem which holds the vector field and its jacobian. We also refer to  BifFunction for more details.\noptions::NewtonPar variable holding the internal parameters used by the newton method\n\nOptional Arguments\n\nNormN = norm specifies a norm for the convergence criteria\ncallback function passed by the user which is called at the end of each iteration. The default one is the following cb_default((x, fx, J, residual, step, itlinear, options, x0, residuals); k...) = true. Can be used to update a preconditionner for example. You can use for example cbMaxNorm to limit the residuals norms. If yo  want to specify your own, the arguments passed to the callback are as follows\nx current solution\nfx current residual\nJ current jacobian\nresidual current norm of the residual\nstep current newton step\nitlinear number of iterations to solve the linear system\noptions a copy of the argument options passed to newton\nresiduals the history of residuals\nkwargs kwargs arguments, contain your initial guess x0\nkwargs arguments passed to the callback. Useful when newton is called from continuation\n\nOutput:\n\nsolution::NonLinearSolution, we refer to NonLinearSolution for more information.\n\nwarning: Linear solver\nMake sure that the linear solver (Matrix-Free...) corresponds to your jacobian (Matrix-Free vs. Matrix based).\n\n\n\n\n\nnewton(prob, defOp, options; ...)\nnewton(prob, defOp, options, _linsolver; kwargs...)\n\n\nThis is the deflated version of the Krylov-Newton Solver for F(x, p0) = 0.\n\nWe refer to the regular newton for more information. It penalises the roots saved in defOp.roots. The other arguments are as for newton. See DeflationOperator for more information on defOp.\n\nArguments\n\nCompared to newton, the only different arguments are\n\ndefOp::DeflationOperator deflation operator\nlinsolver linear solver used to invert the Jacobian of the deflated functional.\ncustom solver DeflatedProblemCustomLS() which requires solving two linear systems J⋅x = rhs.\nFor other linear solvers <: AbstractLinearSolver, a matrix free method is used for the deflated functional.\nif passed Val(:autodiff), then ForwardDiff.jl is used to compute the jacobian Matrix of the deflated problem\nif passed Val(:fullIterative), then a full matrix free method is used for the deflated problem.\n\n\n\n\n\nThis specific Newton-Krylov method first tries to converge to a solution sol0 close the guess x0. It then attempts to converge from the guess x1 while avoiding the previous converged solution close to sol0. This is very handy for branch switching. The method is based on a deflated Newton-Krylov solver.\n\nArguments\n\nCompared to newton, the only different arguments are\n\ndefOp::DeflationOperator deflation operator\nlinsolver linear solver used to invert the Jacobian of the deflated functional.\ncustom solver DeflatedProblemCustomLS() which requires solving two linear systems J⋅x = rhs.\nFor other linear solvers <: AbstractLinearSolver, a matrix free method is used for the deflated functional.\nif passed Val(:autodiff), then ForwardDiff.jl is used to compute the jacobian Matrix of the deflated problem\nif passed Val(:fullIterative), then a full matrix free method is used for the deflated problem.\n\n\n\n\n\nnewton(\n    br,\n    ind_bif;\n    normN,\n    options,\n    start_with_eigen,\n    lens2,\n    kwargs...\n)\n\n\nThis function turns an initial guess for a Fold / Hopf point into a solution to the Fold / Hopf problem based on a Minimally Augmented formulation.\n\nArguments\n\nbr results returned after a call to continuation\nind_bif bifurcation index in br\n\nOptional arguments:\n\noptions::NewtonPar, default value br.contparams.newton_options\nnormN = norm\noptions You can pass newton parameters different from the ones stored in br by using this argument options.\nbdlinsolver bordered linear solver for the constraint equation\nstart_with_eigen = false whether to start the Minimally Augmented problem with information from eigen elements.\nkwargs keywords arguments to be passed to the regular Newton-Krylov solver\n\ntip: ODE problems\nFor ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option bdlinsolver = MatrixBLS()\n\ntip: start_with_eigen\nIt is recommended that you use the option start_with_eigen=true\n\n\n\n\n\nnewton(prob, orbitguess, options; lens, δ, kwargs...)\n\n\nThis is the Newton-Krylov Solver for computing a periodic orbit using the (Standard / Poincaré) Shooting method. Note that the linear solver has to be appropriately set up in options.\n\nArguments\n\nSimilar to newton except that prob is either a ShootingProblem or a PoincareShootingProblem. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.\n\nprob a problem of type <: AbstractShootingProblem encoding the shooting functional G.\norbitguess a guess for the periodic orbit. See ShootingProblem and See PoincareShootingProblem for information regarding the shape of orbitguess.\npar parameters to be passed to the functional\noptions same as for the regular newton method.\n\nOptional argument\n\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\n\n\n\n\nnewton(prob, orbitguess, defOp, options; lens, kwargs...)\n\n\nThis is the deflated Newton-Krylov Solver for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar to newton except that prob is either a ShootingProblem or a PoincareShootingProblem.\n\nOptional argument\n\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\nOutput:\n\nsolution::NonLinearSolution, see NonLinearSolution\n\n\n\n\n\nnewton(probPO, orbitguess, options; kwargs...)\n\n\nThis is the Krylov-Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments:\n\nprob a problem of type PeriodicOrbitTrapProblem encoding the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It should be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N, M in prob.\npar parameters to be passed to the functional\noptions same as for the regular newton method\n\nSpecify the choice of the jacobian (and linear algorithm), jacobian must belong to [:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]. This is used to select a way of inverting the jacobian dG of the functional G.\n\nFor jacobian = :FullLU, we use the default linear solver based on a sparse matrix representation of dG. This matrix is assembled at each newton iteration. This is the default algorithm.\nFor jacobian = :FullSparseInplace, this is the same as for :FullLU but the sparse matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor jacobian = :DenseAD, evaluate the jacobian using ForwardDiff\nFor jacobian = :BorderedLU, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert dG using a bordered linear solver.\nFor jacobian = :BorderedSparseInplace, this is the same as for :BorderedLU but the cyclic matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :BorderedLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor jacobian = :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\nFor jacobian = :FullMatrixFreeAD, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.\n\n\n\n\n\nnewton(probPO, orbitguess, defOp, options; kwargs...)\n\n\nThis function is similar to newton(probPO, orbitguess, options, jacobianPO; kwargs...) except that it uses deflation in order to find periodic orbits different from the ones stored in defOp. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.\n\n\n\n\n\nnewton(probPO, orbitguess, options; kwargs...)\n\n\nThis is the Newton Solver for computing a periodic orbit using orthogonal collocation method. Note that the linear solver has to be apropriately set up in options.\n\nArguments\n\nSimilar to newton except that prob is a PeriodicOrbitOCollProblem.\n\nprob a problem of type <: PeriodicOrbitOCollProblem encoding the shooting functional G.\norbitguess a guess for the periodic orbit.\noptions same as for the regular newton method.\n\nOptional argument\n\njacobian Specify the choice of the linear algorithm, which must belong to (AutoDiffDense(), ). This is used to select a way of inverting the jacobian dG\nFor AutoDiffDense(). The jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using options. The jacobian is formed inplace.\nFor DenseAnalytical() Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\n\n\n\n\n\nnewton(probPO, orbitguess, defOp, options; kwargs...)\n\n\nThis function is similar to newton(probPO, orbitguess, options, jacobianPO; kwargs...) except that it uses deflation in order to find periodic orbits different from the ones stored in defOp. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.\n\n\n\n\n\n","category":"function"},{"location":"library/#Library-Continuation","page":"Library","title":"Continuation","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.DotTheta","category":"page"},{"location":"library/#BifurcationKit.DotTheta","page":"Library","title":"BifurcationKit.DotTheta","text":"struct DotTheta{Tdot, Ta}\n\ndot::Any: dot product used in pseudo-arclength constraint\napply!::Any: Linear operator associated with dot product, i.e. dot(x, y) = <x, Ay>, where <,> is the standard dot product on R^N. You must provide an inplace function which evaluates A. For example x -> rmul!(x, 1/length(x)).\n\nThis parametric type allows to define a new dot product from the one saved in dt::dot. More precisely:\n\ndt(u1, u2, p1::T, p2::T, theta::T) where {T <: Real}\n\ncomputes, the weighted dot product langle (u_1p_1) (u_2p_2)rangle_theta = theta Re langle u_1u_2rangle  +(1-theta)p_1p_2 where u_iinmathbb R^N. The Re factor is put to ensure a real valued result despite possible complex valued arguments.\n\ninfo: Info\nThis is used in the pseudo-arclength constraint with the dot product frac1N langle u_1 u_2ranglequad u_iinmathbb R^N\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"continuation","category":"page"},{"location":"library/#BifurcationKit.continuation","page":"Library","title":"BifurcationKit.continuation","text":"continuation(\n    prob,\n    alg,\n    contparams;\n    linear_algo,\n    bothside,\n    kwargs...\n)\n\n\nCompute the continuation curve associated to the functional F which is stored in the bifurcation problem prob. General information is available in Continuation methods: introduction.\n\nArguments:\n\nprob::AbstractBifurcationFunction a ::AbstractBifurcationProblem, typically a  BifurcationProblem which holds the vector field and its jacobian. We also refer to  BifFunction for more details.\nalg continuation algorithm, for example Natural(), PALC(), Multiple(),.... See algos\ncontparams::ContinuationPar parameters for continuation. See ContinuationPar\n\nOptional Arguments:\n\nplot = false whether to plot the solution/branch/spectrum while computing the branch\nbothside = true compute the branches on the two sides of the initial parameter value p0, merge them and return it.\nnormC = norm norm used in the nonlinear solves\nfilename to save the computed branch during continuation. The identifier .jld2 will be appended to this filename. This requires using JLD2.\ncallback_newton callback for newton iterations. See docs of newton. For example, it can be used to change the preconditioners.\nfinalise_solution = (z, tau, step, contResult; kwargs...) -> true Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning false), save personal data, plot... The notations are z = BorderedArray(x, p) where x (resp. p) is the current solution (resp. parameter value), tau::BorderedArray is the tangent at z, step::Int is the index of the current continuation step and contResult is the current branch. For advanced use:\nthe state state::ContState of the continuation iterator is passed in kwargs. This can be used for testing whether this is called from bisection for locating bifurcation points / events: in_bisection(state) for example. This allows to escape some personal code in this case.\nNote that you can have a better control over the continuation procedure by using an iterator, see Iterator Interface.\nthe iterator iter::ContIterable of the continuation is passed in kwargs.\nverbosity::Int = 0 controls the amount of information printed during the continuation process. Must belong to {0,1,2,3}. In case contparams.newton_options.verbose = false, the following is valid (otherwise the newton iterations are shown). Each case prints more information than the previous one:\ncase 0: print nothing\ncase 1: print basic information about the continuation: used predictor, step size and parameter values\ncase 2: print newton iterations number, stability of solution, detected bifurcations / events\ncase 3: print information during bisection to locate bifurcations / events\nlinear_algo set the linear solver for the continuation algorithm alg. For example, PALC needs a linear solver for an enlarged problem (size n+1 instead of n) and one thus needs to tune the one passed in contparams.newton_options.linsolver. This is a convenient argument to thus change the alg linear solver and is used mostly internally. The proper way is to pass directly to alg the correct linear solver.\nkind::AbstractContinuationKind [Internal] flag to describe continuation kind (equilibrium, codim 2, ...). Default = EquilibriumCont()\n\nOutput:\n\ncontres::ContResult composite type which contains the computed branch. See ContResult for more information.\n\ntip: Continuing the branch in the opposite direction\nJust change the sign of ds in ContinuationPar.\n\ntip: Debug mode\nUse debug mode to access more irformation about the progression of the continuation run, like iterative solvers convergence, problem update, ...\n\n\n\n\n\ncontinuation(\n    prob,\n    algdc,\n    contParams;\n    verbosity,\n    plot,\n    linear_algo,\n    dot_palc,\n    callback_newton,\n    filename,\n    normC,\n    kwcont...\n)\n\n\nThis function computes the set of curves of solutions γ(s) = (x(s), p(s)) to the equation F(x,p) = 0 based on the algorithm of deflated continuation as described in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. “The Computation of Disconnected Bifurcation Diagrams.” ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.\n\nDepending on the options in contParams, it can locate the bifurcation points on each branch. Note that you can specify different predictors using alg.\n\nArguments:\n\nprob::AbstractBifurcationProblem bifurcation problem\nalg::DefCont, deflated continuation algorithm, see DefCont\ncontParams parameters for continuation. See ContinuationPar for more information about the options\n\nOptional Arguments:\n\nplot = false whether to plot the solution while computing,\ncallback_newton callback for newton iterations. see docs for newton. Can be used to change preconditioners or affect the newton iterations. In the deflation part of the algorithm, when seeking for new branches, the callback is passed the keyword argument fromDeflatedNewton = true to tell the user can it is not in the continuation part (regular newton) of the algorithm,\nverbosity::Int controls the amount of information printed during the continuation process. Must belong to {0,⋯,5},\nnormC = norm norm used in the Newton solves,\ndot_palc = (x, y) -> dot(x, y) / length(x), dot product used to define the weighted dot product (resp. norm) (x p)^2_theta in the constraint N(x p) (see online docs on PALC). This argument can be used to remove the factor 1/length(x) for example in problems where the dimension of the state space changes (mesh adaptation, ...),\n\nOutputs:\n\ncontres::DCResult composite type which contains the computed branches. See ContResult for more information,\n\n\n\n\n\ncontinuation(br, ind_bif, lens2; ...)\ncontinuation(\n    br,\n    ind_bif,\n    lens2,\n    options_cont;\n    prob,\n    start_with_eigen,\n    detect_codim2_bifurcation,\n    update_minaug_every_step,\n    kwargs...\n)\n\n\nCodimension 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold / Hopf point into a curve of Fold / Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\nbr results returned after a call to continuation\nind_bif bifurcation index in br\nlens2 second parameter used for the continuation, the first one is the one used to compute br, e.g. getlens(br)\noptions_cont = br.contparams arguments to be passed to the regular continuation\n\nOptional arguments:\n\nbdlinsolver bordered linear solver for the constraint equation\nupdate_minaug_every_step update vectors a, b in Minimally Formulation every update_minaug_every_step steps\nstart_with_eigen = false whether to start the Minimally Augmented problem with information from eigen elements\ndetect_codim2_bifurcation ∈ {0,1,2} whether to detect Bogdanov-Takens, Bautin and Cusp. If equals 1 non precise detection is used. If equals 2, a bisection method is used to locate the bifurcations.\nkwargs keywords arguments to be passed to the regular continuation\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Hopf point in br you want to refine.\n\ntip: ODE problems\nFor ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option bdlinsolver = MatrixBLS()\n\ntip: start_with_eigen\nIt is recommended that you use the option start_with_eigen = true\n\n\n\n\n\ncontinuation(\n    prob,\n    x0,\n    par0,\n    x1,\n    p1,\n    alg,\n    lens,\n    contParams;\n    bothside,\n    kwargs...\n)\n\n\n[Internal] This function is not meant to be called directly.\n\nThis function is the analog of continuation when the first two points on the branch are passed (instead of a single one). Hence x0 is the first point on the branch (with palc s=0) with parameter par0 and x1 is the second point with parameter set(par0, lens, p1).\n\n\n\n\n\ncontinuation(br, ind_bif; ...)\ncontinuation(\n    br,\n    ind_bif,\n    options_cont;\n    alg,\n    δp,\n    ampfactor,\n    nev,\n    usedeflation,\n    verbosedeflation,\n    max_iter_deflation,\n    perturb,\n    plot_solution,\n    Teigvec,\n    scaleζ,\n    tol_fold,\n    kwargs_deflated_newton,\n    kwargs...\n)\n\n\nAutomatic branch switching at branch points based on a computation of the normal form. More information is provided in Branch switching. An example of use is provided in 2d generalized Bratu–Gelfand problem.\n\nArguments\n\nbr branch result from a call to continuation\nind_bif index of the bifurcation point in br from which you want to branch from\noptions_cont options for the call to continuation\n\nOptional arguments\n\nalg = br.alg continuation algorithm to be used, default value: br.alg\nδp used to specify a specific value for the parameter on the bifurcated branch which is otherwise determined by options_cont.ds. This allows to use a step larger than options_cont.dsmax.\nampfactor = 1 factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nnev number of eigenvalues to be computed to get the right eigenvector\nusedeflation = false whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated\nverbosedeflation print deflated newton iterations\nmax_iter_deflation number of newton steps in deflated newton\nperturb = identity which perturbation function to use during deflated newton\nTeigvec = _getvectortype(br) type of the eigenvector. Useful when br was loaded from a file and this information was lost\nscaleζ = norm pass a norm to normalize vectors during normal form computation\nplot_solution change plot solution method in the problem br.prob\nkwargs optional arguments to be passed to continuation, the regular continuation one and to get_normal_form.\n\ntip: Advanced use\nIn the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at methods(BifurcationKit.multicontinuation) to see how to call these versions. These methods has been tested on GPU with very high memory pressure.\n\n\n\n\n\ncontinuation(\n    probPO,\n    orbitguess,\n    alg,\n    contParams,\n    linear_algo;\n    δ,\n    eigsolver,\n    record_from_solution,\n    plot_solution,\n    kwargs...\n)\n\n\nThis is the continuation method for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar to continuation except that probPO is either a ShootingProblem or a PoincareShootingProblem. By default, it prints the period of the periodic orbit.\n\nOptional arguments\n\neigsolver specify an eigen solver for the computation of the Floquet exponents, defaults to FloquetQaD\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\n\n\n\n\ncontinuation(\n    prob,\n    orbitguess,\n    alg,\n    _contParams;\n    linear_algo,\n    kwargs...\n)\n\n\nThis is the continuation routine for computing a periodic orbit using a (Standard / Poincaré) Shooting method.\n\nArguments\n\nSimilar to continuation except that prob is either a ShootingProblem or a PoincareShootingProblem. By default, it prints the period of the periodic orbit.\n\nOptional argument\n\nlinear_algo::AbstractBorderedLinearSolver\njacobian Specify the choice of the linear algorithm, which must belong to [AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]. This is used to select a way of inverting the jacobian dG\nFor MatrixFree(), matrix free jacobian, the jacobian is specified by the user in prob. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutoDiffMF(), we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of x -> prob(x, p) using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system\nFor AutodiffDense(). Same as for AutoDiffMF but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.\nFor FiniteDifferences(), same as for AutoDiffDense but we use Finite Differences to compute the jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\nFor AutoDiffDenseAnalytical(). Same as for AutoDiffDense but the jacobian is formed using a mix of AD and analytical formula.\nFor FiniteDifferencesMF(), use Finite Differences to compute the matrix-free jacobian of x -> prob(x, p) using the δ = 1e-8 which can be passed as an argument.\n\n\n\n\n\ncontinuation(\n    br,\n    ind_bif,\n    _contParams,\n    pbPO;\n    prob_vf,\n    alg,\n    δp,\n    ampfactor,\n    usedeflation,\n    nev,\n    kwargs...\n)\n\n\nPerform automatic branch switching from a Hopf bifurcation point labelled ind_bif in the list of the bifurcated points of a previously computed branch br::ContResult. It first computes a Hopf normal form.\n\nArguments\n\nbr branch result from a call to continuation\nind_hopf index of the bifurcation point in br\ncontParams parameters for the call to continuation\nprobPO problem used to specify the way the periodic orbit is computed. It can be PeriodicOrbitTrapProblem, ShootingProblem or PoincareShootingProblem .\n\nOptional arguments\n\nalg = br.alg continuation algorithm\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nnev number of eigenvalues to be computed to get the right eigenvector\nall kwargs from continuation\n\nA modified version of prob is passed to plot_solution and finalise_solution.\n\nnote: Linear solver\nYou have to be careful about the options contParams.newton_options.linsolver. In the case of Matrix-Free solver, you have to pass the right number of unknowns N * M + 1. Note that the options for the preconditioner are not accessible yet.\n\n\n\n\n\ncontinuation(\n    br,\n    ind_bif,\n    _contParams;\n    alg,\n    δp,\n    ampfactor,\n    usedeflation,\n    linear_algo,\n    detailed,\n    prm,\n    override,\n    kwargs...\n)\n\n\nBranch switching at a bifurcation point on a branch of periodic orbits (PO) specified by a br::AbstractBranchResult. The functional used to compute the PO is br.prob. A deflated Newton-Krylov solver can be used to improve the branch switching capabilities.\n\nArguments\n\nbr branch of periodic orbits computed with a PeriodicOrbitTrapProblem\nind_bif index of the branch point\n_contParams parameters to be used by a regular continuation\n\nOptional arguments\n\nδp = 0.1 used to specify a particular guess for the parameter in the branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\ndetailed = false whether to fully compute the normal form. The normal form is only used to collect the eigenvector for now.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nrecord_from_solution = (u, p) -> u[end], record method used in the bifurcation diagram, by default this records the period of the periodic orbit.\nlinear_algo = BorderingBLS(), same as for continuation\nkwargs keywords arguments used for a call to the regular continuation and the ones specific to periodic orbits (POs).\n\n\n\n\n\ncontinuation(\n    prob,\n    orbitguess,\n    alg,\n    _contParams;\n    record_from_solution,\n    linear_algo,\n    kwargs...\n)\n\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments\n\nprob::PeriodicOrbitTrapProblem encodes the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It could be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N, M in prob.\nalg continuation algorithm\ncontParams same as for the regular continuation method\n\nKeyword arguments\n\nlinear_algo same as in continuation\n\nSpecify the choice of the jacobian (and linear algorithm), jacobian must belong to [:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]. This is used to select a way of inverting the jacobian dG of the functional G.\n\nFor jacobian = :FullLU, we use the default linear solver based on a sparse matrix representation of dG. This matrix is assembled at each newton iteration. This is the default algorithm.\nFor jacobian = :FullSparseInplace, this is the same as for :FullLU but the sparse matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor jacobian = :DenseAD, evaluate the jacobian using ForwardDiff\nFor jacobian = :BorderedLU, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert dG using a bordered linear solver.\nFor jacobian = :BorderedSparseInplace, this is the same as for :BorderedLU but the cyclic matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :BorderedLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor jacobian = :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\nFor jacobian = :FullMatrixFreeAD, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.\n\nNote that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your record_from_solution argument.\n\n\n\n\n\ncontinuation(\n    probPO,\n    orbitguess,\n    alg,\n    _contParams,\n    linear_algo;\n    δ,\n    eigsolver,\n    record_from_solution,\n    plot_solution,\n    kwargs...\n)\n\n\nThis is the continuation method for computing a periodic orbit using an orthogonal collocation method.\n\nArguments\n\nSimilar to continuation except that prob is a PeriodicOrbitOCollProblem. By default, it prints the period of the periodic orbit.\n\nKeywords arguments\n\neigsolver specify an eigen solver for the computation of the Floquet exponents, defaults to FloquetQaD\n\n\n\n\n\n","category":"function"},{"location":"library/#Continuation-algorithms","page":"Library","title":"Continuation algorithms","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Natural","category":"page"},{"location":"library/#BifurcationKit.Natural","page":"Library","title":"BifurcationKit.Natural","text":"Natural continuation algorithm. The predictor is the constant predictor and the parameter is incremented by `ContinuationPar().ds` at each continuation step.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Secant","category":"page"},{"location":"library/#BifurcationKit.Secant","page":"Library","title":"BifurcationKit.Secant","text":"Secant Tangent predictor\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Bordered","category":"page"},{"location":"library/#BifurcationKit.Bordered","page":"Library","title":"BifurcationKit.Bordered","text":"Bordered Tangent predictor\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Polynomial","category":"page"},{"location":"library/#BifurcationKit.Polynomial","page":"Library","title":"BifurcationKit.Polynomial","text":"Polynomial Tangent predictor\n\nn::Int64: Order of the polynomial\nk::Int64: Length of the last solutions vector used for the polynomial fit\nA::Matrix{T} where T<:Real: Matrix for the interpolation\ntangent::BifurcationKit.AbstractTangentComputation: Algo for tangent when polynomial predictor is not possible\nsolutions::DataStructures.CircularBuffer: Vector of solutions\nparameters::DataStructures.CircularBuffer{T} where T<:Real: Vector of parameters\narclengths::DataStructures.CircularBuffer{T} where T<:Real: Vector of arclengths\ncoeffsSol::Vector: Coefficients for the polynomials for the solution\ncoeffsPar::Vector{T} where T<:Real: Coefficients for the polynomials for the parameter\nupdate::Bool: Update the predictor by adding the last point (x, p)? This can be disabled in order to just use the polynomial prediction. It is useful when the predictor is called mutiple times during bifurcation detection using bisection.\n\nConstructor(s)\n\nPolynomial(pred, n, k, v0)\n\nPolynomial(n, k, v0)\n\nn order of the polynomial\nk length of the last solutions vector used for the polynomial fit\nv0 example of solution to be stored. It is only used to get the eltype of the tangent.\n\nCan be used like\n\nPALC(tangent = Polynomial(Bordered(), 2, 6, rand(1)))\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Multiple","category":"page"},{"location":"library/#BifurcationKit.Multiple","page":"Library","title":"BifurcationKit.Multiple","text":"Multiple Tangent continuation algorithm.\n\nalg::PALC: Tangent predictor used Default: PALC()\nτ::Any: Save the current tangent\nα::Real: Damping in Newton iterations, 0 < α < 1\nnb::Int64: Number of predictors\ncurrentind::Int64: Index of the largest converged predictor Default: 0\npmimax::Int64: Index for lookup in residual history Default: 1\nimax::Int64: Maximum index for lookup in residual history Default: 4\ndsfact::Real: Factor to increase ds upon successful step Default: 1.5\n\nConstructor(s)\n\nMultiple(alg, x0, α, n)\n\nMultiple(pred, x0, α, n)\n\nMultiple(x0, α, n)\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"PALC","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"MoorePenrose","category":"page"},{"location":"library/#BifurcationKit.MoorePenrose","page":"Library","title":"BifurcationKit.MoorePenrose","text":"Moore-Penrose predictor / corrector\n\nMoore-Penrose continuation algorithm.\n\nAdditional information is available on the website.\n\nConstructors\n\nalg = MoorePenrose()\n\nalg = MoorePenrose(tangent = PALC())\n\nFields\n\ntangent::Any: Tangent predictor, for example PALC()\nmethod::MoorePenroseLS: Moore Penrose linear solver. Can be BifurcationKit.direct, BifurcationKit.pInv or BifurcationKit.iterative\nls::BifurcationKit.AbstractLinearSolver: (Bordered) linear solver\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.DefCont","category":"page"},{"location":"library/#BifurcationKit.DefCont","page":"Library","title":"BifurcationKit.DefCont","text":"struct DefCont{Tdo, Talg, Tps, Tas, Tud, Tk} <: BifurcationKit.AbstractContinuationAlgorithm\n\nStructure which holds the parameters specific to Deflated continuation.\n\nFields\n\ndeflation_operator::Any: Deflation operator, ::DeflationOperator Default: nothing\nalg::Any: Used as a predictor, ::AbstractContinuationAlgorithm. For example PALC(), Natural(),... Default: PALC()\nmax_branches::Int64: maximum number of (active) branches to be computed Default: 100\nseek_every_step::Int64: whether to seek new (deflated) solution at every step Default: 1\nmax_iter_defop::Int64: maximum number of deflated Newton iterations Default: 5\nperturb_solution::Any: perturb function Default: _perturbSolution\naccept_solution::Any: accept (solution) function Default: _acceptSolution\nupdate_deflation_op::Any: function to update the deflation operator, ie pushing new solutions Default: _updateDeflationOp\njacobian::Any: jacobian for deflated newton. Can be DeflatedProblemCustomLS(), or Val(:autodiff), Val(:fullIterative) Default: DeflatedProblemCustomLS()\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"AsymptoticNumericalMethod.ANM","category":"page"},{"location":"library/#Events","page":"Library","title":"Events","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.DiscreteEvent","category":"page"},{"location":"library/#BifurcationKit.DiscreteEvent","page":"Library","title":"BifurcationKit.DiscreteEvent","text":"struct DiscreteEvent{Tcb, Tl} <: BifurcationKit.AbstractDiscreteEvent\n\nStructure to pass a DiscreteEvent function to the continuation algorithm. A discrete call back returns a discrete value and we seek when it changes.\n\nnb::Int64: number of events, ie the length of the result returned by the callback function\ncondition::Any: = (iter, state) -> NTuple{nb, Int64} callback function which at each continuation state, returns a tuple. For example, to detect a value change.\ncomputeEigenElements::Bool: whether the event requires to compute eigen elements\nlabels::Any: Labels used to display information. For example labels[1] is used to qualify an event occurring in the first component. You can use labels = (\"hopf\",) or labels = (\"hopf\", \"fold\"). You must have labels::Union{Nothing, NTuple{N, String}}.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.ContinuousEvent","category":"page"},{"location":"library/#BifurcationKit.ContinuousEvent","page":"Library","title":"BifurcationKit.ContinuousEvent","text":"struct ContinuousEvent{Tcb, Tl, T} <: BifurcationKit.AbstractContinuousEvent\n\nStructure to pass a ContinuousEvent function to the continuation algorithm. A continuous call back returns a tuple/scalar value and we seek its zeros.\n\nnb::Int64: number of events, ie the length of the result returned by the callback function\ncondition::Any: , (iter, state) -> NTuple{nb, T} callback function which, at each continuation state, returns a tuple. For example, to detect crossing 1.0 and -2.0, you can pass (iter, state) -> (getp(state)+2, getx(state)[1]-1)),. Note that the type T should match the one of the parameter specified by the ::Lens in continuation.\ncomputeEigenElements::Bool: whether the event requires to compute eigen elements\nlabels::Any: Labels used to display information. For example labels[1] is used to qualify an event of the type (0, 1.3213, 3.434). You can use labels = (\"hopf\",) or labels = (\"hopf\", \"fold\"). You must have labels::Union{Nothing, NTuple{N, String}}.\ntol::Any: Tolerance on event value to declare it as true event.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.SetOfEvents","category":"page"},{"location":"library/#BifurcationKit.SetOfEvents","page":"Library","title":"BifurcationKit.SetOfEvents","text":"struct SetOfEvents{Tc<:Tuple, Td<:Tuple} <: BifurcationKit.AbstractEvent\n\nMultiple events can be chained together to form a SetOfEvents. A SetOfEvents is constructed by passing to the constructor ContinuousEvent, DiscreteEvent or other SetOfEvents instances:\n\nSetOfEvents(cb1, cb2, cb3)\n\nExample\n\n BifurcationKit.SetOfEvents(BK.FoldDetectCB, BK.BifDetectCB)\n\nYou can pass as many events as you like.\n\neventC::Tuple: Continuous event\neventD::Tuple: Discrete event\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.PairOfEvents","category":"page"},{"location":"library/#BifurcationKit.PairOfEvents","page":"Library","title":"BifurcationKit.PairOfEvents","text":"struct PairOfEvents{Tc<:BifurcationKit.AbstractContinuousEvent, Td<:BifurcationKit.AbstractDiscreteEvent} <: BifurcationKit.AbstractEvent\n\nStructure to pass a PairOfEvents function to the continuation algorithm. It is composed of a pair ContinuousEvent / DiscreteEvent. A PairOfEvents is constructed by passing to the constructor a ContinuousEvent and a DiscreteEvent:\n\nPairOfEvents(contEvent, discreteEvent)\n\nFields\n\neventC::BifurcationKit.AbstractContinuousEvent: Continuous event\neventD::BifurcationKit.AbstractDiscreteEvent: Discrete event\n\n\n\n\n\n","category":"type"},{"location":"library/#Branch-switching-(branch-point)","page":"Library","title":"Branch switching (branch point)","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"continuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar ; kwargs...)","category":"page"},{"location":"library/#Branch-switching-(Hopf-point)","page":"Library","title":"Branch switching (Hopf point)","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"continuation(br::BifurcationKit.AbstractBranchResult, ind_bif::Int, _contParams::ContinuationPar, prob::BifurcationKit.AbstractPeriodicOrbitProblem ; kwargs...)","category":"page"},{"location":"library/#BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}","page":"Library","title":"BifurcationKit.continuation","text":"continuation(\n    br,\n    ind_bif,\n    _contParams,\n    pbPO;\n    prob_vf,\n    alg,\n    δp,\n    ampfactor,\n    usedeflation,\n    nev,\n    kwargs...\n)\n\n\nPerform automatic branch switching from a Hopf bifurcation point labelled ind_bif in the list of the bifurcated points of a previously computed branch br::ContResult. It first computes a Hopf normal form.\n\nArguments\n\nbr branch result from a call to continuation\nind_hopf index of the bifurcation point in br\ncontParams parameters for the call to continuation\nprobPO problem used to specify the way the periodic orbit is computed. It can be PeriodicOrbitTrapProblem, ShootingProblem or PoincareShootingProblem .\n\nOptional arguments\n\nalg = br.alg continuation algorithm\nδp used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by contParams.ds. This allows to use a step larger than contParams.dsmax.\nampfactor = 1 factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.\nusedeflation = true whether to use nonlinear deflation (see Deflated problems) to help finding the guess on the bifurcated branch\nnev number of eigenvalues to be computed to get the right eigenvector\nall kwargs from continuation\n\nA modified version of prob is passed to plot_solution and finalise_solution.\n\nnote: Linear solver\nYou have to be careful about the options contParams.newton_options.linsolver. In the case of Matrix-Free solver, you have to pass the right number of unknowns N * M + 1. Note that the options for the preconditioner are not accessible yet.\n\n\n\n\n\n","category":"method"},{"location":"library/#Bifurcation-diagram","page":"Library","title":"Bifurcation diagram","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"bifurcationdiagram","category":"page"},{"location":"library/#BifurcationKit.bifurcationdiagram","page":"Library","title":"BifurcationKit.bifurcationdiagram","text":"bifurcationdiagram(\n    prob,\n    alg,\n    level,\n    options;\n    linear_algo,\n    kwargs...\n)\n\n\nCompute the bifurcation diagram associated with the problem F(x, p) = 0 recursively.\n\nArguments\n\nprob::AbstractBifurcationProblem bifurcation problem\nalg continuation algorithm\nlevel maximum branching (or recursion) level for computing the bifurcation diagram\noptions = (x, p, level) -> contparams this function allows to change the continuation options depending on the branching level. The argument x, p denotes the current solution to F(x, p)=0.\nkwargs optional arguments. Look at bifurcationdiagram! for more details.\n\nSimplified call:\n\nWe also provide the method\n\nbifurcationdiagram(prob, br::ContResult, level::Int, options; kwargs...)\n\nwhere br is a branch computed after a call to continuation from which we want to compute the bifurcating branches recursively.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"bifurcationdiagram!","category":"page"},{"location":"library/#BifurcationKit.bifurcationdiagram!","page":"Library","title":"BifurcationKit.bifurcationdiagram!","text":"bifurcationdiagram!(\n    prob,\n    node,\n    maxlevel,\n    options;\n    code,\n    halfbranch,\n    verbosediagram,\n    kwargs...\n)\n\n\nSimilar to bifurcationdiagram but you pass a previously computed node from which you want to further compute the bifurcated branches. It is usually used with node = get_branch(diagram, code) from a previously computed bifurcation diagram.\n\nArguments\n\nnode::BifDiagNode a node in the bifurcation diagram\nmaxlevel = 1 required maximal level of recursion.\noptions = (x, p, level) -> contparams this function allows to change the continuation options depending on the branching level. The argument x, p denotes the current solution to F(x, p)=0.\n\nOptional arguments\n\ncode = \"0\" code used to display iterations\nusedeflation = false\nhalfbranch = false for Pitchfork / Transcritical bifurcations, compute only half of the branch. Can be useful when there are symmetries.\nverbosediagram verbose specific to bifurcation diagram. Print information about the branches as they are being computed.\nkwargs optional arguments as for continuation but also for the different versions listed in Continuation.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"get_branch","category":"page"},{"location":"library/#BifurcationKit.get_branch","page":"Library","title":"BifurcationKit.get_branch","text":"get_branch(diagram, code)\n\n\nReturn the part of the diagram (bifurcation diagram) by recursively descending down the diagram using the Int valued tuple code. For example get_branch(diagram, (1,2,3,)) returns diagram.child[1].child[2].child[3].\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"get_branches_from_BP","category":"page"},{"location":"library/#BifurcationKit.get_branches_from_BP","page":"Library","title":"BifurcationKit.get_branches_from_BP","text":"get_branches_from_BP(diagram, indbif)\n\n\nReturn the part of the diagram corresponding to the indbif-th bifurcation point on the root branch.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"BifurcationKit.SpecialPoint","category":"page"},{"location":"library/#BifurcationKit.SpecialPoint","page":"Library","title":"BifurcationKit.SpecialPoint","text":"struct SpecialPoint{T, Tp, Tv, Tvτ} <: BifurcationKit.AbstractBifurcationPoint\n\nStructure to record special points on a curve. There are two types of special points that are recorded in this structure: bifurcation points and events (see https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/EventCallback/).\n\ntype::Symbol: Description of the special points. In case of Events, this field records the user passed named to the event, or the default :userD, :userC. In case of bifurcation points, it can be one of the following:\n- :bp Bifurcation point, simple eigenvalue crossing the imaginary axis\n- :fold Fold point\n- :hopf Hopf point\n- :nd not documented bifurcation point. Detected by multiple eigenvalues crossing. Generally occurs in problems with symmetries or in cases where the continuation step size is too large and merge two different bifurcation points.\n- :cusp Cusp point\n- :gh Generalized Hopf point (also called Bautin point)\n- :bt Bogdanov-Takens point\n- :zh Zero-Hopf point\n- :hh Hopf-Hopf point\n- :ns Neimark-Sacker point\n- :pd Period-doubling point\n- :R1 Strong resonance 1:1 of periodic orbits\n- :R2 Strong resonance 1:2 of periodic orbits\n- :R3 Strong resonance 1:3 of periodic orbits\n- :R4 Strong resonance 1:4 of periodic orbits\n- :foldFlip Fold / Flip of periodic orbits\n- :foldNS Fold / Neimark-Sacker of periodic orbits\n- :pdNS  Period-Doubling / Neimark-Sacker of periodic orbits\n- :gpd Generalized Period-Doubling of periodic orbits\n- :nsns Double Neimark-Sacker of periodic orbits\n- :ch Chenciner bifurcation of periodic orbits\n Default: :none\nidx::Int64: Index in br.branch or br.eig (see ContResult) for which the bifurcation occurs. Default: 0\nparam::Any: Parameter value at the special point (this is an estimate). Default: 0.0\nnorm::Any: Norm of the equilibrium at the special point Default: 0.0\nprintsol::Any: printsol = record_from_solution(x, param) where record_from_solution is one of the arguments to continuation Default: 0.0\nx::Any: Equilibrium at the special point Default: Vector{T}(undef, 0)\nτ::BorderedArray{Tvτ, T} where {T, Tvτ}: Tangent along the branch at the special point Default: BorderedArray(x, T(0))\nind_ev::Int64: Eigenvalue index responsible for detecting the special point (if applicable) Default: 0\nstep::Int64: Continuation step at which the special occurs Default: 0\nstatus::Symbol: status ∈ {:converged, :guess, :guessL} indicates whether the bisection algorithm was successful in detecting the special (bifurcation) point. If status == :guess, the bissection algorithm failed to meet the requirements given in ::ContinuationPar. Same for status == :guessL but the bissection algorithm stopped on the left of the bifurcation point. Default: :guess\nδ::Tuple{Int64, Int64}: δ = (δr, δi) where δr indicates the change in the number of unstable eigenvalues and δi indicates the change in the number of unstable eigenvalues with nonzero imaginary part. abs(δr) is thus an estimate of the dimension of the kernel of the Jacobian at the special (bifurcation) point. Default: (0, 0)\nprecision::Any: Precision in the location of the special point Default: -1\ninterval::Tuple{T, T} where T: Interval parameter containing the special point Default: (0, 0)\n\n\n\n\n\n","category":"type"},{"location":"library/#Utils-for-periodic-orbits","page":"Library","title":"Utils for periodic orbits","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"getperiod","category":"page"},{"location":"library/#BifurcationKit.getperiod","page":"Library","title":"BifurcationKit.getperiod","text":"getperiod(, x)\ngetperiod(, x, par)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetperiod(prob, x, p)\n\n\nCompute the period of the periodic orbit associated to x.\n\n\n\n\n\ngetperiod(psh, x_bar, par)\n\n\nCompute the period of the periodic orbit associated to x_bar.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"getamplitude","category":"page"},{"location":"library/#BifurcationKit.getamplitude","page":"Library","title":"BifurcationKit.getamplitude","text":"getamplitude(prob, x, p; ratio)\n\n\nCompute the amplitude of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = 1 + ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\ngetamplitude(prob, x, p; ratio)\n\n\nCompute the amplitude of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"getmaximum","category":"page"},{"location":"library/#BifurcationKit.getmaximum","page":"Library","title":"BifurcationKit.getmaximum","text":"getmaximum(prob, x, p; ratio)\n\n\nCompute the maximum of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = 1 + ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\ngetmaximum(prob, x, p)\n\n\nCompute the maximum of the periodic orbit associated to x.\n\n\n\n\n\ngetmaximum(prob, x, p; ratio)\n\n\nCompute the maximum of the periodic orbit associated to x. The keyword argument ratio = 1 is used as follows. If length(x) = ratio * n, the call returns the amplitude over x[1:n].\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"SectionSS","category":"page"},{"location":"library/#BifurcationKit.SectionSS","page":"Library","title":"BifurcationKit.SectionSS","text":"struct SectionSS{Tn, Tc} <: BifurcationKit.AbstractSection\n\nThis composite type (named for Section Standard Shooting) encodes a type of section implemented by a single hyperplane. It can be used in conjunction with ShootingProblem. The hyperplane is defined by a point center and a normal.\n\nnormal::Any: Normal to define hyperplane\ncenter::Any: Representative point on hyperplane\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"SectionPS","category":"page"},{"location":"library/#BifurcationKit.SectionPS","page":"Library","title":"BifurcationKit.SectionPS","text":"struct SectionPS{Tn, Tc, Tnb, Tcb, Tr} <: BifurcationKit.AbstractSection\n\nThis composite type (named for SectionPoincaréShooting) encodes a type of Poincaré sections implemented by hyperplanes. It can be used in conjunction with PoincareShootingProblem. Each hyperplane is defined par a point (one example in centers) and a normal (one example in normals).\n\nM::Int64\nnormals::Any\ncenters::Any\nindices::Vector{Int64}\nnormals_bar::Any\ncenters_bar::Any\nradius::Any\n\nConstructor(s)\n\nSectionPS(normals::Vector{Tv}, centers::Vector{Tv})\n\n\n\n\n\n","category":"type"},{"location":"library/#Misc.","page":"Library","title":"Misc.","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PrecPartialSchurKrylovKit","category":"page"},{"location":"library/#BifurcationKit.PrecPartialSchurKrylovKit","page":"Library","title":"BifurcationKit.PrecPartialSchurKrylovKit","text":"PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)\n\nBuilds a preconditioner based on deflation of nev eigenvalues chosen according to which. A partial Schur decomposition is computed (Matrix-Free), using the package KrylovKit.jl, from which a projection is built. The options are similar to the ones of EigKrylovKit().\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"PrecPartialSchurArnoldiMethod","category":"page"},{"location":"library/#BifurcationKit.PrecPartialSchurArnoldiMethod","page":"Library","title":"BifurcationKit.PrecPartialSchurArnoldiMethod","text":"PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)\n\nBuilds a preconditioner based on deflation of nev eigenvalues chosen according to which. A partial Schur decomposition is computed (Matrix-Free), using the package ArnoldiMethod.jl, from which a projection is built. See the package ArnoldiMethod.jl for how to pass the proper options.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Flow","category":"page"},{"location":"library/#BifurcationKit.Flow","page":"Library","title":"BifurcationKit.Flow","text":"struct Flow{TF, Tf, Tts, Tff, Td, Tad, Tse, Tprob, TprobMono, Tfs, Tcb, Tδ} <: BifurcationKit.AbstractFlow\n\nF::Any: The vector field (x, p) -> F(x, p) associated to a Cauchy problem. Used for the differential of the shooting problem. Default: nothing\nflow::Any: The flow (or semigroup) (x, p, t) -> flow(x, p, t) associated to the Cauchy problem. Only the last time point must be returned in the form (u = ...) Default: nothing\nflowTimeSol::Any: Flow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side. Default: nothing\nflowFull::Any: [Optional] The flow (or semigroup) associated to the Cauchy problem (x, p, t) -> flow(x, p, t). The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, it is mainly used for plotting on the user side. Please use nothing as default. Default: nothing\njvp::Any: The differential dflow of the flow w.r.t. x, (x, p, dx, t) -> dflow(x, p, dx, t). One important thing is that we require dflow(x, dx, t) to return a Named Tuple: (t = t, u = flow(x, p, t), du = dflow(x, p, dx, t)), the last component being the value of the derivative of the flow. Default: nothing\nvjp::Any: The adjoint differential vjpflow of the flow w.r.t. x, (x, p, dx, t) -> vjpflow(x, p, dx, t). One important thing is that we require vjpflow(x, p, dx, t) to return a Named Tuple: (t = t, u = flow(x, p, t), du = vjpflow(x, p, dx, t)), the last component being the value of the derivative of the flow. Default: nothing\njvpSerial::Any: [Optional] Serial version of dflow. Used internally when using parallel multiple shooting. Please use nothing as default. Default: nothing\nprob::Any: [Internal] store the ODEProblem associated to the flow of the Cauchy problem Default: nothing\nprobMono::Any: [Internal] store the ODEProblem associated to the flow of the variational problem Default: nothing\nflowSerial::Any: [Internal] Serial version of the flow Default: nothing\ncallback::Any: [Internal] Store possible callback Default: nothing\ndelta::Any: [Internal] Default: 1.0e-8\n\nSimplified constructor(s)\n\nWe provide a simple constructor where you only pass the vector field F, the flow ϕ and its differential dϕ:\n\nfl = Flow(F, ϕ, dϕ)\n\nSimplified constructors for DifferentialEquations.jl\n\nThese are some simple constructors for which you only have to pass a prob::ODEProblem or prob::EnsembleProblem (for parallel computation) from DifferentialEquations.jl and an ODE time stepper like Tsit5(). Hence, you can do for example\n\nfl = Flow(prob, Tsit5(); kwargs...)\n\nwhere kwargs is passed to SciMLBase::solve. If your vector field depends on parameters p, you can define a Flow using\n\nfl = Flow(prob, Tsit5(); kwargs...)\n\nFinally, you can pass two ODEProblem where the second one is used to compute the variational equation:\n\nfl = Flow(prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"FloquetQaD","category":"page"},{"location":"library/#BifurcationKit.FloquetQaD","page":"Library","title":"BifurcationKit.FloquetQaD","text":"floquet = FloquetQaD(eigsolver::AbstractEigenSolver)\n\nThis composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems (based on the Shooting method or Finite Differences (Trapeze method)), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents when the number of time sections is large because of many matrix products. It allows, nevertheless, to detect bifurcations. The arguments are as follows:\n\neigsolver::AbstractEigenSolver solver used to compute the eigenvalues.\n\nIf eigsolver == DefaultEig(), then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.\n\ndanger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver eigsolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of eigsolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"guess_from_hopf(br, ind_hopf, eigsolver::AbstractEigenSolver, M, amplitude; phase = 0)","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"get_normal_form","category":"page"},{"location":"library/#BifurcationKit.get_normal_form","page":"Library","title":"BifurcationKit.get_normal_form","text":"get_normal_form(\n    prob,\n    br,\n    id_bif;\n    nev,\n    verbose,\n    ζs,\n    ζs_ad,\n    lens,\n    Teigvec,\n    scaleζ,\n    detailed,\n    autodiff,\n    bls,\n    bls_adjoint,\n    bls_block\n)\n\n\nCompute the normal form of the bifurcation point located at br.specialpoint[ind_bif].\n\nArguments\n\nprob::AbstractBifurcationProblem\nbr result from a call to continuation\nind_bif index of the bifurcation point in br.specialpoint\n\nOptional arguments\n\nnev number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.\nverbose whether to display information\nζs list of vectors spanning the kernel of dF at the bifurcation point. Useful to enforce the basis for the normal form.\nlens::Lens specify which parameter to take the partial derivative ∂pF\nscaleζ function to normalise the kernel basis. Indeed, when used with large vectors and norm, it results in ζs and the normal form coefficient being super small.\nautodiff = true whether to use ForwardDiff for the differentiations w.r.t the parameters that are required to compute the normal form. Used for example for Bogdanov-Takens point. You can set to autodiff = false if you wish.\ndetailed = true whether to compute only a simplified normal form. Used for example for Bogdanov-Takens point.\nbls = MatrixBLS() specify Bordered linear solver. Used for example for Bogdanov-Takens point.\n\nAvailable method\n\nYou can directly call \n\nget_normal_form(br, ind_bif ; kwargs...)\n\nwhich is a shortcut for get_normal_form(getprob(br), br, ind_bif ; kwargs...).\n\nOnce the normal form nf has been computed, you can call predictor(nf, δp) to obtain an estimate of the bifurcating branch.\n\n\n\n\n\nget_normal_form(\n    prob,\n    br,\n    id_bif;\n    nev,\n    verbose,\n    ζs,\n    lens,\n    Teigvec,\n    scaleζ,\n    prm,\n    autodiff,\n    detailed,\n    δ\n)\n\n\nCompute the normal form of periodic orbits. We detail the additional keyword arguments specific to periodic orbits\n\nOptional arguments\n\nprm = true compute the normal form using Poincaré return map (PRM). If false, use the Iooss normal form. \n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"newton/#Krylov-Newton-algorithm","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"","category":"section"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"BifurcationKit is built upon the newton algorithm for solving (large-dimensional) nonlinear equations ","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"F(x)=0inmathbb R^nquad xinmathbb R^n","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"Writing J(x)inmathcal L(mathbb R^n) the jacobian, the algorithm reads","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"x_n+1 = x_n - J(x_n)^-1F(x_n)","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"with initial guess x_0.","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"The crux of the algorithm is to solve the linear system in y:","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"J(x_n)cdot y = F(x_n)","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"To this end, we never form J^-1 like with pinv(J) but solve the linear system directly. ","category":"page"},{"location":"newton/#Space-of-solutions","page":"Krylov-Newton algorithm","title":"Space of solutions","text":"","category":"section"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"For the algorithm to be defined, a certain number of operations on x need to be available. If you pass x::AbstractArray, you should not have any problem. Otherwise, your x must comply with the requirements listed in Requested methods for Custom State.","category":"page"},{"location":"newton/#Different-Jacobians","page":"Krylov-Newton algorithm","title":"Different Jacobians","text":"","category":"section"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"There are basically two ways to specify the jacobian:","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"Matrix based\nMatrix-free.","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"In case you pass a matrix (in effect an AbstractMatrix like a sparse one,...), you can use the default linear solver from LinearAlgebra termed the backslash operator \\. This is a direct method. This is the case 1 above.","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"Another possibility is to pass a function J(dx) and to use iterative linear solvers. In this case, this is termed a Krylov-Newton method. This is the case 2 above. In comparison to the Matrix-based case, there is no restriction to the number of unknowns n.","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"The available linear solvers are explained in the section Linear solvers (LS).","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"One can find a full description of the Krylov-Newton method in the API. ","category":"page"},{"location":"newton/#Simple-example","page":"Krylov-Newton algorithm","title":"Simple example","text":"","category":"section"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"Here is a quick example to show how the basics work. In particular, the problem generates a matrix based jacobian using automatic differentiation.","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"using BifurcationKit\nF(x, p) = x.^3 .- 1\nx0 = rand(10)\nprob = BifurcationProblem(F, x0, nothing)\nsol = newton(prob, NewtonPar(verbose = true))","category":"page"},{"location":"newton/#Example","page":"Krylov-Newton algorithm","title":"Example","text":"","category":"section"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"The (basic) tutorial Temperature model presents all cases (direct and iterative ones).","category":"page"},{"location":"newton/","page":"Krylov-Newton algorithm","title":"Krylov-Newton algorithm","text":"","category":"page"},{"location":"faq/#FAQ","page":"Frequently asked questions","title":"FAQ","text":"","category":"section"},{"location":"faq/#How-can-I-save-a-solution-every-n-steps,-or-at-specific-parameter-values?","page":"Frequently asked questions","title":"How can I save a solution every n steps, or at specific parameter values?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"You can use the callback finalise_solution in the function call continuation. For example, you can use something like this to save all steps","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"function mySave(u, tau, step, contResult, personaldata)\n\tpush!(personaldata, u)\nend","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"and pass it like continuation(prob, alg, opts; finalise_solution = (z, tau, step, contResult; k...) -> mySave(z, tau, step, contResult, myData))","category":"page"},{"location":"faq/#The-Fold-/-Hopf-Continuation-does-not-work,-why?","page":"Frequently asked questions","title":"The Fold / Hopf Continuation does not work, why?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"This requires some precise computations. Have you tried passing the expression of the Jacobian instead of relying on finite differences.","category":"page"},{"location":"faq/#What-is-the-parameter-theta-about-in-ContinuationPar?","page":"Frequently asked questions","title":"What is the parameter theta about in ContinuationPar?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"See the description of continuation on the page Library.","category":"page"},{"location":"faq/#How-can-I-change-the-preconditioner-during-computations?","page":"Frequently asked questions","title":"How can I change the preconditioner during computations?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"The easiest way to achieve this is by using the callbacks provided by newton and continuation. See the documentation about these two methods. See also the example 2d Ginzburg-Landau equation","category":"page"},{"location":"faq/#How-can-I-implement-my-own-bifurcation-detection-method?","page":"Frequently asked questions","title":"How can I implement my own bifurcation detection method?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"You can use the callback finalise_solution but the best way is probably to use the Iterator Interface to inject your code anywhere in the continuation procedure.","category":"page"},{"location":"faq/#How-do-I-dissociate-the-computation-of-eigenvalues-from-the-jacobian-that-I-passed?","page":"Frequently asked questions","title":"How do I dissociate the computation of eigenvalues from the jacobian that I passed?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"Sometimes, for example when implementing boundary conditions, you pass a jacobian J but the eigenvalues, and the bifurcation points are not simply related to J. One way to bypass this issue is to define a new eigensolver <: AbstractEigenSolver and pass it to the NewtonPar field eigsolver. This is done for example in example/SH2d-fronts-cuda.jl.","category":"page"},{"location":"faq/#How-can-I-print-the-eigenvalues-during-continuation?","page":"Frequently asked questions","title":"How can I print the eigenvalues during continuation?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"You can print the eigenvalues using the following callback:","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"finalise_solution = (z, tau, step, contResult; k...) -> begin\n\t\tBK.haseigenvalues(contResult) && Base.display(contResult.eig[end].eigenvals)\n\t\treturn true\n\tend,","category":"page"},{"location":"faq/#How-can-I-reject-a-Newton-Step?","page":"Frequently asked questions","title":"How can I reject a Newton Step?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"You can reject a newton step by passing to continuation the argument callback_newton","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"function mycallback((x, f, J, res, iteration, itlinear, options); kwargs...)\n\t# stop Newton algo if residual too large\n\tif res > 1e2\n\t\t@warn \"Reject Newton step!!\"\n\t\treturn false\n\tend\n\treturn true\nend","category":"page"},{"location":"faq/#How-do-I-stop-continuation?","page":"Frequently asked questions","title":"How do I stop continuation?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"Using the argument finalise_solution in continuation. Simply make this function finalise_solution return false.","category":"page"},{"location":"faq/#How-do-I-compute-both-sides-of-a-branch?","page":"Frequently asked questions","title":"How do I compute both sides of a branch?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"Instead of using two calls to continuation, you can pass the keyword bothside=true to continuation","category":"page"},{"location":"faq/#How-do-I-compute-period-orbits-for-non-autonomous-problems","page":"Frequently asked questions","title":"How do I compute period orbits for non-autonomous problems","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"The package does not yet allow to compute periodic orbits solutions of non-autonomous Cauchy problems like","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"fracdudt  = F(u par t)","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"On certain cases, one can still go away with the following trick. Say one is interested (dummy example!) to study","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"dot u = cos(u) + cos(omega cdot t)","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"Then one can use the following autonomous vector field","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"function vectorField(U, par)\n\tu, x, y = U\n\tout = similar(U)\n\tout[1] = cos(u) + x\n\tx2 = x^2+y^2\n\tout[2] = x + par.ω * y - x * x2\n\tout[3] = y - par.ω * x - y * x2\n\tout\nend","category":"page"},{"location":"faq/#Arpack-is-slow-in-computing-eigenvalues","page":"Frequently asked questions","title":"Arpack is slow in computing eigenvalues","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"This is probably due to iterative refinement conducted by SuiteSparse as explained in this blog post. You can disable this using","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"using SuiteSparse\nSuiteSparse.UMFPACK.umf_ctrl[8] = 0","category":"page"},{"location":"faq/#Should-I-use-CVODE_BDF?","page":"Frequently asked questions","title":"Should I use CVODE_BDF?","text":"","category":"section"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"SciML is now able to match the performance of the Sundials solver CVODE_BDF. Check the news for more information.","category":"page"},{"location":"faq/","page":"Frequently asked questions","title":"Frequently asked questions","text":"","category":"page"},{"location":"simplehopf/#Simple-Hopf-point","page":"Simple Hopf","title":"Simple Hopf point","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"At a Hopf branch point (x_0p_0) for the problem F(xp)=0, the spectrum of the linear operator dF(x_0p_0) contains two purely imaginary pm iomega omega  0 which are simple. At such point, we can compute the normal form to transform the initial Cauchy problem","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"dot x = mathbfF(xp)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"in large dimensions to a complex polynomial vector field (delta pequiv p-p_0):","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"dot z = zleft(a cdotdelta p + iomega + l_1z^2right)quadtext(E)","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"whose solutions give access to the solutions of the Cauchy problem in a neighborhood of (xp).","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"More precisely, if mathbfJ equiv dmathbfF(x_0p_0), then we have mathbfJzeta = iomegazeta and mathbfJbarzeta = -iomegabarzeta for some complex eigenvector zeta. It can be shown that x(t) approx x_0 + 2Re(z(t)zeta) when p=p_0+delta p.","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"tip: Coefficient $l_1$\nThe coefficient l_1 above is called the Lyapunov coefficient","category":"page"},{"location":"simplehopf/#Expression-of-the-coefficients","page":"Simple Hopf","title":"Expression of the coefficients","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"The coefficients ab above are computed as follows[Haragus]:","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"a=leftlanglemathbfF_11(zeta)+2 mathbfF_20left(zeta Psi_001right) zeta^*rightrangle","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"l_1=leftlangle 2 mathbfF_20left(zeta Psi_110right)+2 mathbfF_20left(barzeta Psi_200right)+3 mathbfF_30(zeta zeta barzeta) zeta^*rightrangle","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"where","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"beginaligned\n-mathbfJ Psi_001 =mathbfF_01 \n(2 i omega-mathbfJ) Psi_200 =mathbfF_20(zeta zeta) \n-mathbfJ Psi_110 =2 mathbfF_20(zeta barzeta)\nendaligned","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"and where","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"mathbfF(xp)-mathbfJx = sum_1leq q+lleq pmathbfF_ql(x^(q)p^(l))+o(u+p)^p","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"with mathbfF_ql a (q+l)-linear map. ","category":"page"},{"location":"simplehopf/#Normal-form-computation","page":"Simple Hopf","title":"Normal form computation","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"The normal form (E) is automatically computed as follows","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"get_normal_form(br::ContResult, ind_bif::Int ;\n\tverbose = false, ζs = nothing, lens = getlens(br))::Hopf","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"where prob is a bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The above call returns an object of type Hopf.","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"simplehopf/#Predictor","page":"Simple Hopf","title":"Predictor","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the method","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"predictor(hp::BifurcationKit.Hopf, ds; verbose = false, ampfactor = 1 )","category":"page"},{"location":"simplehopf/#BifurcationKit.predictor-Tuple{BifurcationKit.Hopf, Any}","page":"Simple Hopf","title":"BifurcationKit.predictor","text":"predictor(hp, ds; verbose, ampfactor)\n\n\nThis function provides prediction for the periodic orbits branching off the Hopf bifurcation point.\n\nArguments\n\nbp::Hopf the bifurcation point\nds at with distance relative to the bifurcation point do you want the prediction. Can be negative. Basically the new parameter is p = bp.p + ds.\n\nOptional arguments\n\nverbose display information\nampfactor = 1 factor multiplied to the amplitude of the periodic orbit.\n\nReturned values\n\nt -> orbit(t) 2π periodic function guess for the bifurcated orbit.\namp amplitude of the guess of the bifurcated periodic orbits.\nω frequency of the periodic orbit (corrected with normal form coefficients)\nperiod of the periodic orbit (corrected with normal form coefficients)\np new parameter value\ndsfactor factor which has been multiplied to abs(ds) in order to select the correct side of the bifurcation point where the bifurcated branch exists.\n\n\n\n\n\n","category":"method"},{"location":"simplehopf/#References","page":"Simple Hopf","title":"References","text":"","category":"section"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"[Haragus]: Haragus, Mariana, and Gérard Iooss. Local Bifurcations, Center Manifolds, and Normal Forms in Infinite-Dimensional Dynamical Systems. London: Springer London, 2011. https://doi.org/10.1007/978-0-85729-112-7.","category":"page"},{"location":"simplehopf/","page":"Simple Hopf","title":"Simple Hopf","text":"","category":"page"},{"location":"detectionBifurcationPO/#Detection-of-bifurcation-points-of-periodic-orbits","page":"Bifurcation detection (1 param)","title":"Detection of bifurcation points of periodic orbits","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The bifurcations are detected during a call to br = continuation(prob, alg, contParams::ContinuationPar;kwargs...) by turning on the following flags:","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"contParams.detect_bifurcation = 2","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The bifurcation points are located by looking at the spectrum e.g. by monitoring the unstable eigenvalues. The Floquet exponent λ is declared unstable if real(λ) > contParams.tol_stability. The located bifurcation points are then returned in br.specialpoint. ","category":"page"},{"location":"detectionBifurcationPO/#Precise-detection-of-bifurcation-points-using-Bisection","page":"Bifurcation detection (1 param)","title":"Precise detection of bifurcation points using Bisection","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"Note that the bifurcation points detected when detect_bifurcation = 2 can be rather crude  localization of the true bifurcation points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) bifurcation has been detected. Hence, we only have a rough idea of where the bifurcation is located, unless your dsmax is very small... This can be improved as follows.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"If you choose detect_bifurcation = 3, a bisection algorithm is used to locate the bifurcation points more precisely. It means that we recursively track down the change in stability. Some options in ContinuationPar control this behavior:","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"n_inversion: number of sign inversions in the bisection algorithm\nmax_bisection_steps maximum number of bisection steps\ntol_bisection_eigenvalue tolerance on real part of Floquet exponent to detect bifurcation points in the bisection steps","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"tip: Bisection mode\nDuring the bisection, the eigensolvers are called like eil(J, nev; bisection = true) in order to be able to adapt the solver precision.","category":"page"},{"location":"detectionBifurcationPO/#Large-scale-computations","page":"Bifurcation detection (1 param)","title":"Large scale computations","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The user must specify the number of eigenvalues to be computed (like nev = 10) in the parameters ::ContinuationPar passed to continuation. Note that nev is automatically incremented whenever a bifurcation point is detected [1]. Also, there is an option in ::ContinuationPar to save (or not) the eigenvectors. This can be useful in memory limited environments (like on GPUs).","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"[1]: In this case, the Krylov dimension is not increased because the eigensolver could be a direct solver. You might want to increase this dimension using the callbacks in continuation. ","category":"page"},{"location":"detectionBifurcationPO/#List-of-detected-bifurcation-points","page":"Bifurcation detection (1 param)","title":"List of detected bifurcation points","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"Bifurcation index used\nBifurcation point (single eigenvalue stability change, Fold or branch point) bp\nNeimark-Sacker ns\nPeriod doubling pd\nNot documented nd","category":"page"},{"location":"detectionBifurcationPO/#Eigensolver","page":"Bifurcation detection (1 param)","title":"Eigensolver","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The user must provide an eigensolver by setting NewtonOptions.eigsolver where newton_options is located in the parameter ::ContinuationPar passed to continuation. See NewtonPar and ContinuationPar for more information on the composite type of the options passed to newton and continuation.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The eigensolver is highly problem dependent and this is why the user should implement / parametrize its own eigensolver through the abstract type AbstractEigenSolver or select one among List of implemented eigen solvers.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"danger: Floquet multipliers computation\nThe computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option which = :LM of the eigensolver. Nevertheless, note that for most implemented eigensolvers in BifurcationKit, the proper option is automatically set.   ","category":"page"},{"location":"detectionBifurcationPO/#Generic-bifurcation","page":"Bifurcation detection (1 param)","title":"Generic bifurcation","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"By this we mean a change in the dimension of the Jacobian kernel. The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. ","category":"page"},{"location":"detectionBifurcationPO/#Fold-bifurcation","page":"Bifurcation detection (1 param)","title":"Fold bifurcation","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection of Fold point is done by monitoring  the monotonicity of the parameter.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection is triggered by setting detect_fold = true in the parameter ::ContinuationPar passed to continuation. When a Fold is detected on a branch br, a point is added to br.foldpoint allowing for later refinement using the function newton_fold.","category":"page"},{"location":"detectionBifurcationPO/#Neimark-Sacker-bifurcation","page":"Bifurcation detection (1 param)","title":"Neimark-Sacker bifurcation","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection of Neimark-Sacker point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. When a Neimark-Sacker point is detected, a point is added to br.specialpoint.","category":"page"},{"location":"detectionBifurcationPO/#Period-doubling-bifurcation","page":"Bifurcation detection (1 param)","title":"Period-doubling bifurcation","text":"","category":"section"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection of Period-doubling point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. When a Period-doubling point is detected, a point is added to br.specialpoint.","category":"page"},{"location":"detectionBifurcationPO/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"","category":"page"},{"location":"abs-from-hopf/#From-Hopf-/-PD-/-Branch-point-to-periodic-orbits","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf / PD / Branch point to periodic orbits","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"Pages = [\"abs-from-hopf.md\"]\nDepth = 3","category":"page"},{"location":"abs-from-hopf/#From-Hopf-point-to-periodic-orbits","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf point to periodic orbits","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"In order to compute the bifurcated branch of periodic solutions at a Hopf bifurcation point, you need to choose a method to compute periodic orbits among:","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"Periodic orbits based on Trapezoidal rule\nPeriodic orbits based on orthogonal collocation\nPeriodic orbits based on the shooting method","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"Once you have decided which method to use, you can call the following:","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"continuation(br::ContResult, ind_HOPF::Int, _contParams::ContinuationPar,\n\tprob::AbstractPeriodicOrbitProblem ;\n\tδp = nothing, ampfactor = 1, kwargs...)","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"We refer to continuation for more information about the arguments. Here, we just say a few words about how we can specify prob::AbstractPeriodicOrbitProblem.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"For Periodic orbits based on Trapezoidal rule, you can pass PeriodicOrbitTrapProblem(M = 51) where M is the number of times slices in the periodic orbit.\nFor Periodic orbits based on orthogonal collocation, you can pass PeriodicOrbitOCollProblem(M, m) where M is the number of times slices in the periodic orbit and m is the degree of the collocation polynomials.\nFor Periodic orbits based on the shooting method, you need more parameters. For example, you can pass ShootingProblem(M, odeprob, Euler()) or PoincareShootingProblem(M, odeprob, Euler()) where odeprob::ODEProblem (see DifferentialEquations.jl) is an ODE problem to specify the Cauchy problem amd M is the number of sections.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"See Branch switching (Hopf point) for the precise method definition","category":"page"},{"location":"abs-from-hopf/#Algorithm","page":"From Hopf/PD/Branch to periodic orbits","title":"Algorithm","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"The algorithm proceeds as follows. The normal form of the Hopf bifurcation is first computed. Then a predictor for the bifurcated branch of periodic orbits is generated from the normal form. Finally, this predictor is used as a guess for the computation of periodic orbits.","category":"page"},{"location":"abs-from-hopf/#Example","page":"From Hopf/PD/Branch to periodic orbits","title":"Example","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"The simplest example is from the getting-started section which we repeat partially below. Several examples are provided in example ODE. In the case of PDE, you can have a look at Brusselator or 2d Ginzburg-Landau equation.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"We compute a branch with a Hopf bifurcation:","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"using BifurcationKit, Parameters, Plots\n\nfunction Fsl(X, p)\n    @unpack r, μ, ν, c3 = p\n    u, v = X\n    ua = u^2 + v^2\n    [\n        r * u - ν * v - ua * (c3 * u - μ * v)\n        r * v + ν * u - ua * (c3 * v + μ * u)\n    ]\nend\n\npar_sl = (r = 0.1, μ = 0., ν = 1.0, c3 = 1.0)\nu0 = zeros(2)\nprob = BifurcationProblem(Fsl, u0, par_sl, (@lens _.r))\nopts = ContinuationPar()\nbr = continuation(prob, PALC(), opts, bothside = true)","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"We then compute the branch of periodic solutions using orthogonal collocation (for example):","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"br_po = continuation(br, 2, opts,\n        PeriodicOrbitOCollProblem(20, 5)\n        )\nplot(br, br_po)","category":"page"},{"location":"abs-from-hopf/#From-Period-doubling-point-to-curve-of-periodic-orbits","page":"From Hopf/PD/Branch to periodic orbits","title":"From Period-doubling point to curve of periodic orbits","text":"","category":"section"},{"location":"abs-from-hopf/#Case-of-Shooting-and-Collocation","page":"From Hopf/PD/Branch to periodic orbits","title":"Case of Shooting and Collocation","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"We provide an automatic branching procedure in this case. In essence, all you have to do is to call","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"continuation(br::ContResult, ind_PD::Int, _contParams::ContinuationPar;\n    prm = true, detailed = true,\n    kwargs...)","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"The option prm = true enforces that the period-doubling normal form is computed using the Poincaré return map ; this is only necessary in case of use of the collocation method. Indeed, in the case of the collocation method, an automatic procedure based on the Iooss normal form has yet to be implemented.","category":"page"},{"location":"abs-from-hopf/#Case-of-Trapezoid-method","page":"From Hopf/PD/Branch to periodic orbits","title":"Case of Trapezoid method","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"We do not provide (for now) the automatic branching procedure for these bifurcations of periodic orbits. As a consequence, the user is asked to provide the amplitude of the bifurcated solution.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"The call is as follows. Please note that a deflation is included in this method to simplify branch switching.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"continuation(br::AbstractBranchResult, ind_PD::Int, contParams::ContinuationPar;\n\tδp = 0.1, ampfactor = 1, \n\tusedeflation = false,\n\tkwargs...)","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"An example of use is provided in Lur'e problem.","category":"page"},{"location":"abs-from-hopf/#Algorithm-2","page":"From Hopf/PD/Branch to periodic orbits","title":"Algorithm","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"The algorithm proceeds as follows. The normal form of the Period-doubling bifurcation is first computed. Then a predictor for the bifurcated branch of periodic orbits is generated from the normal form. Finally, this predictor is used as a guess for the computation of periodic orbits.","category":"page"},{"location":"abs-from-hopf/#From-Branch-point-to-curve-of-periodic-orbits","page":"From Hopf/PD/Branch to periodic orbits","title":"From Branch point to curve of periodic orbits","text":"","category":"section"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"We do not provide (for now) the automatic branching procedure for these bifurcations of periodic orbits. As a consequence, the user is asked to provide the amplitude of the bifurcated solution.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"We provide the branching method for the following methods to compute periodic orbits: PeriodicOrbitTrapProblem, PeriodicOrbitOCollProblem, ShootingProblem and PoincareShootingProblem. The call is as follows. Please note that a deflation is included in this method to simplify branch switching.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"An example of use is provided in Lur'e problem.","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"continuation(br::AbstractBranchResult, ind_PD::Int, contParams::ContinuationPar;\n\tδp = 0.1, ampfactor = 1, usedeflation = false, kwargs...)","category":"page"},{"location":"abs-from-hopf/","page":"From Hopf/PD/Branch to periodic orbits","title":"From Hopf/PD/Branch to periodic orbits","text":"","category":"page"},{"location":"tutorials/tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials.md\"]\nDepth = 2","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"The tutorials are rated by the following scale of difficulty","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"🟢 basic knowledge of (numerical) bifurcation theory (following equilibria / periodic orbits)\n🟡 advanced knowledge of (numerical) bifurcation theory (codim 2 bifurcations of equilibria)\n🟠 high level of knowledge of (numerical) bifurcation theory (codim 2 bifurcations of periodic orbits, tweaking the methods)\n🟤 very advanced tutorial, research level","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"There are three levels of automatization of the computation in these tutorials:","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"fully automatic bifurcation diagram (aBD) computation (only for equilibria): one uses bifurcationdiagram and let it compute the diagram fully automatically. Another possibility is to use deflated continuation.\nsemi-automatic bifurcation diagram computation: one uses automatic branch switching (aBS) to compute branches at specified bifurcation points\nmanual bifurcation diagram computation: one does not use automatic branch switching. This has only educational purposes or for complex problems where aBS fails.","category":"page"},{"location":"tutorials/tutorials/#ODE-examples","page":"Tutorials","title":"ODE examples","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"These examples are specific to ODEs. ","category":"page"},{"location":"tutorials/tutorials/#Computation-of-equilibria","page":"Tutorials","title":"Computation of equilibria","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/tutorialsBasic1.md\", \"ode/tutorials1.md\", \"ode/tutorialPP2.md\",]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#Codimension-2-bifurcations-of-equilibria","page":"Tutorials","title":"Codimension 2 bifurcations of equilibria","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/tutorialCO.md\",\"ode/lorenz84.md\",]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#Periodic-orbits","page":"Tutorials","title":"Periodic orbits","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"We provide some examples focused on the computation of periodic orbits. Here is one where we present the different ways to compute periodic orbits. ","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/tutorialsODE.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Here is one for aBS from period-doubling bifurcations of periodic orbits","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/tutorialsODE-PD.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"In the next tutorial, we show how to refine a periodic orbit guess obtained from numerical simulation. We also show how to perform continuation of PD/NS points using Shooting or Collocation. ","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/tutorialsCodim2PO.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"In the next tutorial, we showcase the detection of Chenciner bifurcations. This is a relatively advanced tutorial, so we don't give much explanations. The reader should get first familiar with the above simpler examples.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/steinmetz.md\",]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"In the next tutorial, we showcase aBS from Bautin/HH to curve of Fold/NS of periodic orbits.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/lorenz84-PO.md\",]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#Homoclinic-orbits","page":"Tutorials","title":"Homoclinic orbits","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Based on the package HclinicBifurcationKit.jl and its docs.","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"🟡 Autonomous electronic circuit (aBS from BT)\n🟡 Nonlinear laser model","category":"page"},{"location":"tutorials/tutorials/#DAE-examples","page":"Tutorials","title":"DAE examples","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/Colpitts.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#DDE-examples","page":"Tutorials","title":"DDE examples","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"See the tutorials of DDEBifurcationKit.jl.","category":"page"},{"location":"tutorials/tutorials/#Examples-based-on-ModelingToolkit","page":"Tutorials","title":"Examples based on ModelingToolkit","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"ode/NME-MTK.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#PDEs:-bifurcations-of-equilibria","page":"Tutorials","title":"PDEs: bifurcations of equilibria","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials1.md\", \"tutorials1b.md\", \"tutorials2.md\", \"mittelmann.md\", \"tutorials2b.md\", \"tutorialsSH3d.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#PDEs:-automatic-bifurcation-diagram","page":"Tutorials","title":"PDEs: automatic bifurcation diagram","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"Swift-Hohenberg1d.md\", \"tutorialCarrier.md\", \"ks1d.md\", \"mittelmannAuto.md\", \"ks2d.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#PDEs:-bifurcations-of-periodic-orbits","page":"Tutorials","title":"PDEs: bifurcations of periodic orbits","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"tutorials3.md\",\"tutorials3b.md\", \"BrusselatorFF.md\", \"tutorialsPD.md\", \"tutorialsCGL.md\", \"tutorialsCGLShoot.md\",\"Langmuir.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#PDEs-based-on-FEM-with-[Gridap.jl](https://github.com/gridap/Gridap.jl)","page":"Tutorials","title":"PDEs based on FEM with Gridap.jl","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"mittelmannGridap.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/#Symmetries,-freezing,-waves,-fronts","page":"Tutorials","title":"Symmetries, freezing, waves, fronts","text":"","category":"section"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"Pages = [\"autocatalyticAuto.md\", \"autocatalytic.md\", \"cgl1dwave.md\", \"detonationEngine.md\"]\nDepth = 1","category":"page"},{"location":"tutorials/tutorials/","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"PDContinuationPO/#Continuation-of-Period-doubling-(PD)-bifurcations-of-periodic-orbits","page":"Period-Doubling continuation (2 params)","title":"Continuation of Period-doubling (PD) bifurcations of periodic orbits","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"Pages = [\"PDContinuationPO.md\"]\nDepth = 2","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"In this page, we explain how to perform continuation of PD points of periodic orbits and detect the following codim 2 bifurcations.","category":"page"},{"location":"PDContinuationPO/#List-of-detected-codim-2-bifurcation-points","page":"Period-Doubling continuation (2 params)","title":"List of detected codim 2 bifurcation points","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"Bifurcation symbol used Multipliers\nStrong resonance 1:2 bifurcation R2 {1,-1,-1}\nFold / Flip foldFlip {1,1,-1}\nPeriod-Doubling / Neimark-Sacker pdNS {-1,e^pm ialpha}\nGeneralized Period-Doubling gpd {1,-1}","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"In a nutshell, all you have to do (see below) is to call continuation(br, ind_bif, lens2) to continue the bifurcation point stored in br.specialpoint[ind_bif] and set proper options.","category":"page"},{"location":"PDContinuationPO/#PD-continuation","page":"Period-Doubling continuation (2 params)","title":"PD continuation","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"The continuation of PD bifurcation points is based on a Minimally Augmented[Govaerts] formulation which is an efficient way to detect singularities (see Fold / Hopf Continuation). All the methods (see Periodic orbits computation), except the Trapezoid one, for computing periodic orbits are compatible with this algorithm. In particular, you can perform these computations in large dimensions.","category":"page"},{"location":"PDContinuationPO/#Detection-of-codim-2-bifurcation-points","page":"Period-Doubling continuation (2 params)","title":"Detection of codim 2 bifurcation points","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"You can detect the following codim 2 bifurcation points by using the option detect_codim2_bifurcation in the method continuation ","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"the detection of Generalised Period-Doubling bifurcation is done by computing the PD normal form\nthe detection the above bifurcation points is done by monitoring the number of eigenvalues lambda such that Relambda  minlimits_nuinSigma(dF)Renu and Imlambda  epsilon where epsilon is the Newton tolerance.","category":"page"},{"location":"PDContinuationPO/#Setting-the-jacobian","page":"Period-Doubling continuation (2 params)","title":"Setting the jacobian","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"In order to apply the newton algorithm to the PD functional, one needs to invert the jacobian. This is not completely trivial as one must compute this jacobian and then invert it. You can select the following jacobians for your computations (see below):","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"[Default] for jacobian_ma = :autodiff, automatic differentiation is applied to the PD functional and the matrix is then inverted using the provided linear solver. In particular, the jacobian is formed. This is very well suited for small dimensions  (say < 100)\nfor jacobian_ma = :finiteDifferences, same as jacobian_ma = :autodiff but the jacobian is computed using finite differences.\nfor jacobian_ma = :minaug, a specific procedure for evaluating the jacobian and inverting it (without forming the jacobian!) is used. This is well suited for large dimensions.","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"For the case jacobian_ma = :minaug, when the shooting method is employed, the adjoint of the flow is required. This can usually be computed with ReverseDiff.jl.","category":"page"},{"location":"PDContinuationPO/#Codim-2-continuation","page":"Period-Doubling continuation (2 params)","title":"Codim 2 continuation","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"To compute the codim 2 curve of PD points of periodic orbits, one can call continuation with the following options","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":" continuation(br::BifurcationKit.AbstractBranchResult, ind_pd::Int64,\n\t\t\t\tlens2::Lens, options_cont::ContinuationPar = br.contparams ;\n\t\t\t\tkwargs...)","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"where br is a branch of periodic orbits and the options are as above except with have an additional parameter axis lens2 which is used to locate the bifurcation points.","category":"page"},{"location":"PDContinuationPO/#Algorithmic-details","page":"Period-Doubling continuation (2 params)","title":"Algorithmic details","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"The continuation of PD points is based on the formulation","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"G(upomega) = (F_po(up) sigma(up))inmathbb R^n+1quadquad (mathcal F_pd)","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"where F_po is the functional for locating periodic orbits and the test function sigma is solution of","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"leftbeginarraycc\nN(up)  w \nv^top  0\nendarrayrightleftbeginarrayc\nr \nsigma(up)\nendarrayright=leftbeginarrayc\n0_n \n1\nendarrayright","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"The jacobian of the PD functional to use for the Newton algorithm","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"leftbeginarraycc\npartial_uF_po  partial_pF_po \npartial_usigma  partial_psigma\nendarrayright","category":"page"},{"location":"PDContinuationPO/#Shooting","page":"Period-Doubling continuation (2 params)","title":"Shooting","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"In the case of Multiple Standard Shooting, the matrix N is based on the monodromy M(x_iT_i)","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"N=left(beginarraycccccc\nM_1  -I  0  cdots  0 \n0  M_2  -I  cdots  0 \nvdots    ddots  ddots  vdots \n0  cdots  cdots  ddots  -I \nI  cdots  cdots  0  M_m \nendarrayright)","category":"page"},{"location":"PDContinuationPO/#","page":"Period-Doubling continuation (2 params)","title":"","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"In the case of orthogonal collocation, the matrix N is the jacobian of the periodic orbit functional stripped of the phase condition (m=2):","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"left(beginarraylllllll\nH_00^0  H_01^0  H_10^0     \nH_00^1  H_01^1  H_10^1     \n  H_10^0  H_11^0  H_20^0   \n  H_10^1  H_11^1  H_20^1   \n    H_20^0  H_21^0  H_30^0 \n    H_20^1  H_21^1  H_30^1 \n      \nI       I\nendarrayright)","category":"page"},{"location":"PDContinuationPO/#References","page":"Period-Doubling continuation (2 params)","title":"References","text":"","category":"section"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"[Govaerts]: Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.","category":"page"},{"location":"PDContinuationPO/","page":"Period-Doubling continuation (2 params)","title":"Period-Doubling continuation (2 params)","text":"","category":"page"},{"location":"detectionBifurcation/#Detection-of-bifurcation-points-of-Equilibria","page":"Bifurcation detection (1 param)","title":"Detection of bifurcation points of Equilibria","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The bifurcations are detected during a call to br = continuation(prob, alg, contParams::ContinuationPar;kwargs...) by turning on the following flags:","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"contParams.detect_bifurcation = 2","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The bifurcation points are located by looking at the spectrum e.g. by monitoring the unstable eigenvalues. The eigenvalue λ is declared unstable if real(λ) > contParams.tol_stability. The located bifurcation points are then returned in br.specialpoint.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"warning: Eigenvalues\nThe rightmost eigenvalues are computed by default to detect bifurcations. Hence, the number of eigenvalues with positive real parts must be finite (e.g. small). This might require to consider -F(xp)=0 instead of (E).","category":"page"},{"location":"detectionBifurcation/#Precise-detection-of-bifurcation-points-using-Bisection","page":"Bifurcation detection (1 param)","title":"Precise detection of bifurcation points using Bisection","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"Note that the bifurcation points detected when detect_bifurcation = 2 can be rather crude  localization of the true bifurcation points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) bifurcation has been detected. Hence, we only have a rough idea of where the bifurcation is located, unless your dsmax is very small... This can be improved as follows.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"If you choose detect_bifurcation = 3, a bisection algorithm is used to locate the bifurcation points more precisely. It means that we recursively track down the change in stability. Some options in ContinuationPar control this behavior:","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"n_inversion: number of sign inversions in the bisection algorithm\nmax_bisection_steps maximum number of bisection steps\ntol_bisection_eigenvalue tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"If this is still not enough, you can use a Newton solver to locate them very precisely. See Fold / Hopf Continuation.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"tip: Bisection mode\nDuring the bisection, the eigensolvers are called like eil(J, nev; bisection = true) in order to be able to adapt the solver precision.","category":"page"},{"location":"detectionBifurcation/#Large-scale-computations","page":"Bifurcation detection (1 param)","title":"Large scale computations","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The user must specify the number of eigenvalues to be computed (like nev = 10) in the parameters ::ContinuationPar passed to continuation. Note that nev is automatically incremented whenever a bifurcation point is detected [1]. Also, there is an option in ::ContinuationPar to save (or not) the eigenvectors. This can be useful in memory limited environments (like on GPUs).","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"[1]: In this case, the Krylov dimension is not increased because the eigensolver could be a direct solver. You might want to increase this dimension using the callbacks in continuation. ","category":"page"},{"location":"detectionBifurcation/#List-of-detected-bifurcation-points","page":"Bifurcation detection (1 param)","title":"List of detected bifurcation points","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"Bifurcation index used\nFold fold\nHopf hopf\nBifurcation point (single eigenvalue stability change, Fold or branch point) bp\nNot documented nd","category":"page"},{"location":"detectionBifurcation/#Eigensolver","page":"Bifurcation detection (1 param)","title":"Eigensolver","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The user must provide an eigensolver by setting NewtonOptions.eigsolver where newton_options is located in the parameter ::ContinuationPar passed to continuation. See NewtonPar and ContinuationPar for more information on the composite type of the options passed to newton and continuation.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The eigensolver is highly problem dependent and this is why the user should implement / parametrize its own eigensolver through the abstract type AbstractEigenSolver or select one among List of implemented eigen solvers.","category":"page"},{"location":"detectionBifurcation/#Generic-bifurcation","page":"Bifurcation detection (1 param)","title":"Generic bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"By this we mean a change in the dimension of the Jacobian kernel. The detection of Branch point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. ","category":"page"},{"location":"detectionBifurcation/#Fold-bifurcation","page":"Bifurcation detection (1 param)","title":"Fold bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection of Fold point is done by monitoring  the monotonicity of the parameter.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection is triggered by setting detect_fold = true in the parameter ::ContinuationPar passed to continuation. When a Fold is detected on a branch br, a point is added to br.foldpoint allowing for later refinement using the function newton_fold.","category":"page"},{"location":"detectionBifurcation/#Hopf-bifurcation","page":"Bifurcation detection (1 param)","title":"Hopf bifurcation","text":"","category":"section"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection of Hopf point is done by analysis of the spectrum of the Jacobian.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"The detection is triggered by setting detect_bifurcation > 1 in the parameter ::ContinuationPar passed to continuation. When a Hopf point is detected, a point is added to br.specialpoint allowing for later refinement using the function newton_hopf.","category":"page"},{"location":"detectionBifurcation/","page":"Bifurcation detection (1 param)","title":"Bifurcation detection (1 param)","text":"","category":"page"},{"location":"intro_wave/#Freezing-problems,-symmetries-and-waves","page":"Introduction","title":"Freezing problems, symmetries and waves","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"This section is dedicated to the study of the equation F(x,p)=0 where one wishes to freeze a continuous symmetry. When the equation F(x p) = 0 has a continuous symmetry described by a Lie group G and action gcdot x for gin G, one can reduce the symmetry of F by considering the constrained problem[Beyn]:","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"left\nbeginarrayltagW\nF(x p) - scdot Tcdot x=0 \nlangle Tcdot x_refx-x_refrangle=0\nendarrayright","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"where T is a generator of the Lie algebra associated to G, x_ref is a reference solution and s is the speed. This is known as the freezing method.","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"Similarly, one can reduce several symmetries by considering","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"left\nbeginarrayl\nF(x p) - sumlimits_i=1^N_g s_icdot T_icdot x=0 \nlangle T_icdot x_refx-x_refrangle=0quad i=1cdotsN_g\nendarrayright","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"We call a solution (x,p,s) of (W) a wave.","category":"page"},{"location":"intro_wave/#Wave-stability","page":"Introduction","title":"Wave stability","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"There are several ways to compute the stability of a wave (x^wps^w). From [Sandstede], this requires to compute the spectrum of","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"d_1F(xp)- sumlimits_i=1^N_g s_icdot T_itagEV","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"However, there is (potentially) the zero eigenvalue associated to the eigenvectors T_icdot x^w. In practice, because the symmetry is discrete numerically, we find a small eigenvalue instead of 0.","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"Another way to compute the same spectrum is to proceed as follows. Using (W) as a definition of the functional G((xs)p)inmathbb R^N+1, the eigenproblem for computing the stability of a wave (x^ws^w) is","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"A x = σ BxtagGEV","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"where B = diag(1cdots10) and A=dG. An advantage of (GEV) over (EV) is that the trivial eigenvalues are removed but it comes at an increased cost. We can improved this situation as follows.","category":"page"},{"location":"intro_wave/#Case-N_g1","page":"Introduction","title":"Case N_g=1","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"Let us have a look at (GEV) more closely. We need to solve for the eigenvalues sigma and the eigenvectors (x_1c_1) solutions of","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"left\nbeginarrayltagW\nJ x_1+c_1A_12 = sigma x_1 \nlangle A_21x_1rangle + A_22c_1=0\nendarrayright","category":"page"},{"location":"intro_wave/#Case-A_{22}\\neq-0","page":"Introduction","title":"Case A_22neq 0","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"If A_22neq 0, the eigen problem is equivalent to","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"Jx_1 - c_1fraclangle A_21x_1rangleA_22 A_12= sigma x_1","category":"page"},{"location":"intro_wave/#Case-A_{22}-0","page":"Introduction","title":"Case A_22 = 0","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"If A_22 = 0, the eigen problem is equivalent to x_1=α A_21 + x_1^bot with langle A_21x_1^botrangle=0. Hence, I find langle A_21Jx_1^botrangle+c_1langle A_21A_12rangle=0","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"Jx_1^bot-fraclangle A_21Jx_1^botranglelangle A_21A_12rangleA_21=σ x_1^","category":"page"},{"location":"intro_wave/#Encoding-of-the-functional-for-the-freezed-problem","page":"Introduction","title":"Encoding of the functional for the freezed problem","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"The freezing method is encoded in the composite type TWProblem which we loosely refer to as a Travelling Wave (TW) problem. ","category":"page"},{"location":"intro_wave/#Computation-with-newton","page":"Introduction","title":"Computation with newton","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"We provide a simplified call to newton to locate the freezed solution","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"newton(prob::TWProblem, orbitguess, options::NewtonPar; kwargs...)","category":"page"},{"location":"intro_wave/#Continuation","page":"Introduction","title":"Continuation","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"We also provide a simplified call to continuation to continue the freezed solution as function of a parameter:","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"continuation(prob::TWProblem, orbitguess, lens::Lens, contParams::ContinuationPar; jacobian = :MatrixFree, kwargs...)","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"Note that in this case, the eigen solver passed in contParams is converted into an appropriate generalized eigensolver.","category":"page"},{"location":"intro_wave/#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"[Beyn]: Beyn and Thümmler, Phase Conditions, Symmetries and PDE Continuation.","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"[Sandstede]: Sandstede, Björn. “Stability of Travelling Waves.” In Handbook of Dynamical Systems, 2:983–1055. Elsevier, 2002. https://doi.org/10.1016/S1874-575X(02)80039-X.","category":"page"},{"location":"intro_wave/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"abs-from-codim2-eq/#From-codim-2-to-equilibria","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"","category":"section"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"Pages = [\"abs-from-codim2-eq.md\"]\nDepth = 3","category":"page"},{"location":"abs-from-codim2-eq/#From-Bogdanov-Takens-(BT)-point-to-Fold-/-Hopf-curve","page":"From codim 2 to equilibria","title":"From Bogdanov-Takens (BT) point to Fold / Hopf curve","text":"","category":"section"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"We provide an automatic branch switching method in this case (see for example Extended Lorenz-84 model or 2d Ginzburg-Landau equation (finite differences, codim 2, Hopf aBS)). Hence, you can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"continuation(br::ContResult, ind_BT::Int,\n\toptions_cont::ContinuationPar = br.contparams;\n\tnev = options_cont.nev,\n\tdetect_codim2_bifurcation::Int = 0,\n\tstart_with_eigen = false,\n\tautodiff = false,\n\tTeigvec = getvectortype(br),\n\tscaleζ = norm,\n\tkwargs...)","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"where ind_BT is the index of the BT point in br. Note that the BT has been detected during Fold or Hopf continuation. Calling the above method thus switches from Fold continuation to Hopf continuation (and vice-versa) automatically with the same parameter axis.","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"Check the docs of Fold / Hopf Continuation and particularly Setting the jacobian for improving the speed of computation for large scale systems.","category":"page"},{"location":"abs-from-codim2-eq/#From-Zero-Hopf-(ZH)-point-to-Fold-/-Hopf-curve","page":"From codim 2 to equilibria","title":"From Zero-Hopf (ZH) point to Fold / Hopf curve","text":"","category":"section"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"We provide an automatic branch switching method in this case (see for example Extended Lorenz-84 model or 2d Ginzburg-Landau). Hence, you can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"continuation(br::ContResult, ind_ZH::Int,\n\toptions_cont::ContinuationPar = br.contparams;\n\tnev = options_cont.nev,\n\tdetect_codim2_bifurcation::Int = 0,\n\tstart_with_eigen = false,\n\tautodiff = false,\n\tTeigvec = getvectortype(br),\n\tscaleζ = norm,\n\tkwargs...)","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"where ind_ZH is the index of the ZH point in br. Note that the ZH has been detected during Fold or Hopf continuation. Calling the above method thus switches from Fold continuation to Hopf continuation (and vice-versa) automatically with the same parameter axis.","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"Check the docs of Fold / Hopf Continuation and particularly Setting the jacobian for improving the speed of computation for large scale systems.","category":"page"},{"location":"abs-from-codim2-eq/#From-Hopf-Hopf-(HH)-point-to-Fold-/-Hopf-curve","page":"From codim 2 to equilibria","title":"From Hopf-Hopf (HH) point to Fold / Hopf curve","text":"","category":"section"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"We provide an automatic branch switching method in this case (see for example Extended Lorenz-84 model or 2d Ginzburg-Landau equation). Hence, you can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"continuation(br::ContResult, ind_HH::Int,\n\toptions_cont::ContinuationPar = br.contparams;\n\tδp = nothing, ampfactor::Real = 1,\n\tnev = options_cont.nev,\n\tdetect_codim2_bifurcation::Int = 0,\n\tstart_with_eigen = false,\n\tautodiff = false,\n\tTeigvec = getvectortype(br),\n\tscaleζ = norm,\n\tkwargs...)","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"where ind_HH is the index of the HH point in br. Note that the HH has been detected during Hopf continuation. Calling the above method thus switches from Hopf continuation to another Hopf branch automatically with the same parameter axis.","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"Check the docs of Fold / Hopf Continuation and particularly Setting the jacobian for improving the speed of computation for large scale systems.","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"","category":"page"},{"location":"abs-from-codim2-eq/","page":"From codim 2 to equilibria","title":"From codim 2 to equilibria","text":"","category":"page"},{"location":"simplebp/#Simple-bifurcation-branch-point","page":"Simple branch point","title":"Simple bifurcation branch point","text":"","category":"section"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"unknown: References\nThe general method is exposed in Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"A simple branch point (x_0p_0) for the problem F(xp)=0 satisfies dim ker dF(x_0p_0) = 1. At such point, we can apply Lyapunov-Schmidt reduction to transform the initial problem in large dimensions to a scalar polynomial (delta p equiv p-p_0): ","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"adelta p + zleft(b_1delta p + fracb_22z + fracb_36z^2right) = 0 tagE","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"whose solutions give access to all solutions in a neighborhood of (xp).","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"More precisely, if ker dF(x_0p_0) = mathbb Rzeta, one can show that x_0+zzeta is close to a solution on a new branch, thus satisfying F(x_0+zzetap_0+delta p)approx 0.","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"In the above scalar equation,","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"if aneq 0, this is a Saddle-Node bifurcation\nif a=0b_2neq 0, the bifurcation point is Transcritical and the bifurcated branch exists on each side of p_0.\nif a=0b_2=0 b_3neq 0, the bifurcation point is a Pitchfork and the bifurcated branch only exists on one side of p_0.","category":"page"},{"location":"simplebp/#Normal-form-computation","page":"Simple branch point","title":"Normal form computation","text":"","category":"section"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"The reduced equation (E) can be automatically computed as follows","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"get_normal_form(br::ContResult, ind_bif::Int ;\n\tverbose = false, ζs = nothing, lens = getlens(br))","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"where prob is the bifurcation problem. br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns an object of type BranchPoint.","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"simplebp/#Predictor","page":"Simple branch point","title":"Predictor","text":"","category":"section"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the methods (depending on the type of the bifurcation point)","category":"page"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"BifurcationKit.predictor(bp::Union{BifurcationKit.Transcritical, BifurcationKit.TranscriticalMap}, ds::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"simplebp/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{Union{BifurcationKit.Transcritical, BifurcationKit.TranscriticalMap}, T}} where T","page":"Simple branch point","title":"BifurcationKit.predictor","text":"predictor(bp, ds; verbose, ampfactor)\n\n\nThis function provides prediction for the zeros of the Transcritical bifurcation point.\n\nArguments\n\nbp::Transcritical the bifurcation point\nds distance to the bifurcation point for the prediction. Can be negative. Basically the parameter is p = bp.p + ds\n\nOptional arguments\n\nverbose display information\nampfactor = 1 factor multiplying prediction\n\nReturned values\n\nx0 trivial solution (which bifurcates)\nx1 non trivial guess, corrected with Lyapunov-Schmidt expansion\np new parameter value \namp non trivial zero of the normal form (not corrected)\nxm1 non trivial guess for the parameter pm1\npm1 parameter value bp.p - ds\n\n\n\n\n\n","category":"method"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"BifurcationKit.predictor(bp::Union{BifurcationKit.Pitchfork, BifurcationKit.PitchforkMap}, ds::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"simplebp/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{Union{BifurcationKit.Pitchfork, BifurcationKit.PitchforkMap}, T}} where T","page":"Simple branch point","title":"BifurcationKit.predictor","text":"predictor(bp, ds; verbose, ampfactor)\n\n\nThis function provides prediction for the zeros of the Pitchfork bifurcation point.\n\nArguments\n\nbp::Pitchfork the bifurcation point\nds at with distance relative to the bifurcation point do you want the prediction. Based on the criticality of the Picthfork, its sign is enforced no matter what you pass. Basically the parameter is bp.p + abs(ds) * dsfactor where dsfactor = ±1 depending on the criticality.\n\nOptional arguments\n\nverbose display information\nampfactor = 1 factor multiplying prediction\n\nReturned values\n\nx0 trivial solution (which bifurcates)\nx1 non trivial guess\np new parameter value\ndsfactor factor which has been multiplied to abs(ds) in order to select the correct side of the bifurcation point where the bifurcated branch exists.\namp non trivial zero of the normal form\n\n\n\n\n\n","category":"method"},{"location":"simplebp/","page":"Simple branch point","title":"Simple branch point","text":"","category":"page"},{"location":"IntroContinuation/#Continuation-methods:-introduction","page":"Introduction","title":"Continuation methods: introduction","text":"","category":"section"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"Pages = [\"IntroContinuation.md\"]\nDepth = 3","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"The goal of these methods[Kuz],[Govaerts],[Rabinowitz],[Mei],[Keller] is to find solutions xinmathbb R^n to nonlinear equations","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"mathbb R^nni F(xp) = 0 quadtagE","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"as function of a real parameter p. Given a known solution (x_0p_0), we can, under reasonable assumptions, continue it by computing a 1d curve of solutions gamma = (x(s)p(s))_sin I passing through (x_0p_0).","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"For the sequel, it is convenient to use the following formalism [Kuz]","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"prediction of the next point\ncorrection\nstep size control.","category":"page"},{"location":"IntroContinuation/#Natural-continuation","page":"Introduction","title":"Natural continuation","text":"","category":"section"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"More information is available at Predictors - Correctors","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"We just use this simple continuation method to give a trivial example of the formalism. Knowing (x_0 p_0), we form the predictor (x_0 p_0+ds) for some ds and use it as a guess for a Newton corrector applied to xto F(x p_0+ds). The corrector is thus the Newton algorithm.","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"This continuation method is continuation(prob, Natural(), options).","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"danger: Usage\nYou should almost never use this predictor for computations. It fails at turning points, is not adaptive, ... ","category":"page"},{"location":"IntroContinuation/#Step-size-control","page":"Introduction","title":"Step size control","text":"","category":"section"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"Each time the corrector phase failed, the step size ds is halved. This has the disadvantage of having unnecessary Newton iterations (which costs time) and imposing small steps (which can be slow as well). To prevent this, the step size can be controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor a in ContinuationPar.","category":"page"},{"location":"IntroContinuation/#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"[Kuz]: Kuznetsov, Elements of Applied Bifurcation Theory.","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"[Govaerts]: Govaerts, Numerical Methods for Bifurcations of Dynamical Equilibria; Allgower and Georg, Numerical Continuation Methods","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"[Rabinowitz]: Rabinowitz, Applications of Bifurcation Theory; Dankowicz and Schilder, Recipes for Continuation","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"[Mei]: Mei, Numerical Bifurcation Analysis for Reaction-Diffusion Equations","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"[Keller]: Keller, Lectures on Numerical Methods in Bifurcation Problems","category":"page"},{"location":"IntroContinuation/","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"BifurcationDiagram/#Automatic-Bifurcation-diagram-computation","page":"Bifurcation diagram","title":"Automatic Bifurcation diagram computation","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"Thanks to the functionality presented in this part, we can compute the bifurcation diagram of a system recursively and fully automatically. More precisely, the function bifurcationdiagram allows to:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"compute a branch gamma of equilibria\ndetect all bifurcations on the branch\nrecursively compute the branches emanating from branch points on gamma.","category":"page"},{"location":"BifurcationDiagram/#Pitfalls","page":"Bifurcation diagram","title":"Pitfalls","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"For now, there is no way to decide if two branches gamma_1gamma_2 are the same. As a consequence:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"there is no loop detection. Hence, if the branch gamma has a component akin to a circle, you may experience a large number of branches\nif the bifurcation diagram itself has loops (see example below), you may experience a large number of branches","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"warning: Memory\nThe whole diagram is stored in RAM and you might be careful computing it on GPU. We'll add a file system for this in the future. ","category":"page"},{"location":"BifurcationDiagram/#Basic-example-with-simple-branch-points","page":"Bifurcation diagram","title":"Basic example with simple branch points","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using Revise, Plots\nusing BifurcationKit\n\nFbp(u, p) = @. -u * (p + u * (2-5u)) * (p -.15 - u * (2+20u))\n\n# bifurcation problem\nprob = BifurcationProblem(Fbp, [0.0], -0.2, \n\t# specify the continuation parameter\n\t(@lens _);\n\trecord_from_solution = (x, p) -> x[1])\n\n# options for newton\n# we reduce a bit the tolerances to ease automatic branching\nopt_newton = NewtonPar(tol = 1e-9)\n\n# options for continuation\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.005, ds = 0.001,\n\tnewton_options = opt_newton,\n\tnev = 1,\n\t# parameter interval\n\tp_min = -1.0, p_max = .3,\n\t# detect bifurcations with bisection method\n\t# we increase here the precision for the detection of\n\t# bifurcation points\n\tn_inversion = 8)\n\ndiagram = bifurcationdiagram(prob, PALC(),\n\t# very important parameter. This specifies the maximum amount of recursion\n\t# when computing the bifurcation diagram. It means we allow computing branches of branches \n\t# at most in the present case.\n\t2,\n\topts_br,\n)\n\t\n# You can plot the diagram like \nplot(diagram; putspecialptlegend=false, markersize=2, plotfold=false, title = \"#branches = $(size(diagram))\")","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"This gives","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"diagram","category":"page"},{"location":"BifurcationDiagram/#Example-with-nonsimple-branch-points","page":"Bifurcation diagram","title":"Example with nonsimple branch points","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"To show the ability of the branch switching method to cope with non simple branch points, we look at the normal form of the Pitchfork with D6 symmetry which occurs frequently in problems with hexagonal symmetry. You may want to look at Bratu–Gelfand problem for a non trivial example of use.","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using Revise, Plots\nusing BifurcationKit\nconst BK = BifurcationKit\n\nfunction FbpD6(x, p)\n\treturn [ p.μ * x[1] + (p.a * x[2] * x[3] - p.b * x[1]^3 - p.c*(x[2]^2 + x[3]^2) * x[1]),\n\t\tp.μ * x[2] + (p.a * x[1] * x[3] - p.b * x[2]^3 - p.c*(x[3]^2 + x[1]^2) * x[2]),\n\t\tp.μ * x[3] + (p.a * x[1] * x[2] - p.b * x[3]^3 - p.c*(x[2]^2 + x[1]^2) * x[3])]\nend\n\n# model parameters\npard6 = (μ = -0.2, a = 0.3, b = 1.5, c = 2.9)\n\n# problem\nprob = BifurcationProblem(FbpD6, zeros(3), pard6, (@lens _.μ);\n\t\trecord_from_solution = (x, p) -> (n = norminf(x)))\n\n# newton options\nopt_newton = NewtonPar(tol = 1e-9, max_iterations = 20)\n\n# continuation options\nopts_br = ContinuationPar(\n\t# we limit the step size to have smooth branches\n\tdsmax = 0.005, ds = 0.001, \n\t# parameter interval\n\tp_max = 0.4, p_min = -0.25, \n\t# number of eigenvalues to be computed\n\tnev = 3, \n\tnewton_options = opt_newton, \n\tmax_steps = 1000,\n\t# increased precision for bifurcation points\n\tn_inversion = 4, max_bisection_steps = 20)\n\ndiagram = bifurcationdiagram(prob, PALC(), 3,\n\topts_br;\n\tnormC = norminf)","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"We can now plot the result:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"plot(diagram; putspecialptlegend =false, markersize=2, plotfold=false, title=\"#branch = $(size(diagram))\")","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"We can access the different branches with BK.getBranch(diagram, (1,)). Alternatively, you can plot a specific branch:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"(Image: )","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"Finally, you can resume the computation of the bifurcation diagram if not complete by using the syntax","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"BK.bifurcationdiagram!(prob,\n\t# this resume the computation of the diagram from the 2nd node\n\t# diagram is written inplace\n\tget_branch(diagram, (2,)), 6, \n\t(args...) -> opts_br)","category":"page"},{"location":"BifurcationDiagram/#Printing-the-structure-of-the-diagram","page":"Bifurcation diagram","title":"Printing the structure of the diagram","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"It is sometimes useful to have a global representation of the bifurcation diagram. Here, we provide a text representation","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using AbstractTrees\n\nAbstractTrees.children(node::BK.BifDiagNode) = node.child\n\n## Things that make printing prettier\nAbstractTrees.printnode(io::IO, node::BifDiagNode) = print(io, \"$(node.code) [ $(node.level)]\")\n\nprint_tree(diagram)","category":"page"},{"location":"BifurcationDiagram/#Plotting-the-structure-of-the-diagram","page":"Bifurcation diagram","title":"Plotting the structure of the diagram","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"We can also use GraphPlot to plot the tree underlying the bifurcation diagram:","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using LightGraphs, MetaGraphs, GraphPlot\n\nfunction graphFromDiagram!(_graph, diagram, indp)\n\t# ind is the index of the parent node\n\t# add vertex and associated information\n\tadd_vertex!(_graph)\n\tset_props!(_graph, nv(_graph), Dict(:code => diagram.code, :level => diagram.level))\n\tif nv(_graph) > 1\n\t\tadd_edge!(_graph, indp, nv(_graph))\n\tend\n\tif length(diagram.child) > 0\n\t\t# we now run through the children\n\t\tnew_indp = nv(_graph)\n\t\tfor diag in diagram.child\n\t\t\tgraphFromDiagram!(_graph, diag, new_indp)\n\t\tend\n\tend\nend\n\nfunction graphFromDiagram(diagram) \n\t_g = MetaGraph()\n\tgraphFromDiagram!(_g, diagram, 1)\n\treturn _g\nend\n\n_g = graphFromDiagram(bdiag)\n\ngplot(_g, nodelabel = [props(_g, ve)[:code] for ve in vertices(_g)])","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"which gives the following picture. The node label represent the index of the bifurcation point from which the branch branches.","category":"page"},{"location":"BifurcationDiagram/#Using-GraphRecipes","page":"Bifurcation diagram","title":"Using GraphRecipes","text":"","category":"section"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"Another solution is to use GraphRecipes and ","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"using GraphRecipes\n\ngraphplot(_g, \n\tnode_weights = ones(nv(_g)).*10, \n\tnames=[props(_g, ve)[:code] for ve in vertices(_g)], \n\tcurvature_scalar=0.)","category":"page"},{"location":"BifurcationDiagram/","page":"Bifurcation diagram","title":"Bifurcation diagram","text":"","category":"page"},{"location":"periodicOrbitTrapeze/#Periodic-orbits-based-on-Trapezoidal-rule","page":"Trapezoid","title":"Periodic orbits based on Trapezoidal rule","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Pages = [\"periodicOrbitTrapeze.md\"]\nDepth = 3","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"The Trapezoid method allows to compute periodic orbits by discretizing time using Finite Differences based on a trapezoidal rule\t. The method is implemented in the structure PeriodicOrbitTrapProblem. The general method is very well exposed in [Uecker],[Lust] and we adopt the notations of the first reference.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"We look for periodic orbits as solutions (x(0)T) of","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"M_adot x = Tcdot F(x) x(0)=x(1)inmathbb R^ntag1","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"where M_a is a mass matrix (default is the identity one).","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"In order to have a unique solution, we need to remove the phase freedom. This is done by imposing a phase condition","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"frac1Tint_0^Tlangle x(s)-x_pi(s) phi(s)rangle dsapprox frac1msumlimits_i=1^mlangle x_i - x_pii phi_irangle = 0","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"for some x_piphi which are chosen (wisely).","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"We note m the number of time slices of the periodic orbit. By discretizing the above problem, we obtain","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"beginarrayl\n\t\t0= M_aleft(x_j-x_j-1right)-frach2 left(Fleft(x_jright)+Fleft(x_j-1right)right)equiv G_j(x)quad j=1cdotsm-1 \n0= x_m-x_1 equiv G_m(x) \n0=sumlimits_i=1^mlangle x_i - x_pii phi_irangle=0\nendarray","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"where x_0=x_m and h=Tm. In view of the Newton method, we study the jacobian of the above system. The Jacobian w.r.t. (x_0T) is given by","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"mathcalJ=left(beginarrayccA_1  partial_TG  star  dendarrayright)tag2","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"where","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"A_gamma=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1  0 \n-H_2  M_2  0  0  cdots  0  0 \n0  -H_3  M_3  0  cdots  0  0 \nvdots  cdots  ddots  ddots  ddots  vdots  vdots \n0  cdots  cdots  ddots  ddots  0  0 \n0  cdots  cdots  0  -H_m-1  M_m-1  0 \n-gamma I  0  cdots  cdots  cdots  0  I\nendarrayright)","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"with M_i = M_a-\tfrac h2dF(x_i) and H_i = M_a+frac h2dF(x_i-1).","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"We solve the linear equation mathcal Jcdot sol = rhs with a bordering strategy (i.e. the linear solver is a subtype of <: AbstractBorderedLinearSolver) which in turn requires to solve A_gamma z=b where z=(xx_m). We also solve this equation with a bordering strategy but this time, it can be simplified as follows. If we write b=(fg), one gets J_c x=f and x_m=g+gamma x_1 where x_1 is the first time slice of x and J_c is the following cyclic matrix:","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"J_c=left(beginarrayccccccc\nM_1  0  0  0  cdots  -H_1 \n-H_2  M_2  0  0  cdots  0 \n0  -H_3  M_3  0  cdots  0 \nvdots  cdots  ddots  ddots  ddots  vdots \n0  cdots  cdots  ddots  ddots  0 \n0  cdots  cdots  0  -H_m-1  M_m-1 \nendarrayright)","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Our code thus provides methods to invert J_c and A_gamma using a sparse solver or a Matrix-Free one. A preconditioner can be used.","category":"page"},{"location":"periodicOrbitTrapeze/#Encoding-of-the-functional","page":"Trapezoid","title":"Encoding of the functional","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"The functional is encoded in the composite type PeriodicOrbitTrapProblem. See the link for more information, in particular on how to access the underlying functional, its jacobian and other matrices related to it like A_gamma J_c...","category":"page"},{"location":"periodicOrbitTrapeze/#Preconditioning","page":"Trapezoid","title":"Preconditioning","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"We strongly advise you to use a preconditioner to deal with the above linear problem. See 2d Ginzburg-Landau equation (finite differences, codim 2, Hopf aBS) for an example.","category":"page"},{"location":"periodicOrbitTrapeze/#Linear-solvers","page":"Trapezoid","title":"Linear solvers","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"We provide many different linear solvers to take advantage of the formulations. These solvers are available through the argument jacobian in the constructor of PeriodicOrbitTrapProblem. For example, you can pass jacobian  = :FullLU. Note that all the internal solvers and Jacobians are set up automatically, you don't need to do anything. However, for the sake of explanation, we detail how this works.\t","category":"page"},{"location":"periodicOrbitTrapeze/#1.-FullLU","page":"Trapezoid","title":"1. FullLU","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"When using jacobianPO = :FullLU, this triggers the computation of mathcal J as in (2) at each step of newton/continuation. The Jacobian matrix mathcal J is stored a SparseArray. This can be quite costly flow large n (see (1)). This Jacobian is often used with the the linear solver DefaultLS().","category":"page"},{"location":"periodicOrbitTrapeze/#2.-FullSparseInplace","page":"Trapezoid","title":"2. FullSparseInplace","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Same as :FullLU but the Jacobian is allocated only once and updated inplace. This is much faster than :FullLU but the sparsity pattern of dF must be constant.","category":"page"},{"location":"periodicOrbitTrapeze/#3.-Dense","page":"Trapezoid","title":"3. Dense","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Same as : FullSparseInplace above but the matrix dG is dense. It is also updated inplace. This is useful to study ODE of small dimension.","category":"page"},{"location":"periodicOrbitTrapeze/#4.-FullMatrixFree","page":"Trapezoid","title":"4. FullMatrixFree","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"A matrix free linear solver is used for mathcal J: note that a preconditioner is very likely required here because of the cyclic shape of mathcal J which affects negatively the convergence properties of iterative solvers. Note that mathcal J is never formed in this case.","category":"page"},{"location":"periodicOrbitTrapeze/#5.-BorderedLU","page":"Trapezoid","title":"5. BorderedLU","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"For :BorderedLU, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert dG using a bordered linear solver. More precisely, the bordered structure of mathcal J is stored using the internal structure POTrapJacobianBordered. Then, mathcal J is inverted using the custom bordered linear solver PeriodicOrbitTrapBLS which is based on the bordering strategy (see Bordered linear solvers (BLS)). This particular solver is based on an explicit formula which only requires to invert A_gamma: this is done by the linear solver AγLinearSolver. In a nutshell, we have:","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"PeriodicOrbitTrapBLS = BorderingBLS(solver = AγLinearSolver(), check_precision = false)","category":"page"},{"location":"periodicOrbitTrapeze/#6.-BorderedSparseInplace","page":"Trapezoid","title":"6. BorderedSparseInplace","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Same as :BorderedLU but the Jacobian is allocated only once and updated inplace. This is much faster than :BorderedLU but the sparsity pattern of dF must be constant.","category":"page"},{"location":"periodicOrbitTrapeze/#7.-BorderedMatrixFree","page":"Trapezoid","title":"7. BorderedMatrixFree","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"A matrix free linear solver is used but for mathcal J_c only: it means that options.linsolver is used to invert mathcal J_c. ","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"info: Matrix-Free\nThese two Matrix-Free options, :FullMatrixFree and :BorderedMatrixFree, thus expose different part of the Jacobian mathcal J in order to use specific preconditioners. For example, an ILU preconditioner on mathcal J_c could remove the constraints in mathcal J and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely be required.","category":"page"},{"location":"periodicOrbitTrapeze/#Floquet-multipliers-computation","page":"Trapezoid","title":"Floquet multipliers computation","text":"","category":"section"},{"location":"periodicOrbitTrapeze/#Default-method","page":"Trapezoid","title":"Default method","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"A not very precise algorithm for computing the Floquet multipliers is provided in the package. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents because it relies on constructing the monodromy matrix. ","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Note that the computation of the eigenvalues can be iterative or direct based on the eigensolver passed in arguments.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"It amounts to computing the eigenvalues of the monodromy matrix","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"mathcalM=M_1^-1 H_1 M_m-1^-1 H_m-1 cdots M_2^-1 H_2","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"The method allows, nevertheless, to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. For more information, have a look at FloquetQaD.","category":"page"},{"location":"periodicOrbitTrapeze/#Most-precise-method","page":"Trapezoid","title":"Most precise method","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"The state of the art method is based on a Periodic Schur decomposition. It is available through the package PeriodicSchurBifurcationKit.jl. For more information, have a look at FloquetPQZ.","category":"page"},{"location":"periodicOrbitTrapeze/#Computation-with-newton","page":"Trapezoid","title":"Computation with newton","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"We provide a simplified call to newton to locate the periodic orbits. Compared to the regular newton function, there is an additional option linearalgo to select one of the many ways to deal with the above linear problem. The default solver linearalgo is :BorderedLU.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Have a look at the Periodic orbits based on Trapezoidal rule example for the Brusselator for a basic example and at 2d Ginzburg-Landau equation for a more advanced one.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"The docs for this specific newton are located at newton.","category":"page"},{"location":"periodicOrbitTrapeze/#Computation-with-newton-and-deflation","page":"Trapezoid","title":"Computation with newton and deflation","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"We also provide a simplified call to newton to locate the periodic orbit with a deflation operator.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"newton(probPO::PeriodicOrbitTrapProblem,\n\t\torbitguess::vectype,\n\t\tdefOp::DeflationOperator{Tp, Tdot, T, vectype},\n\t\toptions::NewtonPar;\n\t\tkwargs...) where {Tp, Tdot, T, vectype}","category":"page"},{"location":"periodicOrbitTrapeze/#BifurcationKit.newton-Union{Tuple{vectype}, Tuple{T}, Tuple{Tdot}, Tuple{Tp}, Tuple{PeriodicOrbitTrapProblem, vectype, DeflationOperator{Tp, Tdot, T, vectype}, NewtonPar}} where {Tp, Tdot, T, vectype}","page":"Trapezoid","title":"BifurcationKit.newton","text":"newton(probPO, orbitguess, defOp, options; kwargs...)\n\n\nThis function is similar to newton(probPO, orbitguess, options, jacobianPO; kwargs...) except that it uses deflation in order to find periodic orbits different from the ones stored in defOp. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.\n\n\n\n\n\n","category":"method"},{"location":"periodicOrbitTrapeze/#Continuation","page":"Trapezoid","title":"Continuation","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"Have a look at the Periodic orbits based on Trapezoidal rule example for the Brusselator. We refer to continuation for more information regarding the arguments.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"continuation(prob::PeriodicOrbitTrapProblem,\n\t\t\t\torbitguess,\n\t\t\t\talg::BifurcationKit.AbstractContinuationAlgorithm,\n\t\t\t\t_contParams::ContinuationPar;\n\t\t\t\tkwargs...)","category":"page"},{"location":"periodicOrbitTrapeze/#BifurcationKit.continuation-Tuple{PeriodicOrbitTrapProblem, Any, BifurcationKit.AbstractContinuationAlgorithm, ContinuationPar}","page":"Trapezoid","title":"BifurcationKit.continuation","text":"continuation(\n    prob,\n    orbitguess,\n    alg,\n    _contParams;\n    record_from_solution,\n    linear_algo,\n    kwargs...\n)\n\n\nThis is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.\n\nArguments\n\nprob::PeriodicOrbitTrapProblem encodes the functional G\norbitguess a guess for the periodic orbit where orbitguess[end] is an estimate of the period of the orbit. It could be a vector of size N * M + 1 where M is the number of time slices, N is the dimension of the phase space. This must be compatible with the numbers N, M in prob.\nalg continuation algorithm\ncontParams same as for the regular continuation method\n\nKeyword arguments\n\nlinear_algo same as in continuation\n\nSpecify the choice of the jacobian (and linear algorithm), jacobian must belong to [:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]. This is used to select a way of inverting the jacobian dG of the functional G.\n\nFor jacobian = :FullLU, we use the default linear solver based on a sparse matrix representation of dG. This matrix is assembled at each newton iteration. This is the default algorithm.\nFor jacobian = :FullSparseInplace, this is the same as for :FullLU but the sparse matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :FullLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :Dense, same as above but the matrix dG is dense. It is also updated inplace. This option is useful to study ODE of small dimension.\nFor jacobian = :DenseAD, evaluate the jacobian using ForwardDiff\nFor jacobian = :BorderedLU, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert dG using a bordered linear solver.\nFor jacobian = :BorderedSparseInplace, this is the same as for :BorderedLU but the cyclic matrix dG is updated inplace. This method allocates much less. In some cases, this is significantly faster than using :BorderedLU. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.\nFor jacobian = :FullMatrixFree, a matrix free linear solver is used for dG: note that a preconditioner is very likely required here because of the cyclic shape of dG which affects negatively the convergence properties of GMRES.\nFor jacobian = :BorderedMatrixFree, a matrix free linear solver is used but for Jc only (see docs): it means that options.linsolver is used to invert Jc. These two Matrix-Free options thus expose different part of the jacobian dG in order to use specific preconditioners. For example, an ILU preconditioner on Jc could remove the constraints in dG and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.\nFor jacobian = :FullMatrixFreeAD, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.\n\nNote that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your record_from_solution argument.\n\n\n\n\n\n","category":"method"},{"location":"periodicOrbitTrapeze/#References","page":"Trapezoid","title":"References","text":"","category":"section"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"[Uecker]: Uecker, Hannes. Hopf Bifurcation and Time Periodic Orbits with Pde2path – Algorithms and Applications. Communications in Computational Physics 25, no. 3 (2019)","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"[Lust]: Lust, Kurt, Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations, PhD thesis, 1997.","category":"page"},{"location":"periodicOrbitTrapeze/","page":"Trapezoid","title":"Trapezoid","text":"","category":"page"},{"location":"hh/#Normal-form-of-the-Hopf-Hopf-bifurcation","page":"Hopf-Hopf","title":"Normal form of the Hopf-Hopf bifurcation","text":"","category":"section"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"We follow the paper[Kuznetsov],[Kuznetsov2] and consider a Cauchy problem","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"dot x=mathbf F(xp)","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"We denote by mathbf L the jacobian of mathbf F at the bifurcation point (x_0p_0). We choose a basis such that:","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"mathbf L q_1=i omega_1 q_1 quad mathbf L q_2=i omega_2 q_2","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"Under some conditions, x(t)approx x_0+2Re w_1(t)q_1+2Re w_2(t)q_2 where w_i satisfy the normal form:","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"leftbeginaligned\ndotw_1=  i omega_1 w_1+frac12 G_2100 w_1leftw_1right^2+G_1011 w_1leftw_2right^2 \n +frac112 G_3200 w_1leftw_1right^4+frac12 G_2111 w_1leftw_1right^2leftw_2right^2+frac14 G_1022 w_1leftw_2right^4 \n +Oleft(leftleft(w_1 barw_1 w_2 barw_2right)right^6right) \ndotw_2=  i omega_2 w_2+G_1110 w_2leftw_1right^2+frac12 G_0021 w_2leftw_2right^2 +frac14 G_2210 w_2leftw_1right^4+frac12 G_1121 w_2leftw_1right^2leftw_2right^2+frac112 G_0032 w_2leftw_2right^4 \n +Oleft(leftleft(w_1 barw_1 w_2 barw_2right)right^6right)\nendalignedrighttagE","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"This normal form is usually computed in order to branch from a Hopf-Hopf bifurcation point to curves of Neimark-Sacker bifurcations of periodic orbits (see [Kuznetsov2]). Not all coefficients in (E) are required for this branching procedure, that is why only a subset of the G_ijkl is returned.","category":"page"},{"location":"hh/#Normal-form-computation","page":"Hopf-Hopf","title":"Normal form computation","text":"","category":"section"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"The normal form (E) can be automatically computed as follows","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"get_normal_form(br::ContResult, ind_bif::Int ; verbose = false, ζs = nothing, lens = getlens(br))","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"br is a branch computed after a call to continuation with detection of bifurcation points enabled and ind_bif is the index of the bifurcation point on the branch br. The above call returns a point with information needed to compute the bifurcated branch. For more information about the optional parameters, we refer to get_normal_form. The result returns an object of type HopfHopf.","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"info: Note\nYou should not need to call get_normal_form except if you need the full information about the branch point.","category":"page"},{"location":"hh/#Predictors","page":"Hopf-Hopf","title":"Predictors","text":"","category":"section"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the methods","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"BifurcationKit.predictor(hh::BifurcationKit.HopfHopf, ::Val{:HopfCurve}, ds::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"hh/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.HopfHopf, Val{:HopfCurve}, T}} where T","page":"Hopf-Hopf","title":"BifurcationKit.predictor","text":"predictor(hh, , ds; verbose, ampfactor)\n\n\nCompute the predictor for the Hopf curve near the Hopf-Hopf bifurcation point.\n\n\n\n\n\n","category":"method"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"BifurcationKit.predictor(hh::BifurcationKit.HopfHopf, ::Val{:NS}, ϵ::T; verbose = false, ampfactor = T(1)) where T","category":"page"},{"location":"hh/#BifurcationKit.predictor-Union{Tuple{T}, Tuple{BifurcationKit.HopfHopf, Val{:NS}, T}} where T","page":"Hopf-Hopf","title":"BifurcationKit.predictor","text":"predictor(hh, , ϵ; verbose, ampfactor)\n\n\nCompute the predictor for the curve of Neimark-Sacker points near the Hopf-Hopf bifurcation point.\n\nReference\n\nKuznetsov, Yu A., H. G. E. Meijer, W. Govaerts, and B. Sautois. “Switching to Nonhyperbolic Cycles from Codim 2 Bifurcations of Equilibria in ODEs.” Physica D: Nonlinear Phenomena 237, no. 23 (December 2008): 3061–68. https://doi.org/10.1016/j.physd.2008.06.006.\n\n\n\n\n\n","category":"method"},{"location":"hh/#References","page":"Hopf-Hopf","title":"References","text":"","category":"section"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"[Kuznetsov]: Kuznetsov, Yu. A. “Numerical Normalization Techniques for All Codim 2 Bifurcations of Equilibria in ODE’s.” SIAM Journal on Numerical Analysis 36, no. 4 (January 1, 1999): 1104–24. https://doi.org/10.1137/S0036142998335005.","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"[Kuznetsov2]: Kuznetsov, Yu A., H. G. E. Meijer, W. Govaerts, and B. Sautois. “Switching to Nonhyperbolic Cycles from Codim 2 Bifurcations of Equilibria in ODEs.” Physica D: Nonlinear Phenomena 237, no. 23 (December 2008): 3061–68. https://doi.org/10.1016/j.physd.2008.06.006.","category":"page"},{"location":"hh/","page":"Hopf-Hopf","title":"Hopf-Hopf","text":"","category":"page"},{"location":"interfacePred/#Interface-for-Predictor-/-Corrector","page":"Predictor / corrector","title":"Interface for Predictor / Corrector","text":"","category":"section"},{"location":"interfacePred/","page":"Predictor / corrector","title":"Predictor / corrector","text":"Here is a description of the interface that is used to specify predictor / corrector for continuation methods. The type must be a subtype of the abstract type AbstractTangentPredictor.","category":"page"},{"location":"interfacePred/","page":"Predictor / corrector","title":"Predictor / corrector","text":"In the table below, we assume it::AbstractContinuationIterable and M = BorderedArray","category":"page"},{"location":"interfacePred/","page":"Predictor / corrector","title":"Predictor / corrector","text":"Required methods Brief description\ngetPredictor!(z_pred::M, z_old::M, τ::M, ds, pred::AbstractTangentPredictor, nrm = false) Write in z_pred a prediction for the new Newton guess given the current solution z_old, tangent τ and arc length ds.\ngetTangent!(τ::M, z_new::M, z_old::M, it, ds, θ, pred:: AbstractTangentPredictor, verbosity) Generate an estimate of the tangent to the branch of solutions at positions z_new, z_old\ncorrector(it, z_old::M, τ::M, z_pred::M, ds, θ, pred::AbstractTangentPredictor, linearalgo; normC = norm, callback = cbDefault, kwargs...) Correct the guess z_pred. Must return a tuple (sol, residuals, isconverged, it numbers, itlinear)\nOptional methods Brief description\nBase.empty!(pred::AbstractTangentPredictor) Reset the predictor","category":"page"},{"location":"interfacePred/","page":"Predictor / corrector","title":"Predictor / corrector","text":"","category":"page"},{"location":"EventCallback/#Event-Handling","page":"Event handling and Callback","title":"Event Handling","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"BifurcationKit.jl allows the detection of events along the branch of solutions. Its main use consists in detecting bifurcation points but they can be used and combined together by the user too.","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"The events are detected during a call to br = continuation(prob, alg, contParams::ContinuationPar;kwargs...) by turning on the following flag(s):","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"contParams.detect_event = 1","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"The event points are located by looking at the function defining the event (see below). The located event points are then returned in br.specialpoint.","category":"page"},{"location":"EventCallback/#Precise-detection-of-event-points-using-Bisection","page":"Event handling and Callback","title":"Precise detection of event points using Bisection","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"Note that the event points detected when detect_event = 1 are only approximate event points. Indeed, we only signal that, in between two continuation steps which can be large, a (several) event point has been detected. Hence, we only have a rough idea of where the event is located, unless your ContinuationPar().dsmax is very small... This can be improved as follows.","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"If you choose detect_event = 2, a bisection algorithm is used to locate the event points more precisely. It means that we recursively track down the event. Some options in ContinuationPar control this behavior:","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"n_inversion: number of sign inversions in the bisection algorithm\nmax_bisection_steps maximum number of bisection steps\ntol_param_bisection_event tolerance on parameter to locate event","category":"page"},{"location":"EventCallback/#Different-event-types","page":"Event handling and Callback","title":"Different event types","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"The set of possible events DiscreteEvent, ContinuousEvent, SetOfEvents, PairOfEvents is detailed in the Library.","category":"page"},{"location":"EventCallback/#Built-in-events","page":"Event handling and Callback","title":"Built-in events","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"BifurcationKit.SaveAtEvent","category":"page"},{"location":"EventCallback/#BifurcationKit.SaveAtEvent","page":"Event handling and Callback","title":"BifurcationKit.SaveAtEvent","text":"`SaveAtEvent(positions::Tuple)`\n\nThis event implements the detection of when the parameter values, used during continuation, equals one of the values in positions. This state is then saved in the branch.\n\nFor example, you can use it like continuation(args...; event = SaveAtEvent((1., 2., -3.)))\n\n\n\n\n\n","category":"function"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"BifurcationKit.FoldDetectEvent","category":"page"},{"location":"EventCallback/#BifurcationKit.FoldDetectEvent","page":"Event handling and Callback","title":"BifurcationKit.FoldDetectEvent","text":"`FoldDetectEvent`\n\nThis event implements the detection of Fold points based on the p-component of the tangent vector to the continuation curve. It is designed to work with PALC(tangent=Bordered()) as continuation algorithm. To use it, pass event = FoldDetectEvent to continuation.\n\n\n\n\n\n","category":"constant"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"BifurcationKit.BifDetectEvent","category":"page"},{"location":"EventCallback/#BifurcationKit.BifDetectEvent","page":"Event handling and Callback","title":"BifurcationKit.BifDetectEvent","text":"`BifDetectEvent`\n\nThis event implements the detection of bifurcations points along a continuation curve. The detection is based on monitoring the number of unstable eigenvalues. More details are given at Detection of bifurcation points of Equilibria.\n\n\n\n\n\n","category":"constant"},{"location":"EventCallback/#Examples","page":"Event handling and Callback","title":"Examples","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"We show how to use the different events. We first set up a problem as usual.","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"using Revise, BifurcationKit\nusing Plots\nconst BK = BifurcationKit\n####################################################################################################\n# test vector field for event detection\nfunction Feve(X, p)\n\tp1, p2, k = p\n\tx, y = X\n\tout = similar(X)\n\tout[1] = p1 + x - y - x^k/k\n\tout[2] = p1 + y + x - 2y^k/k\n\tout\nend\n\n# parameters for the vector field\npar = (p1 = -3., p2 = -3., k = 3)\n\n# bifurcation problem\nprob = BifurcationProblem(Feve, -2ones(2), par, (@lens _.p1);\n\trecord_from_solution = (x, p) -> x[1])\n\n# parameters for the continuation\nopts = ContinuationPar(max_steps = 150, p_min = -3., p_max = 4.0,\n    # we disable bifurcation detection to focus \n    # on the user passed events\n    detect_bifurcation = 0, detect_fold = false,\n    # parameters specific to event detection\n    detect_event = 2)\n# arguments for continuation\nargs = (prob, PALC(), opts)\nkwargs = (plot = false, verbosity = 0,)\nnothing #hide","category":"page"},{"location":"EventCallback/#Example-of-continuous-event","page":"Event handling and Callback","title":"Example of continuous event","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"In this first example, we build an event to detect when the parameter value is -2 or when the first component of the solution is 1.","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"br = continuation(args...; kwargs...,\n\tevent = BK.ContinuousEvent(2, \n\t\t(iter, state) -> (getp(state)+2, getx(state)[1]-1)),)\nnothing #hide\t\t","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"gives","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"br","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"This shows for example that the first component of the event was detected userC-1 first. This yields","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"plot(br)","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"You can also name the events as follows","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"br = continuation(args...; kwargs...,\n \tevent = BK.ContinuousEvent(2, \n \t\t(iter, state) -> (getp(state)+2, getx(state)[1]-1),\n \t\t(\"event1\", \"event2\")))\nnothing #hide \t\t","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"And get:","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"br","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"plot(br)","category":"page"},{"location":"EventCallback/#Example-of-discrete-event","page":"Event handling and Callback","title":"Example of discrete event","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"You can also use discrete events to detect a change. For example, the following detect when the parameter value equals -2:","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"br = continuation(args...; kwargs...,\n\tevent = BK.DiscreteEvent(1, \n\t\t(iter, state) -> getp(state)>-2))","category":"page"},{"location":"EventCallback/#Example-of-PairOfEvents-event","page":"Event handling and Callback","title":"Example of PairOfEvents event","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"Let us be a bit more creative and combine a continuous event with a discrete one:","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"br = continuation(args...; kwargs...,\n\tevent = BK.PairOfEvents(\n\t\tBK.ContinuousEvent(1, (iter, state) -> getp(state)),\n\t\tBK.DiscreteEvent(1, (iter, state) -> getp(state)>-2)))","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"Here userD-1 means that the first component of the discrete event was detected. Of course, you can name the event like done above.","category":"page"},{"location":"EventCallback/#Example-of-set-of-events","page":"Event handling and Callback","title":"Example of set of events","text":"","category":"section"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"We can combine more events and chain them like we want using SetOfEvents. In this example, we show how to do bifurcation detection and event location altogether:","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"ev1 = BK.ContinuousEvent(1, (iter, state) -> getp(state)-1)\nev2 = BK.ContinuousEvent(2, (iter, state) -> (getp(state)-2, getp(state)-2.5))\n# event to detect bifurcation\nev3 = BK.BifDetectEvent\n# we combine the events together\neve = BK.SetOfEvents(ev1, ev2, ev3)\n\nbr = continuation(args...; kwargs...,\n\t\tevent = eve)","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"Which gives","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"plot(br)","category":"page"},{"location":"EventCallback/","page":"Event handling and Callback","title":"Event handling and Callback","text":"","category":"page"},{"location":"Borderedarrays/#Bordered-Arrays","page":"Bordered arrays","title":"Bordered Arrays","text":"","category":"section"},{"location":"Borderedarrays/","page":"Bordered arrays","title":"Bordered arrays","text":"Here are some informations on a composite type which is used all over the package to hold a couple (array, array) or (array, scalar) while implementing the methods described in Requested methods for Custom State. ","category":"page"},{"location":"Borderedarrays/","page":"Bordered arrays","title":"Bordered arrays","text":"BorderedArray","category":"page"},{"location":"Borderedarrays/#BifurcationKit.BorderedArray","page":"Bordered arrays","title":"BifurcationKit.BorderedArray","text":"mutable struct BorderedArray{vectype1, vectype2}\n\nThis defines an array (although not <: AbstractArray) to hold two arrays or an array and a scalar. This is useful when one wants to add constraints (phase, ...) to a functional for example. It is used throughout the package for the Pseudo Arc Length Continuation, for the continuation of Fold / Hopf points, for periodic orbits... It is also used to define periodic orbits as (orbit, period). As such, it is a convenient alternative to cat, vcat and friends. We chose not to make it a subtype of AbstractArray as we wish to apply the current package to general \"arrays\", see Requested methods for Custom State. Finally, it proves useful for the GPU where the operation x[end] can be slow.\n\n\n\n\n\n","category":"type"},{"location":"Borderedarrays/","page":"Bordered arrays","title":"Bordered arrays","text":"","category":"page"},{"location":"abs-from-eq/#From-equilibria-to-equilibria","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"Pages = [\"abs-from-eq.md\"]\nDepth = 3","category":"page"},{"location":"abs-from-eq/#From-simple-branch-point-to-equilibria","page":"From equilibria to equilibria","title":"From simple branch point to equilibria","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"See Branch switching (branch point) for the precise method definition","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"You can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"continuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar; kwargs...)","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"where br is a branch computed after a call to continuation with detection of bifurcation points enabled. This call computes the branch bifurcating from the ind_bifth bifurcation point in br. An example of use is provided in 2d Bratu–Gelfand problem.","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"See Branch switching (branch point) precise method definition","category":"page"},{"location":"abs-from-eq/#Simple-example:-transcritical-bifurcation","page":"From equilibria to equilibria","title":"Simple example: transcritical bifurcation","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"using BifurcationKit, Plots\n\n# vector field of transcritical bifurcation\nF(x, p) = [x[1] * (p.μ - x[1])]\n\n# parameters of the vector field\npar = (μ = -0.2, )\n\n# problem (automatic differentiation)\nprob = BifurcationProblem(F, [0.], par, (@lens _.μ); record_from_solution = (x, p) -> x[1])\n\n# compute branch of trivial equilibria and detect a bifurcation point\nbr = continuation(prob, PALC(), ContinuationPar())\n\t\n# perform branch switching on both sides of the bifurcation point\nbr1 = continuation(br, 1; bothside = true )\n\nscene = plot(br, br1; branchlabel = [\"br\", \"br1\"], legend = :topleft)","category":"page"},{"location":"abs-from-eq/#Simple-example:-pitchfork-bifurcation","page":"From equilibria to equilibria","title":"Simple example: pitchfork bifurcation","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"using BifurcationKit, Plots\n\n# vector field of pitchfork bifurcation\nF(x, p) = [x[1] * (p.μ - x[1]^2)]\n\n# parameters of the vector field\npar = (μ = -0.2, )\n\n# problem (automatic differentiation)\nprob = BifurcationProblem(F, [0.], par, (@lens _.μ); record_from_solution = (x, p) -> x[1])\n\n# compute branch of trivial equilibria and \n# detect a bifurcation point with improved precision\nbr = continuation(prob, PALC(), ContinuationPar(n_inversion = 6))\n\t\n# perform branch switching on both sides of the bifurcation point\nbr1 = continuation(br, 1; bothside = true )\n\nscene = plot(br, br1; branchlabel = [\"br\", \"br1\"], legend = :topleft)","category":"page"},{"location":"abs-from-eq/#Algorithm","page":"From equilibria to equilibria","title":"Algorithm","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"the normal form is computed and non-trivial zeros are used to produce guesses for points on the bifurcated branch.","category":"page"},{"location":"abs-from-eq/#abs-nonsimple-eq","page":"From equilibria to equilibria","title":"From non simple branch point to equilibria","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"We provide an automatic branch switching method in this case. The underlying method is to first compute the reduced equation (see Non-simple branch point) and its zeros. These zeros are then seeded as initial guess for continuation. Hence, you can perform automatic branch switching by calling continuation with the following options:","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"continuation(br::ContResult, \n\tind_bif::Int,\n\toptionsCont::ContinuationPar;\n\tkwargs...)","category":"page"},{"location":"abs-from-eq/#Examples","page":"From equilibria to equilibria","title":"Examples","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"An example of use is provided in 2d Bratu–Gelfand problem. A much simpler example is given now. It is a bit artificial because the vector field is its own normal form at the bifurcation point located at 0.","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"using BifurcationKit, Plots\n\nfunction FbpD6(x, p)\n    return [p.μ * x[1] + (p.a * x[2] * x[3] - p.b * x[1]^3 - p.c*(x[2]^2 + x[3]^2) * x[1]),\n           p.μ * x[2] + (p.a * x[1] * x[3] - p.b * x[2]^3 - p.c*(x[3]^2 + x[1]^2) * x[2]),\n           p.μ * x[3] + (p.a * x[1] * x[2] - p.b * x[3]^3 - p.c*(x[2]^2 + x[1]^2) * x[3])]\nend\n\n# model parameters\npard6 = (μ = -0.2, a = 0.3, b = 1.5, c = 2.9)\n\n# problem\nprob = BifurcationProblem(FbpD6, zeros(3), pard6, (@lens _.μ);\n\trecord_from_solution = (x, p) -> (n = norminf(x)))\n\n# continuation options\nopts_br = ContinuationPar(dsmin = 0.001, dsmax = 0.02, ds = 0.01, \n\t# parameter interval\n\tp_max = 0.4, p_min = -0.2, \n\tnev = 3, \n\tnewton_options = NewtonPar(tol = 1e-10, max_iterations = 20), \n\tmax_steps = 1000, \n\tn_inversion = 6)\n\nbr = continuation(prob, PALC(), opts_br)","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"You can now branch from the nd point","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"br2 = continuation(br, 1, opts_br; δp = 0.02)\n\nplot(br, br2...)","category":"page"},{"location":"abs-from-eq/#Assisted-branching-from-non-simple-bifurcation-point","page":"From equilibria to equilibria","title":"Assisted branching from non-simple bifurcation point","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"It may happen that the general procedure fails. We thus expose the procedure multicontinuation in order to let the user tune it to its need.","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"The first step is to compute the reduced equation, say of the first bifurcation point in br.","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"bp = get_normal_form(br, 1)","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"Next, we want to find the zeros of the reduced equation. This is usually achieved by calling the predictor","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"δp = 0.005\npred = predictor(bp, δp)","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"which returns zeros of bp before and after the bifurcation point. You could also use your preferred procedure from Roots.jl (or other) to find the zeros of the polynomials bp(Val(:reducedForm), z, p).","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"We can use these zeros to form guesses to apply Newton for the full functional:","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"pts = BifurcationKit.get_first_points_on_branch(br, bp, pred, opts_br; δp)","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"We can then use this to continue the different branches","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"brbp = BifurcationKit.multicontinuation(br, bp, pts.before, pts.after, opts_br)\n\nplot(br, brbp...)","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"Note that you can chose another predictor which uses all vertices of the cube as initial guesses","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"pred = predictor(bp, Val(:exhaustive), δp)\npts = BifurcationKit.get_first_points_on_branch(br, bp, pred, opts_br; δp)","category":"page"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"brbp = BifurcationKit.multicontinuation(br, bp, pts.before, pts.after, opts_br)\n\nplot(br, brbp...)","category":"page"},{"location":"abs-from-eq/#predictors-@docsBifurcationKit.predictor(bp::BifurcationKit.NdBranchPoint,-δp::T;-k...)-where-T@docsBifurcationKit.predictor(bp::BifurcationKit.NdBranchPoint,-algo::Val{:exhaustive},-δp::T;k...)-where-T","page":"From equilibria to equilibria","title":"predictors @docsBifurcationKit.predictor(bp::BifurcationKit.NdBranchPoint, δp::T; k...) where T@docsBifurcationKit.predictor(bp::BifurcationKit.NdBranchPoint, algo::Val{:exhaustive}, δp::T;k...) where T","text":"","category":"section"},{"location":"abs-from-eq/","page":"From equilibria to equilibria","title":"From equilibria to equilibria","text":"","category":"page"},{"location":"linearsolver/#Linear-solvers-(LS)","page":"Linear solvers","title":"Linear solvers (LS)","text":"","category":"section"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"If you provide your own linear solver, it must be a subtype of AbstractLinearSolver otherwise BifurcationKit.jl will not recognize it. See example just below. ","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"The linear solvers provide a way of inverting the Jacobian J or solving J * x = rhs. Such linear solver linsolve will be called like sol, success, itnumber = linsolve(J, rhs; kwargs...) throughout the package.","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"Here is an example of the simplest one (see src/LinearSolver.jl for the true implementation) to give you an idea, the backslash operator:","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"struct DefaultLS <: AbstractLinearSolver end\n\nfunction (l::DefaultLS)(J, rhs; k...)\n\treturn J \\ rhs, true, 1\nend","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"Note that for newton to work, the linear solver must return 3 arguments. The first one is the result, the second one is whether the computation was successful and the third is the number of iterations required to perform the computation.","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"You can then call it as follows (and it will be called like this in newton)","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"ls = DefaultLS()\nJ = rand(2, 2) # example of linear operator\nls(J, rand(2))","category":"page"},{"location":"linearsolver/#List-of-implemented-linear-solvers","page":"Linear solvers","title":"List of implemented linear solvers","text":"","category":"section"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"Default \\ solver based on LU or Cholesky depending on the type of the Jacobian. This works for sparse matrices as well. You can create one via linsolver = DefaultLS().\nGMRES from IterativeSolvers.jl. You can create one via linsolver = GMRESIterativeSolvers() and pass appropriate options.\nGMRES from KrylovKit.jl. You can create one via linsolver = GMRESKrylovKit() and pass appropriate options.","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"tip: Different linear solvers\nBy tuning the options of GMRESKrylovKit, you can select CG, GMRES... see KrylovKit.jl.","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"note: Other solvers\nIt is very straightforward to implement the Conjugate Gradients from IterativeSolvers.jl by copying the interface done for gmres. Same goes for minres,... Not needing them, I did not implement this.","category":"page"},{"location":"linearsolver/#Preconditioner","page":"Linear solvers","title":"Preconditioner","text":"","category":"section"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"Preconditioners should be considered when using Matrix Free methods such as GMRES. GMRESIterativeSolvers provides a very simple interface for using them. For GMRESKrylovKit, we implemented a left preconditioner. Note that, for GMRESKrylovKit, you are not restricted to use Vectors anymore. Finally, here are some packages to use preconditioners","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"IncompleteLU.jl an ILU like preconditioner\nAlgebraicMultigrid.jl Algebraic Multigrid (AMG) preconditioners. This works especially well for symmetric positive definite matrices.\nPreconditioners.jl A convenient interface to conveniently called most of the above preconditioners using a single syntax.\nWe provide a preconditioner based on deflation of eigenvalues (also called preconditioner based on Leading Invariant Subspaces) using a partial Schur decomposition. There are two ways to define one i.e. PrecPartialSchurKrylovKit and PrecPartialSchurArnoldiMethod. ","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"tip: Using Preconditioners\nApart from setting a preconditioner for a linear solver, it can be advantageous to change the preconditioner during computations, e.g. during a call to continuation or newton. This can be achieved by taking advantage of the callbacks to these methods. See the example 2d Ginzburg-Landau equation (finite differences, codim 2, Hopf aBS).","category":"page"},{"location":"linearsolver/","page":"Linear solvers","title":"Linear solvers","text":"","category":"page"},{"location":"waveEigen/#Wave-stability","page":"Eigen Solvers","title":"Wave stability","text":"","category":"section"},{"location":"waveEigen/#References","page":"Eigen Solvers","title":"References","text":"","category":"section"},{"location":"waveEigen/","page":"Eigen Solvers","title":"Eigen Solvers","text":"[Beyn]: Beyn and Thümmler, Phase Conditions, Symmetries and PDE Continuation.","category":"page"},{"location":"waveEigen/","page":"Eigen Solvers","title":"Eigen Solvers","text":"[Sandstede]: Sandstede, Björn. “Stability of Travelling Waves.” In Handbook of Dynamical Systems, 2:983–1055. Elsevier, 2002. https://doi.org/10.1016/S1874-575X(02)80039-X.","category":"page"},{"location":"waveEigen/","page":"Eigen Solvers","title":"Eigen Solvers","text":"","category":"page"},{"location":"FoldContinuationPO/#fold-po","page":"Fold continuation (2 params)","title":"Continuation of Fold of periodic orbits","text":"","category":"section"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"In this page, we explain how to perform continuation of Fold points and detect the associated codim 2 bifurcations.","category":"page"},{"location":"FoldContinuationPO/#List-of-detected-codim-2-bifurcation-points","page":"Fold continuation (2 params)","title":"List of detected codim 2 bifurcation points","text":"","category":"section"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"Bifurcation symbol used Multipliers\nCusp cusp {1,1}\nStrong resonance 1:1 bifurcation R1 {1,1,1}\nFold / Flip foldPD {1,1,-1}\nFold / Neimark-Sacker foldNS {1,1,e^pm ialpha }","category":"page"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"In a nutshell, all you have to do (see below) is to call continuation(br, ind_bif, lens2) to continue the bifurcation point stored in br.specialpoint[ind_bif] and set proper options.","category":"page"},{"location":"FoldContinuationPO/#Fold-continuation","page":"Fold continuation (2 params)","title":"Fold continuation","text":"","category":"section"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"The continuation of Fold bifurcation points is based on a Minimally Augmented[Govaerts] formulation which is an efficient way to detect singularities (see Fold / Hopf Continuation). All the methods (see Periodic orbits computation) for computing periodic orbits are compatible with this algorithm. In particular, you can perform these computations in large dimensions.","category":"page"},{"location":"FoldContinuationPO/#Detection-of-codim-2-bifurcation-points","page":"Fold continuation (2 params)","title":"Detection of codim 2 bifurcation points","text":"","category":"section"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"You can detect the following codim 2 bifurcation points by using the keyword argument detect_codim2_bifurcation in the method continuation ","category":"page"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"the detection of Cusp (Cusp) is done by the detection of Fold bifurcation points along the curve of Folds by monitoring the parameter component of the tangent.\nthe detection the above bifurcation points is done by monitoring the number of eigenvalues lambda such that Relambda  minlimits_nuinSigma(dF)Renu and Imlambda  epsilon where epsilon is the Newton tolerance.","category":"page"},{"location":"FoldContinuationPO/#Setting-the-jacobian","page":"Fold continuation (2 params)","title":"Setting the jacobian","text":"","category":"section"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"In order to apply the newton algorithm to the Fold functional, one needs to invert the jacobian. This is not completely trivial as one must compute this jacobian and then invert it. You can select the following jacobians for your computations (see below):","category":"page"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"[Default] for jacobian_ma = :autodiff, automatic differentiation is applied to the Fold functional and the matrix is then inverted using the provided linear solver. In particular, the jacobian is formed. This is very well suited for small dimensions  (say < 100)\nfor jacobian_ma = :finiteDifferences, same as jacobian_ma = :autodiff but the jacobian is computed using finite differences.\nfor jacobian_ma = :minaug, a specific procedure for evaluating the jacobian and inverting it (without forming the jacobian!) is used. This is well suited for large dimensions.","category":"page"},{"location":"FoldContinuationPO/#Codim-2-continuation","page":"Fold continuation (2 params)","title":"Codim 2 continuation","text":"","category":"section"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"To compute the codim 2 curve of Fold points of periodic orbits, one can call continuation with the following options","category":"page"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":" continuation(br::BifurcationKit.AbstractBranchResult, ind_bif::Int64,\n\t\t\t\tlens2::Lens, options_cont::ContinuationPar = br.contparams ;\n\t\t\t\tkwargs...)","category":"page"},{"location":"FoldContinuationPO/#BifurcationKit.continuation","page":"Fold continuation (2 params)","title":"BifurcationKit.continuation","text":"continuation(br, ind_bif, lens2; ...)\ncontinuation(\n    br,\n    ind_bif,\n    lens2,\n    options_cont;\n    prob,\n    start_with_eigen,\n    detect_codim2_bifurcation,\n    update_minaug_every_step,\n    kwargs...\n)\n\n\nCodimension 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold / Hopf point into a curve of Fold / Hopf points based on a Minimally Augmented formulation. The arguments are as follows\n\nbr results returned after a call to continuation\nind_bif bifurcation index in br\nlens2 second parameter used for the continuation, the first one is the one used to compute br, e.g. getlens(br)\noptions_cont = br.contparams arguments to be passed to the regular continuation\n\nOptional arguments:\n\nbdlinsolver bordered linear solver for the constraint equation\nupdate_minaug_every_step update vectors a, b in Minimally Formulation every update_minaug_every_step steps\nstart_with_eigen = false whether to start the Minimally Augmented problem with information from eigen elements\ndetect_codim2_bifurcation ∈ {0,1,2} whether to detect Bogdanov-Takens, Bautin and Cusp. If equals 1 non precise detection is used. If equals 2, a bisection method is used to locate the bifurcations.\nkwargs keywords arguments to be passed to the regular continuation\n\nwhere the parameters are as above except that you have to pass the branch br from the result of a call to continuation with detection of bifurcations enabled and index is the index of Hopf point in br you want to refine.\n\ntip: ODE problems\nFor ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option bdlinsolver = MatrixBLS()\n\ntip: start_with_eigen\nIt is recommended that you use the option start_with_eigen = true\n\n\n\n\n\n","category":"function"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"where br is a branch of periodic orbits and the options are as above except with have an additional parameter axis lens2 which is used to locate the bifurcation points.","category":"page"},{"location":"FoldContinuationPO/#References","page":"Fold continuation (2 params)","title":"References","text":"","category":"section"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"[Govaerts]: Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.","category":"page"},{"location":"FoldContinuationPO/","page":"Fold continuation (2 params)","title":"Fold continuation (2 params)","text":"","category":"page"},{"location":"ModulatedTW/#Modulated-travelling-wave-(MTW),-N_g1","page":"Modulated Travelling waves","title":"Modulated travelling wave (MTW), N_g=1","text":"","category":"section"},{"location":"ModulatedTW/","page":"Modulated Travelling waves","title":"Modulated Travelling waves","text":"warning: \nThis is work in progress","category":"page"},{"location":"ModulatedTW/","page":"Modulated Travelling waves","title":"Modulated Travelling waves","text":"A modulated travelling wave with period T satisfies q(xt+T) = q(x-s Tt). Equivalently, using a moving frame to freeze the wave xi=x-st, it holds that tilde q(xit+T) = tilde q(xit) where tilde q(xit)=q(xi+stt). Hence, tilde q is a periodic solution to","category":"page"},{"location":"ModulatedTW/","page":"Modulated Travelling waves","title":"Modulated Travelling waves","text":"partial_ttilde q = -sTcdottilde q+F(tilde qp)tageqMWP","category":"page"},{"location":"ModulatedTW/","page":"Modulated Travelling waves","title":"Modulated Travelling waves","text":"Stability of the MTW is determined by the spectrum of the linearized time-T map associated with (eqMWP). ","category":"page"},{"location":"ModulatedTW/#References","page":"Modulated Travelling waves","title":"References","text":"","category":"section"},{"location":"ModulatedTW/","page":"Modulated Travelling waves","title":"Modulated Travelling waves","text":"[Beyn]: Beyn and Thümmler, Phase Conditions, Symmetries and PDE Continuation.","category":"page"},{"location":"ModulatedTW/","page":"Modulated Travelling waves","title":"Modulated Travelling waves","text":"[Sandstede]: Sandstede, Björn. “Stability of Travelling Waves.” In Handbook of Dynamical Systems, 2:983–1055. Elsevier, 2002. https://doi.org/10.1016/S1874-575X(02)80039-X.","category":"page"},{"location":"ModulatedTW/","page":"Modulated Travelling waves","title":"Modulated Travelling waves","text":"","category":"page"},{"location":"plotting/#Plotting","page":"Plot functions","title":"Plotting","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"Pages = [\"plotting.md\"]\nDepth = 3","category":"page"},{"location":"plotting/#Standard-plots-using-the-plot-recipe-from-Plots.jl","page":"Plot functions","title":"Standard plots using the plot recipe from Plots.jl","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"Plotting is provided by calling recipes to Plots.jl. It means that to plot a branch br, you just need to call","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"#]add Plots # You need to install Plots.jl before your first time using it!\nusing Plots\nplot(br)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"where br is a branch computed after a call to br = continuation(...). Plots can be customized using all the keyword arguments provided by Plots.jl. For example, we can change the plotting backend to the GR package and put a title on the plot by doing:","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"gr()\nplot!(br, title = \"I have a branch!\")","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"or you can use a scatter plot","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"scatter(br)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"Then to save the plot, use savefig, for example:","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"savefig(\"myplot.png\")","category":"page"},{"location":"plotting/#Specific-plotting-keyword-arguments","page":"Plot functions","title":"Specific plotting keyword arguments","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"The available arguments specific to our plotting methods are","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"plotfold = true: plot the fold points with black dots\nputspecialptlegend = true: display the legend corresponding to the bifurcation points\nvars = nothing: see below\nplotstability = true: display the stability of the branch\nplotspecialpoints = true: plot the special (bifurcation) points on the branch\nbranchlabel = \"fold branch\": assign label to a branch which is printed in the legend\nlinewidthunstable: set the linewidth for the unstable part of the branch\nlinewidthstable: set the linewidth for the stable part of the branch\nplotcirclesbif = false use circles to plot bifurcation points\napplytoX = identity apply transformation applytoX to x-axis\napplytoY = identity apply transformation applytoY to y-axis","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"If you have several branches br1, br2, you can plot them in the same figure by doing","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"plot(br1, br2)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"in place of","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"plot(br1)\nplot!(br2)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"warn: Plot of bifurcation points\nThe bifurcation points for which the bisection was successful are indicated with circles and with squares otherwise.","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"Note that the plot recipes use the parameter axis as xlabel, and the passed variable as ylabel.","category":"page"},{"location":"plotting/#Choosing-Variables","page":"Plot functions","title":"Choosing Variables","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"You can select which variables to plot using the keyword argument vars, for example:","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"plot(br, vars = (:param, :x))","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"The available symbols are :x, :param, :itnewton, :itlinear, :ds, :θ, :n_unstable, :n_imag, :stable, :step,... and:","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"x if record_from_solution (see continuation) returns a Number.\nx1, x2,... if record_from_solution returns a Tuple.\nthe keys of the NamedTuple returned by record_from_solution.","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"The available symbols are provided by calling propertynames(br.branch).","category":"page"},{"location":"plotting/#Plotting-bifurcation-diagrams","page":"Plot functions","title":"Plotting bifurcation diagrams","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"To do this, you just need to call","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"plot(diagram)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"where diagram is a branch computed after a call to diagram = bifurcationdiagram(...). You can use the keywords provided by Plots.jl and the different backends. You can thus call scatter(diagram). In addition to the options for plotting branches (see above), there are specific arguments available for bifurcation diagrams","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"code specify the part of the bifurcation diagram to plot. For example code = (1,1,) plots the part after the first branch of the first branch of the root branch.\nlevel = (-Inf, Inf) restrict the branching level for plotting.","category":"page"},{"location":"plotting/#Plotting-without-the-plot-recipe","page":"Plot functions","title":"Plotting without the plot recipe","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"What if you don't want to use Plots.jl? You can define your own plotting functions using the internal fields of br which is of type ContResult. For example, in PyPlot, Gadfly, GR, etc., you can do the following to plot the branch (like the plot recipe plot(br, vars = (:param, :x))):","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"plot(br.branch.param, br.branch.x)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"You can also have access to the stability of the points by using br.stable. More information concerning the fields can be found in ContResult. For example, you can change the color depending on the stability:","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"col = [stb ? :green : :red for stb in br.stable]\nplot(br.param, br.x, color=col)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"You can also plot the spectrum at a specific continuation step::Int by calling","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"# get the eigenvalues\neigvals = br.eig[step].eigenvals\n\n# plot them in the complex plane\nscatter(real.(eigvals), imag.(eigvals))","category":"page"},{"location":"plotting/#Standard-plots-using-the-Makie.jl-[Experimental]","page":"Plot functions","title":"Standard plots using the Makie.jl [Experimental]","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"Plotting is also provided by calling recipes to Makie.jl. It means that to plot a branch br, you just need to call","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"#]add GLMakie # You need to install GLMakie.jl before your first time using it!\nusing GLMakie\nBifurcationKit.plot(br)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"The keyword arguments to BifurcationKit.plot are the same as decribed above in the page. You can also combine diagrams with BifurcationKit.plot(br1, br2) or use BifurcationKit.plot!(ax, br) to add a branch to an existing plot.","category":"page"},{"location":"plotting/#Example","page":"Plot functions","title":"Example","text":"","category":"section"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"using Revise, GLMakie, BifurcationKit\nMakie.inline!(true)\nq = 1/0\nk = 2\nF(x, p) = (@. p + x - x^(k+1)/(k+1))\nprob = BifurcationProblem(F, [0.8], 1., (@lens _); record_from_solution = (x,p) -> x[1])\nopts = ContinuationPar(dsmax = 0.1, dsmin = 1e-3, ds = -0.001, p_min = -1., p_max = 1.)\nbr = continuation(prob, PALC(), opts)\nBifurcationKit.plot(br)","category":"page"},{"location":"plotting/","page":"Plot functions","title":"Plot functions","text":"","category":"page"},{"location":"pd/#Period-doubling-point","page":"Period-doubling","title":"Period-doubling point","text":"","category":"section"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"Pages = [\"pd.md\"]\nDepth = 2","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"At a period-doubling (PD) bifurcation of a periodic orbit gamma (with period T) for parameter value p_0 for the Cauchy problem ","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"fracdudt=F(up)tagE","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"the eigenvalues (Floquet coefficients) of the monodromy operator mathcal M=Y(T) solution to","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"fracdYdt=A(t)Y(t) Y(0)=I_n","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"contain the simple eigenvalue mu=-1.","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"There are two ways to compute the normal form of this bifurcation","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"using the Poincaré return map [Kuznetsov]\nusing the method of [Iooss] see also [Kuz2]","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"You can obtain the normal form of a PD bifurcation using ","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"pd = get_normal_form(br, ind; prm = false)","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"where prm indicates whether you want to use the method based on Poincaré return map (PRM) or the one based on Iooss method.","category":"page"},{"location":"pd/#Which-method-to-use?","page":"Period-doubling","title":"Which method to use?","text":"","category":"section"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"Depending on the method used for computing the periodic orbits, you have several possibilities:","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"For shooting, you can only the PRM method. Shooting is the preferred way for large scale systems. Note that the PRM method is not very precise numerically.\nFor collocation, you can use PRM and Iooss methods. Note that the Iooss method is the most precise.\nFor Trapezoid method, PD normal form is not yet implemented.","category":"page"},{"location":"pd/#Predictor","page":"Period-doubling","title":"Predictor","text":"","category":"section"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"The predictor for a non trivial guess at distance delta p from the bifurcation point is provided by the method","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"predictor(hp::BifurcationKit.PeriodDoublingPO{ <: ShootingProblem }, δp, \n                    ampfactor; \n                    override = false)","category":"page"},{"location":"pd/#BifurcationKit.predictor-Tuple{BifurcationKit.PeriodDoublingPO{<:ShootingProblem}, Any, Any}","page":"Period-doubling","title":"BifurcationKit.predictor","text":"predictor(nf, δp, ampfactor; override)\n\n\nCompute the predictor for the period bifurcation of periodic orbit.\n\n\n\n\n\n","category":"method"},{"location":"pd/#Normal-form-based-on-Poincaré-return-map","page":"Period-doubling","title":"Normal form based on Poincaré return map","text":"","category":"section"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"Given a transversal section Sigma to x_0 at x_0(0), the Poincaré return map mathcal P associates to each point xinSigma close to x_0(0) the first point mathcal P(xp)inSigma where the orbit of (E) with initial condition x intersects again Sigma at mathcal P(xp). Hence, the discrete map x_n+1=mathcal P(x_np) has normal form","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"x_n+1 = -x_n+cx_n^3+","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"where [Kuz2]","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"c =frac16leftlangle p^* mathcalC(p p p)+3 mathcalBleft(pleft(I_n-1-mathcalAright)^-1 mathcalB(p p)right)rightrangle","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"where mathcal C=d^3mathcal P(x_0(0)), mathcal B = d^2mathcal P(x_0(0)) and mathcal A = dmathcal P(x_0(0)). Also:","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"mathcalA p=-p mathcalA^mathrmT p^*=-p^*","category":"page"},{"location":"pd/#Normal-form-based-on-Iooss-method","page":"Period-doubling","title":"Normal form based on Iooss method","text":"","category":"section"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"This is based on [Iooss],[Kuz2]. Suppose that the T periodic orbit x_0(tau) has a Period-Doubling bifurcation for a parameter value p_0. Locally, the orbits can be represented by p-p_0=mu and","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"x(tau) = x_0(tau)+xi v(tau)+H(tau xi mu)","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"where ","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"leftbeginarrayl\nfracd taud t=1+a_01cdot(p-p_0)+a_2 xi^2+cdots \nfracd xid tau=c_11cdot(p-p_0)xi+c_3 xi^3+cdots\nendarrayright","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"with center manifold correction H(tau xi mu) being 2T periodic in tau and v(tau) is a Floquet eigenvector for the eigenvalue -1.","category":"page"},{"location":"pd/#References","page":"Period-doubling","title":"References","text":"","category":"section"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"[Kuznetsov]: Yu. A. Kuznetsov, \"Elements of Applied Bifurcation Theory\", 2nd ed., 1998.","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"[Kuz2]: Kuznetsov et al., “Numerical Periodic Normalization for Codim 1 Bifurcations of Limit Cycles.”","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"[Iooss]: Iooss, \"Global Characterization of the Normal Form for a Vector Field near a Closed Orbit.\", 1988","category":"page"},{"location":"pd/","page":"Period-doubling","title":"Period-doubling","text":"","category":"page"},{"location":"MooreSpence/#Moore-Penrose-continuation","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"Pages = [\"MooreSpence.md\"]\nDepth = 3","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"This is one of the various continuation methods implemented in BifurcationKit.jl. It is set by the option alg = MoorePenrose() in continuation. See also MoorePenrose for more information.","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"For solving","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"mathbb R^nni F(xp) = 0 quadtagE","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"using a Newton algorithm, we miss an equation. Hence, we proceed as follows [Meijer]. Starting from a predictor (x_1p_1), we look for the solution to (E) that is closest to (x_1p_1). Hence, we optimise","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"min_(xp)  (xp)-(x_1p_1) text such that  F(xp)=0 tagMS","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"It can be interpreted as a PALC in which the hyperplane is adapted at every step.  ","category":"page"},{"location":"MooreSpence/#Predictor","page":"Moore-Penrose continuation","title":"Predictor","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"The possible predictors tangent::AbstractTangentPredictor are listed in Predictors - Correctors. They can be used to create a Moore-Penrose algorithm  like MoorePenrose(tangent = PALC())","category":"page"},{"location":"MooreSpence/#Corrector","page":"Moore-Penrose continuation","title":"Corrector","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"The corrector is the Gauss Newton algorithm applied to (MS).","category":"page"},{"location":"MooreSpence/#Linear-Algebra","page":"Moore-Penrose continuation","title":"Linear Algebra","text":"","category":"section"},{"location":"MooreSpence/#Norm","page":"Moore-Penrose continuation","title":"Norm","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"The option normC continuation specifies the norm used to evaluate the distance in (MS). The dot product (resp. norm) used in the (iterative) linear solvers is LinearAlgebra.dot (resp. LinearAlgebra.norm). It can be changed by importing these functions and redefining it. Note that by default, the L^2 norm is used.","category":"page"},{"location":"MooreSpence/#Linear-problem","page":"Moore-Penrose continuation","title":"Linear problem","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"The linear solver for the linear problem associated to (MS) is set by the option linear_algo in continuation: it is one of Bordered linear solvers (BLS).","category":"page"},{"location":"MooreSpence/#Algorithm-for-solving-(MS)","page":"Moore-Penrose continuation","title":"Algorithm for solving (MS)","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"Let us write yequiv(xp)inmathbb R^N+1. In order to solve for the argmin, we apply the newton algorithm with jacobian belonging to mathbb R^Ntimes (N+1):","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"y^k+1 = y^k -d_yF(y^k)^+F(y^k)","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"where the superscript ^+ indicates the Moore-Penrose pseudoinverse of rank N.","category":"page"},{"location":"MooreSpence/#Direct-case","page":"Moore-Penrose continuation","title":"Direct case","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"In this case, triggered by the option MoorePenrose(method = BifurcationKit.direct), the pseudoinverse is computed with \\.","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"For the option MoorePenrose(method = BifurcationKit.pInv), the pseudoinverse is computed with pinv.","category":"page"},{"location":"MooreSpence/#Iterative-case","page":"Moore-Penrose continuation","title":"Iterative case","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"In this case, triggered by the option MoorePenrose(method = BifurcationKit.iterative), the pseudoinverse is computed with an iterative method described in [Meijer]:","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"leftbeginarrayl\ny_1^j+1=y_1^j-left(beginarrayc\nF_yleft(y_1^jright) \nleft(phi_1^jright)^top\nendarrayright)^-1left(beginarrayc\nFleft(y_1^jright) \n0\nendarrayright) \nphi_1^j+1=left(beginarrayc\nF_yleft(y_1^j+1right) \nleft(phi_1^jright)^top\nendarrayright)^-1left(beginarrayl\n0 \n1\nendarrayright) quad j=012 ldots\nendarrayright","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"We initialise phi_1^0 with the tangent.","category":"page"},{"location":"MooreSpence/#Step-size-control","page":"Moore-Penrose continuation","title":"Step size control","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"Each time the corrector fails, the step size ds is halved. This has the disadvantage of having lost Newton iterations (which costs time) and imposing small steps (which can be slow as well). To prevent this, the step size is controlled internally with the idea of having a constant number of Newton iterations per point. This is in part controlled by the aggressiveness factor a in ContinuationPar.","category":"page"},{"location":"MooreSpence/#References","page":"Moore-Penrose continuation","title":"References","text":"","category":"section"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"[Meijer]: Meijer, Dercole, and Oldeman, “Numerical Bifurcation Analysis.”","category":"page"},{"location":"MooreSpence/","page":"Moore-Penrose continuation","title":"Moore-Penrose continuation","text":"","category":"page"}]
}
