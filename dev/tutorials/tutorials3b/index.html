<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ğŸŸ  1d Brusselator Â· Bifurcation Analysis in Julia</title><meta name="title" content="ğŸŸ  1d Brusselator Â· Bifurcation Analysis in Julia"/><meta property="og:title" content="ğŸŸ  1d Brusselator Â· Bifurcation Analysis in Julia"/><meta property="twitter:title" content="ğŸŸ  1d Brusselator Â· Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../../educational/">Educational introduction</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../../ANM/">ANM</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../../cusp/">Cusp</a></li><li><a class="tocitem" href="../../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../../bautin/">Bautin</a></li><li><a class="tocitem" href="../../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../../pd/">Period-doubling</a></li><li><a class="tocitem" href="../../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ğŸŸ  1d Brusselator</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ğŸŸ  1d Brusselator</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/tutorials/tutorials3b.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="bruss"><a class="docs-heading-anchor" href="#bruss">ğŸŸ  1d Brusselator</a><a id="bruss-1"></a><a class="docs-heading-anchor-permalink" href="#bruss" title="Permalink"></a></h1><ul><li><a href="#bruss">ğŸŸ  1d Brusselator</a></li><li class="no-marker"><ul><li><a href="#Normal-form-computation">Normal form computation</a></li><li><a href="#Continuation-of-Hopf-points">Continuation of Hopf points</a></li><li><a href="#Continuation-of-periodic-orbits-(Finite-differences)">Continuation of periodic orbits (Finite differences)</a></li><li><a href="#Deflation-for-periodic-orbit-problems">Deflation for periodic orbit problems</a></li><li><a href="#Floquet-coefficients">Floquet coefficients</a></li><li><a href="#Continuation-of-periodic-orbits-(Standard-Shooting)">Continuation of periodic orbits (Standard Shooting)</a></li><li><a href="#Continuation-of-periodic-orbits-(PoincarÃ©-Shooting)">Continuation of periodic orbits (PoincarÃ© Shooting)</a></li><li><a href="#References">References</a></li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">Goal</header><div class="admonition-body"><p>The goal of this tutorial is to show similar computations as in the previous tutorial but without using the automatic branch switching tools. This is for the experienced used who wants to dive more in the internals of the package.    </p></div></div><p>We look at the Brusselator in 1d (see <sup class="footnote-reference"><a id="citeref-Lust" href="#footnote-Lust">[Lust]</a></sup>). The equations are as follows</p><p class="math-container">\[\begin{aligned} \frac { \partial X } { \partial t } &amp; = \frac { D _ { 1 } } { l ^ { 2 } } \frac { \partial ^ { 2 } X } { \partial z ^ { 2 } } + X ^ { 2 } Y - ( Î² + 1 ) X + Î± \\ \frac { \partial Y } { \partial t } &amp; = \frac { D _ { 2 } } { l ^ { 2 } } \frac { \partial ^ { 2 } Y } { \partial z ^ { 2 } } + Î² X - X ^ { 2 } Y \end{aligned}\]</p><p>with Dirichlet boundary conditions</p><p class="math-container">\[\begin{array} { l } { X ( t , z = 0 ) = X ( t , z = 1 ) = Î± } \\ { Y ( t , z = 0 ) = Y ( t , z = 1 ) = Î² / Î± } \end{array}\]</p><p>These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium <span>$(Î±, Î² / Î±)$</span>. Here, we consider bifurcations with respect to the parameter <span>$l$</span>.</p><p>We start by writing the PDE</p><pre><code class="language-julia hljs">using Revise
using BifurcationKit, LinearAlgebra, Plots, SparseArrays
const BK = BifurcationKit

f1(u, v) = u * u * v

function Fbru!(f, x, p, t = 0)
	(;Î±, Î², D1, D2, l) = p
	n = div(length(x), 2)
	h2 = 1.0 / n^2
	c1 = D1 / l^2 / h2
	c2 = D2 / l^2 / h2

	u = @view x[1:n]
	v = @view x[n+1:2n]

	# Dirichlet boundary conditions
	f[1]   = c1 * (Î±	  - 2u[1] + u[2] ) + Î± - (Î² + 1) * u[1] + f1(u[1], v[1])
	f[end] = c2 * (v[n-1] - 2v[n] + Î² / Î±)			 + Î² * u[n] - f1(u[n], v[n])

	f[n]   = c1 * (u[n-1] - 2u[n] +  Î±   ) + Î± - (Î² + 1) * u[n] + f1(u[n], v[n])
	f[n+1] = c2 * (Î² / Î±  - 2v[1] + v[2])			 + Î² * u[1] - f1(u[1], v[1])

	for i=2:n-1
		  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + Î± - (Î² + 1) * u[i] + f1(u[i], v[i])
		f[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])			  + Î² * u[i] - f1(u[i], v[i])
	end
	return f
end

Fbru(x, p, t = 0) = Fbru!(similar(x), x, p, t)</code></pre><p>For computing periodic orbits, we will need a Sparse representation of the Jacobian:</p><pre><code class="language-julia hljs">function Jbru_sp(x, p)
	(;Î±, Î², D1, D2, l) = p
	# compute the Jacobian using a sparse representation
	n = div(length(x), 2)
	ğ’¯ = eltype(x)
	h = 1.0 / n; h2 = h*h

	c1 = D1 / p.l^2 / h2
	c2 = D2 / p.l^2 / h2

	u = @view x[1:n]
	v = @view x[n+1:2n]

	diag   = zeros(ğ’¯, 2n)
	diagp1 = zeros(ğ’¯, 2n-1)
	diagm1 = zeros(ğ’¯, 2n-1)

	diagpn = zeros(ğ’¯, n)
	diagmn = zeros(ğ’¯, n)

	@. diagmn = Î² - 2 * u * v
	@. diagm1[1:n-1] = c1
	@. diagm1[n+1:end] = c2

	@. diag[1:n]    = -2c1 - (Î² + 1) + 2 * u * v
	@. diag[n+1:2n] = -2c2 - u * u

	@. diagp1[1:n-1] = c1
	@. diagp1[n+1:end] = c2

	@. diagpn = u * u
	return spdiagm(0 =&gt; diag, 1 =&gt; diagp1, -1 =&gt; diagm1, n =&gt; diagpn, -n =&gt; diagmn)
end</code></pre><p>We shall now compute the equilibria and their stability.</p><pre><code class="language-julia hljs">n = 500

# parameters of the Brusselator model and guess for the stationary solution
par_bru = (Î± = 2., Î² = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)
sol0 = vcat(par_bru.Î± * ones(n), par_bru.Î² / par_bru.Î± * ones(n))

# bifurcation problem
probBif = BK.BifurcationProblem(Fbru, sol0, par_bru, (@lens _.l);
  J = Jbru_sp,
  plot_solution = (x, p; kwargs...) -&gt; (plotsol(x; label=&quot;&quot;, kwargs... )),
  record_from_solution = (x, p) -&gt; x[div(n,2)])</code></pre><p>For the eigensolver, we use a Shift-Invert algorithm (see <a href="../../eigensolver/#Eigen-solvers-(Eig)">Eigen solvers (Eig)</a>)</p><pre><code class="language-julia hljs">eigls = EigArpack(1.1, :LM)</code></pre><p>We continue the trivial equilibrium to find the Hopf points</p><pre><code class="language-julia hljs">opt_newton = NewtonPar(eigsolver = eigls, tol = 1e-9)
opts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.1,
	p_max = 1.9, nev = 21,
	newton_options = opt_newton, max_steps = 1000,
	# specific options for precise localization of Hopf points
	n_inversion = 6)

br = continuation(probBif, PALC(),opts_br_eq, normC = norminf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> â”Œâ”€ Curve type: <span class="sgr36"><span class="sgr1">EquilibriumCont</span></span>
 â”œâ”€ Number of points: 18
 â”œâ”€ Type of vectors: <span class="sgr36"><span class="sgr1">Vector{Float64}</span></span>
 â”œâ”€ Parameter <span class="sgr36"><span class="sgr1">l</span></span> starts at 0.3, ends at 1.9
 â”œâ”€ Algo: <span class="sgr36"><span class="sgr1">PALC</span></span>
 â””â”€ Special points:

- #  1, <span class="sgr34"><span class="sgr1">    hopf</span></span> at l â‰ˆ +0.51206298 âˆˆ (+0.51199393, +0.51206298), |Î´p|=7e-05, [<span class="sgr32"><span class="sgr1">converged</span></span>], Î´ = ( 2,  2), step =   6
- #  2, <span class="sgr34"><span class="sgr1">    hopf</span></span> at l â‰ˆ +1.02402486 âˆˆ (+1.02388676, +1.02402486), |Î´p|=1e-04, [<span class="sgr32"><span class="sgr1">converged</span></span>], Î´ = ( 2,  2), step =  10
- #  3, <span class="sgr34"><span class="sgr1">    hopf</span></span> at l â‰ˆ +1.53598675 âˆˆ (+1.53584864, +1.53598675), |Î´p|=1e-04, [<span class="sgr32"><span class="sgr1">converged</span></span>], Î´ = ( 2,  2), step =  14
- #  4, <span class="sgr1">endpoint</span> at l â‰ˆ +1.90000000,                                                                     step =  17
</code></pre><p>We obtain the following bifurcation diagram with 3 Hopf bifurcation points</p><pre><code class="language-julia hljs">scene = plot(br)</code></pre><img src="9eec3b65.svg" alt="Example block output"/><h2 id="Normal-form-computation"><a class="docs-heading-anchor" href="#Normal-form-computation">Normal form computation</a><a id="Normal-form-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-form-computation" title="Permalink"></a></h2><p>We can compute the normal form of the Hopf points as follows</p><pre><code class="language-julia hljs">hopfpt = get_normal_form(br, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">SuperCritical - Hopf</span></span> bifurcation point at l â‰ˆ 0.512062980959364.
Frequency Ï‰ â‰ˆ 2.139470722402082
Period of the periodic orbit â‰ˆ 2.9367942460671608
Normal form zâ‹…(iÏ‰ + aâ‹…Î´p + bâ‹…|z|Â²):
â”Œâ”€ a = 0.8785640377699344 + 0.5680594832729724im
â””â”€ b = -0.0009377741298574449 + 0.0009393095359773138im
</code></pre><h2 id="Continuation-of-Hopf-points"><a class="docs-heading-anchor" href="#Continuation-of-Hopf-points">Continuation of Hopf points</a><a id="Continuation-of-Hopf-points-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-Hopf-points" title="Permalink"></a></h2><p>We use the bifurcation points guesses located in <code>br.specialpoint</code> to turn them into precise bifurcation points. For the second one, we have</p><pre><code class="language-julia hljs"># index of the Hopf point in br.specialpoint
ind_hopf = 2

# newton iterations to compute the Hopf point
hopfpoint = newton(br, ind_hopf; normN = norminf)
BK.converged(hopfpoint) &amp;&amp; printstyled(color=:red, &quot;--&gt; We found a Hopf Point at l = &quot;, hopfpoint.u.p[1], &quot;, Ï‰ = &quot;, hopfpoint.u.p[2], &quot;, from l = &quot;, br.specialpoint[ind_hopf].param, &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">--&gt; We found a Hopf Point at l = 1.023985162110299, Ï‰ = -2.1395092625009005, from l = 1.0240248633536086</code></pre><p>We now perform a Hopf continuation with respect to the parameters <code>l, Î²</code></p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><pre><code class="language-julia hljs">optcdim2 = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, p_max = 6.5, p_min = 0.0, newton_options = opt_newton, detect_bifurcation = 0)
br_hopf = continuation(br, ind_hopf, (@lens _.Î²), optcdim2, normC = norminf, jacobian_ma = :minaug)
scene = plot(br_hopf)</code></pre><img src="57db5569.svg" alt="Example block output"/><h2 id="Continuation-of-periodic-orbits-(Finite-differences)"><a class="docs-heading-anchor" href="#Continuation-of-periodic-orbits-(Finite-differences)">Continuation of periodic orbits (Finite differences)</a><a id="Continuation-of-periodic-orbits-(Finite-differences)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-periodic-orbits-(Finite-differences)" title="Permalink"></a></h2><p>Here, we perform continuation of periodic orbits branching from the Hopf bifurcation points.We need an educated guess for the periodic orbit which is given by <code>guess_from_hopf</code>:</p><pre><code class="language-julia hljs"># number of time slices
M = 51

l_hopf, Th, orbitguess2, hopfpt, vec_hopf = BK.guess_from_hopf(br, ind_hopf,
	opts_br_eq.newton_options.eigsolver,
	M, 2.7; phase = 0.25)</code></pre><p>We wish to make two remarks at this point. The first is that an initial guess is composed of a space time solution and of the guess for the period <code>Th</code> of the solution. Note that the argument <code>2.7</code> is a guess for the amplitude of the orbit.</p><pre><code class="language-julia hljs"># orbit initial guess from guess_from_hopf, is not a vector, so we reshape it
orbitguess_f2 = reduce(vcat, orbitguess2)
orbitguess_f = vcat(vec(orbitguess_f2), Th) |&gt; vec</code></pre><p>The second remark concerns the phase <code>0.25</code> written above. To account for the additional unknown (<em>i.e.</em> the period), periodic orbit localization using Finite Differences requires an additional constraint (see <a href="../../periodicOrbitTrapeze/#Periodic-orbits-based-on-Trapezoidal-rule">Periodic orbits based on Trapezoidal rule</a> for more details). In the present case, this constraint is</p><p class="math-container">\[&lt; u(0) - u_{hopf}, \phi&gt; = 0\]</p><p>where <code>u_{hopf}</code> is the equilibrium at the Hopf bifurcation and <span>$\phi$</span> is <code>real.(vec_hopf)</code> where <code>vec_hopf</code> is the eigenvector. This is akin to a PoincarÃ© section. We do not put any constraint on <span>$u(t)$</span> albeit this is possible (see <a href="../../periodicOrbitTrapeze/#Periodic-orbits-based-on-Trapezoidal-rule">Periodic orbits based on Trapezoidal rule</a>.</p><p>The phase of the periodic orbit is set so that the above constraint is satisfied. We shall now use Newton iterations to find a periodic orbit.</p><p>Given our initial guess, we create a (family of) problem which encodes the functional associated to finding Periodic orbits based on Trapezoidal rule (see <a href="../../periodicOrbitTrapeze/#Periodic-orbits-based-on-Trapezoidal-rule">Periodic orbits based on Trapezoidal rule</a> for more information):</p><pre><code class="language-julia hljs">poTrap = PeriodicOrbitTrapProblem(
	probBif,    		   # pass the bifurcation problem
	real.(vec_hopf),	 # used to set Ï•, see the phase constraint
	hopfpt.u,          # used to set uhopf, see the phase constraint
	M, 2n;             # number of time slices
	jacobian = :FullSparseInplace) # jacobian of PO functional

nothing #hide</code></pre><p>To evaluate the functional at <code>x</code>, you call it like a function: <code>poTrap(x, par)</code> for the parameter <code>par</code>.</p><div class="admonition is-info"><header class="admonition-header">Using the functional for deflation, Fold of limit cycles...</header><div class="admonition-body"><p>The functional <code>poTrap</code> gives you access to the underlying methods to call a regular <code>newton</code>. For example the functional is <code>x -&gt; poTrap(x, par)</code> at parameter <code>par</code>. The (sparse) Jacobian at <code>(x,p)</code> is computed like this <code>poTrap(Val(:JacFullSparse), x, p)</code> while the Matrix Free version is <code>dx -&gt; poTrap((x, p, dx)</code>. This also allows you to call the newton deflated method (see <a href="../../deflatedproblem/#Deflated-problems">Deflated problems</a>) or to locate Fold point of limit cycles see <a href="../../library/#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>. You can also use preconditioners. In the case of more computationally intense problems (like the 2d Brusselator), this might be mandatory as using LU decomposition for the linear solve will use too much memory. See also the example <a href="../tutorialsCGL/#cgl">2d Ginzburg-Landau equation (finite differences, codim 2, Hopf aBS)</a></p></div></div><p>For convenience, we provide a simplified newton / continuation methods for periodic orbits. One has just to pass a <a href="../../library/#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>.</p><pre><code class="language-julia hljs"># we use the linear solver LSFromBLS to speed up the computations
opt_po = NewtonPar(tol = 1e-10, verbose = true, max_iterations = 14, linsolver = BK.LSFromBLS())

# we set the parameter values
poTrap = @set poTrap.prob_vf.params = (@set par_bru.l = l_hopf + 0.01)

outpo_f = @time newton(poTrap, orbitguess_f, opt_po, normN = norminf)
BK.converged(outpo_f) &amp;&amp; printstyled(color=:red, &quot;--&gt; T = &quot;, outpo_f.u[end], &quot;, amplitude = &quot;, BK.amplitude(outpo_f.u, n, M; ratio = 2),&quot;\n&quot;)
# plot of the periodic orbit
BK.plot_periodic_potrap(outpo_f.u, n, M; ratio = 2)</code></pre><img src="000b2a7c.svg" alt="Example block output"/><p>Finally, we can perform continuation of this periodic orbit using the specialized call <code>continuationPOTrap</code></p><pre><code class="language-julia hljs">opt_po = @set opt_po.eigsolver = EigArpack(; tol = 1e-5, v0 = rand(2n))
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.03, ds= 0.01,
	p_max = 3.0, max_steps = 20,
	newton_options = opt_po, nev = 5, tol_stability = 1e-8, detect_bifurcation = 0)

br_po = continuation(poTrap,
	outpo_f.u, PALC(),
	opts_po_cont;
	verbosity = 2,	plot = true,
	plot_solution = (x, p;kwargs...) -&gt; heatmap!(reshape(x[1:end-1], 2*n, M)&#39;; ylabel=&quot;time&quot;, color=:viridis, kwargs...),
	normC = norminf)

Scene = title!(&quot;&quot;)</code></pre><img src="fd48a67c.svg" alt="Example block output"/><h2 id="Deflation-for-periodic-orbit-problems"><a class="docs-heading-anchor" href="#Deflation-for-periodic-orbit-problems">Deflation for periodic orbit problems</a><a id="Deflation-for-periodic-orbit-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Deflation-for-periodic-orbit-problems" title="Permalink"></a></h2><p>Looking for periodic orbits branching of bifurcation points, it is very useful to use <code>newton</code> algorithm with deflation. We thus define a deflation operator (see previous example)</p><pre><code class="language-julia hljs">deflationOp = DeflationOperator(2, (x,y) -&gt; dot(x[1:end-1], y[1:end-1]), 1.0, [zero(orbitguess_f)])</code></pre><p>which allows to find periodic orbits different from <code>orbitguess_f</code>. Note that the <code>dot</code> product removes the last component, <em>i.e.</em> the period of the cycle is not considered during this particular deflation. We can now use</p><pre><code class="language-julia hljs">outpo_f = @time newton(poTrap, orbitguess_f, deflationOp, opt_po; normN = norminf)</code></pre><h2 id="Floquet-coefficients"><a class="docs-heading-anchor" href="#Floquet-coefficients">Floquet coefficients</a><a id="Floquet-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Floquet-coefficients" title="Permalink"></a></h2><p>A basic method for computing Floquet coefficients based on the eigenvalues of the monodromy operator is available (see <a href="../../library/#BifurcationKit.FloquetQaD"><code>FloquetQaD</code></a>). It is precise enough to locate bifurcations. Their computation is triggered like in the case of a regular call to <code>continuation</code>:</p><pre><code class="language-julia hljs">opt_po = @set opt_po.eigsolver = DefaultEig()
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.04, ds= -0.01, p_max = 3.0, max_steps = 200, newton_options = opt_po, nev = 5, tol_stability = 1e-6)
br_po = @time continuation(poTrap, outpo_f.u, PALC(),
	opts_po_cont; verbosity = 3, plot = true,
	plot_solution = (x, p;kwargs...) -&gt; heatmap!(reshape(x[1:end-1], 2*n, M)&#39;; ylabel=&quot;time&quot;, color=:viridis, kwargs...), normC = norminf)</code></pre><p>A more complete diagram can be obtained combining the methods (essentially deflation and Floquet) described above. It shows the period of the periodic orbits as function of <code>l</code>. See <code>example/brusselator.jl</code> for more information.</p><p><img src="../bru-po-cont-3br.png" alt/></p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set when the computation of Floquet multipliers is requested.</p></div></div><div class="admonition is-success"><header class="admonition-header">Performances</header><div class="admonition-body"><p>This example is clearly not optimized because we wanted to keep it simple. We can use a Matrix-Free version of the functional and preconditioners to speed this up. Floquet multipliers could also be computed in a Matrix-Free manner. See <code>examples/brusselator.jl</code> for more efficient methods. See also <a href="../tutorialsCGL/#cgl">2d Ginzburg-Landau equation (finite differences, codim 2, Hopf aBS)</a> for a more advanced example where we introduce those methods.</p></div></div><h2 id="Continuation-of-periodic-orbits-(Standard-Shooting)"><a class="docs-heading-anchor" href="#Continuation-of-periodic-orbits-(Standard-Shooting)">Continuation of periodic orbits (Standard Shooting)</a><a id="Continuation-of-periodic-orbits-(Standard-Shooting)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-periodic-orbits-(Standard-Shooting)" title="Permalink"></a></h2><blockquote><p>Note that what follows is not really optimized on the <code>DifferentialEquations.jl</code> side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern,...</p></blockquote><p>We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field <code>Fbru</code>. We will show how to do this with an implicit method <code>Rodas4P</code> from <code>DifferentialEquations.jl</code>. Note that the user can pass its own time stepper but for convenience, we use the ones in <code>DifferentialEquations.jl</code>. More information regarding the shooting method is contained in <a href="../../periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method">Periodic orbits based on the shooting method</a>.</p><pre><code class="language-julia hljs">n = 100

# different parameters to define the Brusselator model and guess for the stationary solution
par_bru = (Î± = 2., Î² = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)
sol0 = vcat(par_bru.Î± * ones(n), par_bru.Î²/par_bru.Î± * ones(n))
probBif = re_make(probBif, u0 = sol0)

eigls = EigArpack(1.1, :LM)
opts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.00615, ds = 0.0061, p_max = 1.9,
	detect_bifurcation = 3, nev = 21, plot_every_step = 50,
	newton_options = NewtonPar(eigsolver = eigls, tol = 1e-9), max_steps = 1060)

br = @time continuation(probBif, PALC(), opts_br_eq, normC = norminf)</code></pre><p>We need to create a guess for the periodic orbit. We proceed as previously:</p><pre><code class="language-julia hljs"># number of time slices
M = 5

# index of the Hopf point in the branch br
ind_hopf = 1

l_hopf, Th, orbitguess2, hopfpt, vec_hopf = BK.guess_from_hopf(br, ind_hopf,
	opts_br_eq.newton_options.eigsolver, M, 22*0.075)
#
orbitguess_f2 = reduce(hcat, orbitguess2)
orbitguess_f = vcat(vec(orbitguess_f2), Th) |&gt; vec</code></pre><p>Let us now initiate the Standard Shooting method. To this aim, we need to provide a guess of the periodic orbit at times <span>$T/M_{sh}$</span> where <span>$T$</span> is the period of the cycle and <span>$M_{sh}$</span> is the number of slices along the periodic orbits. If <span>$M_{sh} = 1$</span>, this the Standard Simple Shooting and the Standard Multiple one otherwise. See <a href="../../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> for more information.</p><pre><code class="language-julia hljs">dM = 2
orbitsection = Array(orbitguess_f2[:, 1:dM:M])

# the last component is an estimate of the period of the cycle.
initpo = vcat(vec(orbitsection), 3.0)</code></pre><p>Finally, we need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper. For performance reasons, we rely on <code>SparseDiffTools</code></p><pre><code class="language-julia hljs">using DifferentialEquations, SparseDiffTools, SparseArrays

FOde(f, x, p, t) = Fbru!(f, x, p)

u0 = sol0 .+ 0.01 .* rand(2n)

# parameter close to the Hopf bifurcation point
par_hopf = (@set par_bru.l = l_hopf + 0.01)

jac_prototype = Jbru_sp(ones(2n), @set par_bru.Î² = 0)
jac_prototype.nzval .= ones(length(jac_prototype.nzval))
_colors = matrix_colors(jac_prototype)
vf = ODEFunction(FOde; jac_prototype = jac_prototype, colorvec = _colors)
prob = ODEProblem(vf,  sol0, (0.0, 520.), par_bru)</code></pre><p>We create the parallel standard shooting problem:</p><pre><code class="language-julia hljs"># this encodes the functional for the Shooting problem
probSh = ShootingProblem(
	# we pass the ODEProblem encoding the flow and the time stepper
	prob, Rodas4P(),

	# this is for the phase condition, you can pass your own section as well
	[orbitguess_f2[:,ii] for ii=1:dM:M];

	# enable threading
	parallel = true,

	# these are options passed to the ODE time stepper
	abstol = 1e-10, reltol = 1e-8,

  # parameter axis
  lens = (@lens _.l),

  # parameters
  par = par_hopf,

  # jacobian of the periodic orbit functional
  jacobian = BK.FiniteDifferencesMF())</code></pre><p>We are now ready to call <code>newton</code></p><pre><code class="language-julia hljs">ls = GMRESIterativeSolvers(reltol = 1e-7, N = length(initpo), maxiter = 100)
optn_po = NewtonPar(verbose = true, tol = 1e-9,  max_iterations = 20, linsolver = ls)
outpo = @time newton(probSh, initpo, optn_po; normN = norminf)
plot(initpo[1:end-1], label = &quot;Init guess&quot;)
plot!(outpo.u[1:end-1], label = &quot;sol&quot;)</code></pre><p>which gives (note that we did not have a really nice guess...)</p><pre><code class="language-julia hljs">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Newton step         residual      linear iterations â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       0     â”‚       2.6239e-01     â”‚        0       â”‚
â”‚       1     â”‚       8.8979e-03     â”‚       27       â”‚
â”‚       2     â”‚       9.6221e-04     â”‚       28       â”‚
â”‚       3     â”‚       5.0540e-02     â”‚       31       â”‚
â”‚       4     â”‚       3.4149e-03     â”‚       28       â”‚
â”‚       5     â”‚       1.1336e+00     â”‚       31       â”‚
â”‚       6     â”‚       9.5418e-02     â”‚       25       â”‚
â”‚       7     â”‚       1.1996e-02     â”‚       28       â”‚
â”‚       8     â”‚       1.2655e-02     â”‚       28       â”‚
â”‚       9     â”‚       3.8820e-03     â”‚       30       â”‚
â”‚      10     â”‚       4.1901e-04     â”‚       31       â”‚
â”‚      11     â”‚       5.4309e-06     â”‚       31       â”‚
â”‚      12     â”‚       1.1430e-09     â”‚       33       â”‚
â”‚      13     â”‚       5.2525e-14     â”‚       34       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  3.396345 seconds (5.38 M allocations: 17.675 GiB, 1.66% gc time)</code></pre><p>and</p><p><img src="../brus-sh-new.png" alt/></p><p>Note that using Simple Shooting, the convergence is much faster. Indeed, running the code above with <code>dM = 10</code> gives:</p><pre><code class="language-julia hljs">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Newton step         residual     linear iterations  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       0     â”‚       6.1712e-03     â”‚        0       â”‚
â”‚       1     â”‚       3.4465e-03     â”‚        6       â”‚
â”‚       2     â”‚       1.0516e-01     â”‚        8       â”‚
â”‚       3     â”‚       7.4614e-03     â”‚        6       â”‚
â”‚       4     â”‚       1.6620e-03     â”‚        7       â”‚
â”‚       5     â”‚       3.9589e-04     â”‚        7       â”‚
â”‚       6     â”‚       4.3043e-05     â”‚        8       â”‚
â”‚       7     â”‚       1.7232e-06     â”‚        8       â”‚
â”‚       8     â”‚       8.0455e-09     â”‚        8       â”‚
â”‚       9     â”‚       3.9453e-11     â”‚        8       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  0.612070 seconds (217.21 k allocations: 523.069 MiB, 4.83% gc time)</code></pre><div class="admonition is-info"><header class="admonition-header">Convergence and speedup</header><div class="admonition-body"><p>The convergence is much worse for the multiple shooting than for the simple one. This is reflected above in the number of linear iterations made during the newton solve. The reason for this is because of the cyclic structure of the jacobian which impedes GMRES from converging fast. This can only be resolved with an improved GMRES which we&#39;ll provide in the future.</p></div></div><p>Finally, we can perform continuation of this periodic orbit using a specialized version of <code>continuation</code>:</p><pre><code class="language-julia hljs"># note the eigensolver computes the eigenvalues of the monodromy matrix. Hence
# the dimension of the state space for the eigensolver is 2n
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, p_max = 1.5,
	max_steps = 500, newton_options = (@set optn_po.tol = 1e-7), nev = 25,
	tol_stability = 1e-8, detect_bifurcation = 0)

br_po = @time continuation(probSh, outpo.u, PALC(),
	opts_po_cont; verbosity = 2,
	# specific bordered linear solver
	linear_algo = MatrixFreeBLS(@set ls.N = ls.N+1),
	plot = true,
	plot_solution = (x, p; kwargs...) -&gt; BK.plot_periodic_shooting!(x[1:end-1], length(1:dM:M); kwargs...),
	record_from_solution = (u, p) -&gt; u[end], 
	normC = norminf)</code></pre><p>We can observe that simple shooting is faster but the Floquet multipliers are less accurate than for multiple shooting. Also, when the solution is very unstable, simple shooting can have spurious branch switching. Finally, note the <span>$0=\log 1$</span> eigenvalue of the monodromy matrix in the graph below.</p><p><img src="../brus-sh-cont.png" alt/></p><h2 id="Continuation-of-periodic-orbits-(PoincarÃ©-Shooting)"><a class="docs-heading-anchor" href="#Continuation-of-periodic-orbits-(PoincarÃ©-Shooting)">Continuation of periodic orbits (PoincarÃ© Shooting)</a><a id="Continuation-of-periodic-orbits-(PoincarÃ©-Shooting)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-periodic-orbits-(PoincarÃ©-Shooting)" title="Permalink"></a></h2><p>We now turn to another Shooting method, namely the PoincarÃ© one. We can provide this method thanks to the unique functionalities of <code>DifferentialEquations.jl</code>. More information is provided at <a href="../../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> and <a href="../../periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method">Periodic orbits based on the shooting method</a> but basically, it is a shooting method between PoincarÃ© sections <span>$\Sigma_i$</span> (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is <span>$M_{sh}\cdot(N-1)$</span> where <span>$N$</span> is the dimension of the phase space. Indeed, each time slice lives in an hyperplane <span>$\Sigma_i$</span>. Additionally, the period <span>$T$</span> is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane <span>$\Sigma_i$</span>, something called <strong>event detection</strong>.</p><p>We show how to use this method, the code is very similar to the case of the Standard Shooting. We first define the functional for PoincarÃ© Shooting Problem</p><pre><code class="language-julia hljs"># sub-sampling factor of a initial guess for the periodic orbit
dM = 5

# vectors to define the hyperplanes Sigma_i
normals = [Fbru(orbitguess_f2[:,ii], par_hopf)/(norm(Fbru(orbitguess_f2[:,ii], par_hopf))) for ii = 1:dM:M]
centers = [orbitguess_f2[:,ii] for ii = 1:dM:M]

# functional to hold the Poincare Shooting Problem
probHPsh = PoincareShootingProblem(
	# ODEProblem, ODE solver used to compute the flow
	prob, Rodas4P(),

	# parameters for the PoincarÃ© sections
	normals, centers;

	# enable threading
	parallel = true,

	# Parameters passed to the ODE solver
	abstol = 1e-10, reltol = 1e-8,

  # parameter axis
  lens = (@lens _.l),

  # parameters
  par = par_hopf,

  # jacobian of the periodic orbit functional
  jacobian = BK.FiniteDifferencesMF())</code></pre><p>Let us now compute an initial guess for the periodic orbit, it must live in the hyperplanes <span>$\Sigma_i$</span>. Fortunately, we provide projections on these hyperplanes.</p><pre><code class="language-julia hljs"># projection of the initial guess on the hyperplanes. We assume that the centers[ii]
# form the periodic orbit initial guess.
initpo_bar = reduce(vcat, BK.projection(probHPsh, centers))</code></pre><p>We can now call <code>continuation</code> to get the first branch.</p><pre><code class="language-julia hljs"># eigen / linear solver
eig = EigKrylovKit(tol= 1e-12, xâ‚€ = rand(2n-1), dim = 40)
ls = GMRESIterativeSolvers(reltol = 1e-11, N = length(vec(initpo_bar)), maxiter = 500)

# newton options
optn = NewtonPar(verbose = true, tol = 1e-9,  max_iterations = 140, linsolver = ls)

# continuation options
opts_po_cont_floquet = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.001,
	p_max = 2.5, max_steps = 500, nev = 10,
	tol_stability = 1e-5, detect_bifurcation = 3, plot_every_step = 3)
opts_po_cont_floquet = @set opts_po_cont_floquet.newton_options =
	NewtonPar(linsolver = ls, eigsolver = eig, tol = 1e-9, verbose = true)

# continuation run
br_po = @time continuation(probHPsh, vec(initpo_bar), PALC(),
	opts_po_cont_floquet; verbosity = 3,
	linear_algo = MatrixFreeBLS(@set ls.N = ls.N+1),
	plot = true,
	plot_solution = (x, p; kwargs...) -&gt; BK.plot!(x; label=&quot;&quot;, kwargs...),
	normC = norminf)		</code></pre><p><img src="../brus-psh-cont.png" alt/></p><p>We also obtain the following information:</p><pre><code class="language-julia hljs">julia&gt; br_po
Branch number of points: 41
Bifurcation points:
- #  1,    bp at p â‰ˆ 1.20987963 âˆˆ (1.20128196, 1.20987963), |Î´p|=9e-03, [converged], Î´ = ( 1,  0), step =  21, eigenelements in eig[ 22], ind_ev =   1
- #  2,    ns at p â‰ˆ 1.78687615 âˆˆ (1.77831727, 1.78687615), |Î´p|=9e-03, [converged], Î´ = ( 2,  2), step =  30, eigenelements in eig[ 31], ind_ev =   3
- #  3,    pd at p â‰ˆ 1.85103701 âˆˆ (1.84676466, 1.85103701), |Î´p|=4e-03, [converged], Î´ = ( 1,  1), step =  31, eigenelements in eig[ 32], ind_ev =   4
- #  4,    ns at p â‰ˆ 1.87667870 âˆˆ (1.86813520, 1.87667870), |Î´p|=9e-03, [converged], Î´ = ( 2,  2), step =  32, eigenelements in eig[ 33], ind_ev =   6</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Lust"><a class="tag is-link" href="#citeref-Lust">Lust</a><blockquote><p><strong>Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations,</strong> Lust, 1997.</p></blockquote></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 12 July 2024 20:21">Friday 12 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
