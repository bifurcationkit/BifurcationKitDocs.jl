<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>🟡 1d Brusselator (automatic) · Bifurcation Analysis in Julia</title><meta name="title" content="🟡 1d Brusselator (automatic) · Bifurcation Analysis in Julia"/><meta property="og:title" content="🟡 1d Brusselator (automatic) · Bifurcation Analysis in Julia"/><meta property="twitter:title" content="🟡 1d Brusselator (automatic) · Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../../educational/">Educational introduction</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../../hybrid/">AutoSwitch</a></li><li><a class="tocitem" href="../../ANM/">ANM</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../../cusp/">Cusp</a></li><li><a class="tocitem" href="../../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../../bautin/">Bautin</a></li><li><a class="tocitem" href="../../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../../pd/">Period-doubling</a></li><li><a class="tocitem" href="../../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>🟡 1d Brusselator (automatic)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>🟡 1d Brusselator (automatic)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/tutorials/tutorials3.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="brusauto"><a class="docs-heading-anchor" href="#brusauto">🟡 1d Brusselator (automatic)</a><a id="brusauto-1"></a><a class="docs-heading-anchor-permalink" href="#brusauto" title="Permalink"></a></h1><ul><li><a href="#brusauto">🟡 1d Brusselator (automatic)</a></li><li class="no-marker"><ul><li><a href="#Normal-form-computation">Normal form computation</a></li><li><a href="#Continuation-of-Hopf-points">Continuation of Hopf points</a></li><li><a href="#Computation-of-the-branch-of-periodic-orbits-(Finite-differences)">Computation of the branch of periodic orbits (Finite differences)</a></li><li><a href="#Computation-of-the-branch-of-periodic-orbits-(Standard-Shooting)">Computation of the branch of periodic orbits (Standard Shooting)</a></li><li><a href="#Computation-of-the-branch-of-periodic-orbits-(Poincaré-Shooting)">Computation of the branch of periodic orbits (Poincaré Shooting)</a></li><li><a href="#References">References</a></li></ul></li></ul><p>We look at the Brusselator in 1d (see <sup class="footnote-reference"><a id="citeref-Lust" href="#footnote-Lust">[Lust]</a></sup>). The equations are</p><p class="math-container">\[\begin{aligned} \frac { \partial X } { \partial t } &amp; = \frac { D _ { 1 } } { l ^ { 2 } } \frac { \partial ^ { 2 } X } { \partial z ^ { 2 } } + X ^ { 2 } Y - ( β + 1 ) X + α \\ \frac { \partial Y } { \partial t } &amp; = \frac { D _ { 2 } } { l ^ { 2 } } \frac { \partial ^ { 2 } Y } { \partial z ^ { 2 } } + β X - X ^ { 2 } Y \end{aligned}\]</p><p>with Dirichlet boundary conditions</p><p class="math-container">\[\begin{array} { l } { X ( t , z = 0 ) = X ( t , z = 1 ) = α } \\ { Y ( t , z = 0 ) = Y ( t , z = 1 ) = β / α. } \end{array}\]</p><p>These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium <span>$(α, β / α)$</span>. Here, we consider bifurcations with respect to the parameter <span>$l$</span>.</p><p>We start by writing the PDE</p><pre><code class="language-julia hljs">using Revise
using BifurcationKit, Plots, SparseArrays
const BK = BifurcationKit

f1(u, v) = u * u * v

function Fbru!(f, x, p, t = 0)
	(;α, β, D1, D2, l) = p
	n = div(length(x), 2)
	h2 = 1.0 / n^2
	c1 = D1 / l^2 / h2
	c2 = D2 / l^2 / h2

	u = @view x[1:n]
	v = @view x[n+1:2n]

	# Dirichlet boundary conditions
	f[1]   = c1 * (α	  - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])
	f[end] = c2 * (v[n-1] - 2v[n] + β / α)			 + β * u[n] - f1(u[n], v[n])

	f[n]   = c1 * (u[n-1] - 2u[n] +  α   ) + α - (β + 1) * u[n] + f1(u[n], v[n])
	f[n+1] = c2 * (β / α  - 2v[1] + v[2])			 + β * u[1] - f1(u[1], v[1])

	for i=2:n-1
		  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])
		f[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])			  + β * u[i] - f1(u[i], v[i])
	end
	return f
end

Fbru(x, p, t = 0) = Fbru!(similar(x), x, p, t)</code></pre><p>We use a sparse representation of the jacobian:</p><pre><code class="language-julia hljs">function Jbru_sp(x, p)
	(;α, β, D1, D2, l) = p
	# compute the Jacobian using a sparse representation
	n = div(length(x), 2)
	h = 1.0 / n; h2 = h*h

	c1 = D1 / p.l^2 / h2
	c2 = D2 / p.l^2 / h2

	u = @view x[1:n]
	v = @view x[n+1:2n]

	diag   = zeros(eltype(x), 2n)
	diagp1 = zeros(eltype(x), 2n-1)
	diagm1 = zeros(eltype(x), 2n-1)

	diagpn = zeros(eltype(x), n)
	diagmn = zeros(eltype(x), n)

	@. diagmn = β - 2 * u * v
	@. diagm1[1:n-1] = c1
	@. diagm1[n+1:end] = c2

	@. diag[1:n]    = -2c1 - (β + 1) + 2 * u * v
	@. diag[n+1:2n] = -2c2 - u * u

	@. diagp1[1:n-1] = c1
	@. diagp1[n+1:end] = c2

	@. diagpn = u * u
	return spdiagm(0 =&gt; diag, 1 =&gt; diagp1, -1 =&gt; diagm1, n =&gt; diagpn, -n =&gt; diagmn)
end</code></pre><p>We shall now compute the equilibria and their stability.</p><pre><code class="language-julia hljs">n = 300

# parameters of the Brusselator model and guess for the stationary solution
par_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)
sol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))

# bifurcation problem
probBif = BK.BifurcationProblem(Fbru, sol0, par_bru, (@optic _.l);
  J = Jbru_sp,
  plot_solution = (x, p; kwargs...) -&gt; (plotsol(x; label=&quot;&quot;, kwargs... )),
  record_from_solution = (x, p; k...) -&gt; x[div(n,2)])</code></pre><p>For the eigensolver, we use a Shift-Invert algorithm (see <a href="../../eigensolver/#Eigen-solvers-(Eig)">Eigen solvers (Eig)</a>) even though for this discretization size, the default eigensolver <code>DefaultEig</code> would suffice.</p><pre><code class="language-julia hljs">eigls = EigArpack(1.1, :LM)</code></pre><p>We continue the trivial equilibrium to find the Hopf points</p><pre><code class="language-julia hljs">opt_newton = NewtonPar(eigsolver = eigls, tol = 1e-9)
opts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds = 0.001,
	p_max = 1.9, nev = 21,
	newton_options = opt_newton, max_steps = 1000,
	# specific options for precise localization of Hopf points
	n_inversion = 6)

br = continuation(probBif, PALC(), opts_br_eq, normC = norminf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> ┌─ Curve type: <span class="sgr36"><span class="sgr1">EquilibriumCont</span></span>
 ├─ Number of points: 120
 ├─ Type of vectors: <span class="sgr36"><span class="sgr1">Vector{Float64}</span></span>
 ├─ Parameter <span class="sgr36"><span class="sgr1">l</span></span> starts at 0.3, ends at 1.9
 ├─ Algo: <span class="sgr36"><span class="sgr1">PALC</span></span>
 └─ Special points:

- #  1, <span class="sgr34"><span class="sgr1">    hopf</span></span> at l ≈ +0.51133101 ∈ (+0.51130339, +0.51133101), |δp|=3e-05, [<span class="sgr32"><span class="sgr1">converged</span></span>], δ = ( 2,  2), step =  19
- #  2, <span class="sgr34"><span class="sgr1">    hopf</span></span> at l ≈ +1.02261272 ∈ (+1.02260927, +1.02261272), |δp|=3e-06, [<span class="sgr32"><span class="sgr1">converged</span></span>], δ = ( 2,  2), step =  56
- #  3, <span class="sgr34"><span class="sgr1">    hopf</span></span> at l ≈ +1.53388407 ∈ (+1.53388364, +1.53388407), |δp|=4e-07, [<span class="sgr31"><span class="sgr1">   guessL</span></span>], δ = ( 2,  2), step =  93
- #  4, <span class="sgr1">endpoint</span> at l ≈ +1.90000000,                                                                     step = 119
</code></pre><p>We obtain the following branch with 3 Hopf bifurcation points</p><pre><code class="language-julia hljs">scene = plot(br)</code></pre><img src="5f2997ef.svg" alt="Example block output"/><h2 id="Normal-form-computation"><a class="docs-heading-anchor" href="#Normal-form-computation">Normal form computation</a><a id="Normal-form-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-form-computation" title="Permalink"></a></h2><p>We can compute the normal form of the Hopf points as follows</p><pre><code class="language-julia hljs">hopfpt = get_normal_form(br, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">SuperCritical - Hopf</span></span> bifurcation point at l ≈ 0.5113310149554013.
Frequency ω ≈ 2.1394991675560107
Period of the periodic orbit ≈ 2.9367552006841793
Normal form z⋅(iω + a⋅δp + b⋅|z|²):
┌─ a = 0.8799946552796951 + 0.5689776417277187im
└─ b = -0.001560810290147428 + 0.001563481097008653im
</code></pre><h2 id="Continuation-of-Hopf-points"><a class="docs-heading-anchor" href="#Continuation-of-Hopf-points">Continuation of Hopf points</a><a id="Continuation-of-Hopf-points-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-Hopf-points" title="Permalink"></a></h2><p>We use the guesses of the bifurcation points located in <code>br.specialpoint</code> to turn them into precise bifurcation points. For the second one, we have</p><pre><code class="language-julia hljs"># index of the Hopf point in br.specialpoint
ind_hopf = 2

# newton iterations to compute the Hopf point
hopfpoint = newton(br, ind_hopf; normN = norminf)
BK.converged(hopfpoint) &amp;&amp; printstyled(color=:red, &quot;--&gt; We found a Hopf Point at l = &quot;, hopfpoint.u.p[1], &quot;, ω = &quot;, hopfpoint.u.p[2], &quot;, from l = &quot;, br.specialpoint[ind_hopf].param, &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">--&gt; We found a Hopf Point at l = 1.0226125272271145, ω = -2.13950928953339, from l = 1.022612721393132</code></pre><p>We now perform a Hopf continuation with respect to the parameters <code>l, β</code></p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><pre><code class="language-julia hljs">optcdim2 = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, p_max = 6.5, p_min = 0.0, newton_options = opt_newton, detect_bifurcation = 0)

br_hopf = continuation(br, ind_hopf, (@optic _.β),
	optcdim2, verbosity = 2,
	# detection of codim 2 bifurcations with bisection
	detect_codim2_bifurcation = 2,
	# we update the Hopf problem at every continuation step
	update_minaug_every_step = 1,
	jacobian_ma = :minaug, # specific to large dimensions
	normC = norminf)

scene = plot(br_hopf)</code></pre><img src="f619aacb.svg" alt="Example block output"/><h2 id="Computation-of-the-branch-of-periodic-orbits-(Finite-differences)"><a class="docs-heading-anchor" href="#Computation-of-the-branch-of-periodic-orbits-(Finite-differences)">Computation of the branch of periodic orbits (Finite differences)</a><a id="Computation-of-the-branch-of-periodic-orbits-(Finite-differences)-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-of-the-branch-of-periodic-orbits-(Finite-differences)" title="Permalink"></a></h2><p>We now compute the bifurcated branches of periodic solutions from the Hopf points using <a href="../../periodicOrbitTrapeze/#Periodic-orbits-based-on-Trapezoidal-rule">Periodic orbits based on Trapezoidal rule</a>. One has just to pass a <a href="../../library/#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>.</p><p>We start by providing a linear solver and some options for the continuation to work</p><pre><code class="language-julia hljs"># automatic branch switching from Hopf point
opt_po = NewtonPar(tol = 1e-10, verbose = true, max_iterations = 15)
opts_po_cont = ContinuationPar(dsmin = 0.001,
		dsmax = 0.04, ds = 0.01,
		p_max = 2.2,
		max_steps = 30,
		newton_options = opt_po,
		plot_every_step = 1,
		nev = 11,
		tol_stability = 1e-6,
		)</code></pre><pre><code class="language-julia hljs"># number of time slices for the periodic orbit
M = 51
probFD = PeriodicOrbitTrapProblem(M = M;
  # specific method for solving the linear system for newton
  # of periodic orbits with trapeze method.
  # We could use the default one :FullLU (slower here)
  jacobian = :BorderedSparseInplace)

br_po = continuation(
	# arguments for branch switching from the first
	# Hopf bifurcation point
	br, 1,
	# arguments for continuation
	opts_po_cont, probFD;
	# regular options for continuation
	verbosity = 3, plot = true,
	plot_solution = (x, p; kwargs...) -&gt; heatmap!(reshape(x[1:end-1], 2*n, M)&#39;; ylabel=&quot;time&quot;, color=:viridis, kwargs...),
	normC = norminf)

Scene = title!(&quot;&quot;)</code></pre><img src="98318479.svg" alt="Example block output"/><p>Using the above call, it is very easy to find the first branches:</p><p><img src="../bru-po-cont-3br0.png" alt/></p><p>We note that there are several branch points (blue points) on the above diagram. This means that there are additional branches in the neighborhood of these points. We now turn to automatic branch switching on these branches.</p><p>Let&#39;s say that we want to branch from the first branch point of the first curve pink branch. The syntax is very similar to the previous one:</p><pre><code class="language-julia hljs">br_po2 = continuation(
	# arguments for branch switching
	br_po, 1,
	# arguments for continuation
	opts_po_cont;
	ampfactor = 1., δp = 0.01,
	verbosity = 3, plot = true,
	plot_solution = (x, p; kwargs...) -&gt; heatmap!(reshape(x[1:end-1], 2*n, M)&#39;; ylabel=&quot;time&quot;, color=:viridis, kwargs...),
	normC = norminf)</code></pre><p>It is now straightforward to get the following diagram</p><p><img src="../bru-po-cont-3br.png" alt/></p><h2 id="Computation-of-the-branch-of-periodic-orbits-(Standard-Shooting)"><a class="docs-heading-anchor" href="#Computation-of-the-branch-of-periodic-orbits-(Standard-Shooting)">Computation of the branch of periodic orbits (Standard Shooting)</a><a id="Computation-of-the-branch-of-periodic-orbits-(Standard-Shooting)-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-of-the-branch-of-periodic-orbits-(Standard-Shooting)" title="Permalink"></a></h2><blockquote><p>Note that what follows is not really optimized on the <code>DifferentialEquations.jl</code> side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern, ...</p></blockquote><p>We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field <code>Fbru</code>. We show how to do this with an implicit method <code>Rodas4P</code> from <code>DifferentialEquations.jl</code>. Note that the user can pass its own time stepper but for convenience, we use the ones in <code>DifferentialEquations.jl</code>. More information regarding the shooting method is contained in <a href="../../periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method">Periodic orbits based on the shooting method</a>.</p><p>We then recompute the locus of the Hopf bifurcation points using the same method as above.</p><pre><code class="language-julia hljs">n = 100

# different parameters to define the Brusselator model and guess for the stationary solution
par_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)
sol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))
probBif = re_make(probBif, u0 = sol0)

eigls = EigArpack(1.1, :LM)
opts_br_eq = ContinuationPar(dsmin = 0.001,
		dsmax = 0.00615, ds = 0.0061,
		p_max = 1.9,
		nev = 21,
		plot_every_step = 50,
		newton_options = NewtonPar(eigsolver = eigls,
			tol = 1e-9), max_steps = 200)

br = continuation(probBif, PALC(), opts_br_eq, normC = norminf)</code></pre><p>We need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq

FOde(f, x, p, t) = Fbru!(f, x, p, t)

u0 = sol0 .+ 0.01 .* rand(2n)

# we pass our jacobian function to increase performances
# an inplace jacobian would be favoured
vf = ODEFunction(FOde, jac = (J,u,p,t) -&gt; J .= Jbru_sp(u, p), jac_prototype = Jbru_sp(u0, par_bru))

# this is the ODE time stepper when used with `solve`
prob_ode = ODEProblem(vf, u0, (0., 1000.), par_bru; abstol = 1e-10, reltol = 1e-8)</code></pre><div class="admonition is-success"><header class="admonition-header">Performance</header><div class="admonition-body"><p>You can really speed this up by using the improved <code>ODEProblem</code></p><pre><code class="language-julia hljs">using SparseDiffTools, SparseArrays
jac_prototype = Jbru_sp(ones(2n), par_bru)
jac_prototype.nzval .= ones(length(jac_prototype.nzval))
_colors = matrix_colors(jac_prototype)
vf = ODEFunction(FOde; jac_prototype = jac_prototype, colorvec = _colors)
prob_ode = ODEProblem(vf,  u0, (0.0, 520.), par_bru) # gives 0.22s</code></pre></div></div><p>We are now ready to call the automatic branch switching. Note how similar it is to the previous section based on finite differences. This case is more deeply studied in the tutorial <a href="@ref">1d Brusselator (advanced user)</a>.</p><pre><code class="language-julia hljs"># linear solvers
ls = GMRESIterativeSolvers(reltol = 1e-7, maxiter = 100)
eig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n), dim = 40)
# newton parameters
optn_po = NewtonPar(verbose = true, 
	tol = 1e-7,
	linsolver = ls,
	eigsolver = eig)
# continuation parameters
opts_po_cont = ContinuationPar(dsmax = 0.03, ds= 0.01, p_max = 2.5, max_steps = 10,
	newton_options = optn_po, nev = 15, tol_stability = 1e-3,
	plot_every_step = 2)

Mt = 2 # number of shooting sections
br_po = continuation(
	br, 1,
	# arguments for continuation
	opts_po_cont,
	# this is where we tell that we want Parallel Standard Shooting
	ShootingProblem(Mt, prob_ode, Rodas4P(), parallel = true, jacobian = BK.FiniteDifferencesMF());
	# the next option is not necessary
	# it speeds up the newton iterations
	# by combining the linear solves of the bordered linear system
	linear_algo = MatrixFreeBLS(@set ls.N = 2+2n*Mt),
	verbosity = 3,	plot = true,
	plot_solution = (x, p; kwargs...) -&gt; BK.plot_periodic_shooting!(x[1:end-1], Mt; kwargs...),
	normC = norminf)</code></pre><p>and you should see</p><p><img src="../brus-sh-cont.png" alt/></p><h2 id="Computation-of-the-branch-of-periodic-orbits-(Poincaré-Shooting)"><a class="docs-heading-anchor" href="#Computation-of-the-branch-of-periodic-orbits-(Poincaré-Shooting)">Computation of the branch of periodic orbits (Poincaré Shooting)</a><a id="Computation-of-the-branch-of-periodic-orbits-(Poincaré-Shooting)-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-of-the-branch-of-periodic-orbits-(Poincaré-Shooting)" title="Permalink"></a></h2><p>We now turn to another Shooting method, namely the Poincaré one. We can provide this method thanks to the unique functionalities of <code>DifferentialEquations.jl</code>. More information is provided at <a href="../../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> and <a href="../../periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method">Periodic orbits based on the shooting method</a> but basically, it is a shooting method between Poincaré sections <span>$\Sigma_i$</span> (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is <span>$M_{sh}\cdot(N-1)$</span> where <span>$N$</span> is the dimension of the phase space. Indeed, each time slice lives in an hyperplane <span>$\Sigma_i$</span>. Additionally, the period <span>$T$</span> is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane <span>$\Sigma_i$</span>, something called <strong>event detection</strong>.</p><p>We show how to use this method, the code is very similar to the case of the Parallel Standard Shooting:</p><pre><code class="language-julia hljs"># linear solvers
ls = GMRESIterativeSolvers(reltol = 1e-8, maxiter = 100)
eig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n-1), dim = 50)
# newton parameters
optn_po = NewtonPar(verbose = true, 
	tol = 1e-7,
	linsolver = ls,
	eigsolver = eig)
# continuation parameters
opts_po_cont = ContinuationPar(dsmax = 0.03, ds = 0.005, p_max = 2.5, newton_options = optn_po, nev = 10, tol_stability = 1e-5, plot_every_step = 2)

# number of time slices
Mt = 2
br_po = continuation(
	br, 1,
	# arguments for continuation
	opts_po_cont,
	PoincareShootingProblem(Mt, prob_ode, Rodas4P(); jacobian = BK.FiniteDifferencesMF(), update_section_every_step = 0);
	# the next option is not necessary
	# it speeds up the newton iterations
	# by combining the linear solves of the bordered linear system
	linear_algo = MatrixFreeBLS(@set ls.N = (2n-1)*Mt+1),
	verbosity = 3, plot = true,
	plot_solution = (x, p; kwargs...) -&gt; BK.plot_periodic_shooting!(x[1:end-1], Mt; kwargs...),
	normC = norminf)</code></pre><p>and you should see:</p><p><img src="../brus-psh-cont.png" alt/></p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Lust"><a class="tag is-link" href="#citeref-Lust">Lust</a><blockquote><p><strong>Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations,</strong> Lust, 1997.</p></blockquote></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Saturday 8 March 2025 14:26">Saturday 8 March 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
