<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>üü° 2d Swift-Hohenberg equation: snaking, finite differences ¬∑ Bifurcation Analysis in Julia</title><meta name="title" content="üü° 2d Swift-Hohenberg equation: snaking, finite differences ¬∑ Bifurcation Analysis in Julia"/><meta property="og:title" content="üü° 2d Swift-Hohenberg equation: snaking, finite differences ¬∑ Bifurcation Analysis in Julia"/><meta property="twitter:title" content="üü° 2d Swift-Hohenberg equation: snaking, finite differences ¬∑ Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../../educational/">Educational introduction</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../../waveEigen/">Eigen Solvers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../../hybrid/">AutoSwitch</a></li><li><a class="tocitem" href="../../ANM/">ANM</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../../cusp/">Cusp</a></li><li><a class="tocitem" href="../../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../../bautin/">Bautin</a></li><li><a class="tocitem" href="../../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../../pd/">Period-doubling</a></li><li><a class="tocitem" href="../../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../../BifurcationDiagram/">Automatic Bifurcation diagram</a></li><li><a class="tocitem" href="../../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../../debug/">Debugging</a></li><li><a class="tocitem" href="../../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>üü° 2d Swift-Hohenberg equation: snaking, finite differences</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>üü° 2d Swift-Hohenberg equation: snaking, finite differences</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/tutorials/tutorials2.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sh2dfd"><a class="docs-heading-anchor" href="#sh2dfd">üü° 2d Swift-Hohenberg equation: snaking, finite differences</a><a id="sh2dfd-1"></a><a class="docs-heading-anchor-permalink" href="#sh2dfd" title="Permalink"></a></h1><ul><li><a href="#sh2dfd">üü° 2d Swift-Hohenberg equation: snaking, finite differences</a></li><li class="no-marker"><ul><li><a href="#Continuation-and-bifurcation-points">Continuation and bifurcation points</a></li><li><a href="#Snaking-computed-with-deflation">Snaking computed with deflation</a></li><li><a href="#Automatic-branch-switching">Automatic branch switching</a></li></ul></li></ul><p>We study the following PDE</p><p class="math-container">\[-(I+\Delta)^2 u+l\cdot u +\nu u^2-u^3 = 0\]</p><p>with Neumann boundary conditions. The full example is in the file <code>example/SH2d-fronts.jl</code>. This example is also treated in the MATLAB package <a href="http://www.staff.uni-oldenburg.de/hannes.uecker/pde2path/">pde2path</a>. We use a Sparse Matrix to express the operator <span>$L_1=(I+\Delta)^2$</span>.</p><pre><code class="language-julia hljs">using BifurcationKit, Plots, SparseArrays
import LinearAlgebra: I, norm
const BK = BifurcationKit

# helper function to plot solution
heatmapsol(x) = heatmap(reshape(x,Nx,Ny)&#39;,color=:viridis)
heatmapsol!(x; k...) = heatmap!(reshape(x,Nx,Ny)&#39;;color=:viridis, k...)

Nx = 151
Ny = 100
lx = 4*2pi
ly = 2*2pi/sqrt(3)

function Laplacian2D(Nx, Ny, lx, ly)
    hx = 2lx/Nx
    hy = 2ly/Ny
    D2x = spdiagm(0 =&gt; -2ones(Nx), 1 =&gt; ones(Nx-1), -1 =&gt; ones(Nx-1) ) / hx^2
    D2y = spdiagm(0 =&gt; -2ones(Ny), 1 =&gt; ones(Ny-1), -1 =&gt; ones(Ny-1) ) / hy^2

    D2x[1,1] = -1/hx^2
    D2x[end,end] = -1/hx^2

    D2y[1,1] = -1/hy^2
    D2y[end,end] = -1/hy^2

    D2xsp = sparse(D2x)
    D2ysp = sparse(D2y)
    A = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))
    return A, D2x
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Laplacian2D (generic function with 1 method)</code></pre><p>We also write the functional and its Jacobian which is a Sparse Matrix</p><pre><code class="language-julia hljs">function F_sh(u, p)
	(;l, ŒΩ, L1) = p
	return -L1 * u .+ (l .* u .+ ŒΩ .* u.^2 .- u.^3)
end

function dF_sh(u, p)
	(;l, ŒΩ, L1) = p
	return -L1 .+ spdiagm(0 =&gt; l .+ 2 .* ŒΩ .* u .- 3 .* u.^2)
end

# we compute the differentials
d2F_sh(u, p, dx1, dx2) = (2 .* p.ŒΩ .* dx2 .- 6 .* dx2 .* u) .* dx1
d3F_sh(u, p, dx1, dx2, dx3) = (-6 .* dx2 .* dx3) .* dx1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">d3F_sh (generic function with 1 method)</code></pre><p>We first look for hexagonal patterns. This is done with</p><pre><code class="language-julia hljs">X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)
Y = -ly .+ 2ly/(Ny) * collect(0:Ny-1)

# initial guess for hexagons
sol0 = [(cos(x) + cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]
sol0 .= sol0 .- minimum(vec(sol0))
sol0 ./= maximum(vec(sol0))
sol0 = sol0 .- 0.25
sol0 .*= 1.7

# define parameters for the PDE
Œî, = Laplacian2D(Nx, Ny, lx, ly);
L1 = (I + Œî)^2;
par = (l = -0.1, ŒΩ = 1.3, L1);

# Bifurcation Problem
prob = BifurcationProblem(F_sh, vec(sol0), par, (@optic _.l);
		J = dF_sh,
		plot_solution = (x, p; kwargs...) -&gt; (heatmapsol!(x; label=&quot;&quot;, kwargs...)),
		record_from_solution = (x, p; k...) -&gt; (n2 = norm(x), n8 = norm(x, 8)),
		issymmetric = true,
		d2F = d2F_sh,
		d3F = d3F_sh)

# newton corrections of the initial guess
optnewton = NewtonPar(verbose = true, tol = 1e-8, max_iterations = 20)
sol_hexa = @time BK.solve(prob, Newton(), optnewton)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NonLinearSolution{Vector{Float64}, BifurcationProblem{BifFunction{typeof(Main.F_sh), BifurcationKit.var&quot;#115#117&quot;{typeof(Main.F_sh)}, Nothing, Nothing, typeof(Main.dF_sh), Nothing, Nothing, typeof(Main.d2F_sh), Nothing, typeof(Main.d3F_sh), Nothing, Float64, Nothing}, Vector{Float64}, @NamedTuple{l::Float64, ŒΩ::Float64, L1::SparseArrays.SparseMatrixCSC{Float64, Int64}}, PropertyLens{:l}, Main.var&quot;#4#8&quot;, Main.var&quot;#6#9&quot;, typeof(BifurcationKit.save_solution_default), typeof(BifurcationKit.update_default)}, Vector{Float64}, Int64}([-0.2676318368347582, -0.2819508046473875, -0.3079031271710653, -0.3404220279478643, -0.37258926897029726, -0.39627026641081653, -0.40276114666498797, -0.3834475080895921, -0.3305880458892222, -0.23838085795816594  ‚Ä¶  -0.2383808575779124, -0.33058804569095807, -0.38344750802749616, -0.4027611466887988, -0.39627026647430436, -0.37258926903687656, -0.34042202799366617, -0.3079031271858182, -0.28195080463331473, -0.26763183680366787], ‚îå‚îÄ Bifurcation Problem with uType <span class="sgr36"><span class="sgr1">Vector{Float64}</span></span>
‚îú‚îÄ Inplace: <span class="sgr36"><span class="sgr1">false</span></span>
‚îú‚îÄ Dimension: <span class="sgr36"><span class="sgr1">15100</span></span>
‚îú‚îÄ Symmetric: <span class="sgr36"><span class="sgr1">true</span></span>
‚îî‚îÄ Parameter: <span class="sgr36"><span class="sgr1">l</span></span>, [173.91081387402477, 5046.503242335292, 1487.8453969712814, 435.2934599419263, 125.59783690139939, 35.51195898336262, 9.544668266513503, 2.176338430851776, 0.33503137281104206, 0.07725874815447939, 0.0074767271919087405, 7.950459535048754e-5, 8.841342345772113e-9], true, 12, 12)</code></pre><p>with <code>sol_hexa</code> being</p><pre><code class="language-julia hljs">heatmapsol(sol_hexa.u)</code></pre><img src="bc94994c.svg" alt="Example block output"/><h2 id="Continuation-and-bifurcation-points"><a class="docs-heading-anchor" href="#Continuation-and-bifurcation-points">Continuation and bifurcation points</a><a id="Continuation-and-bifurcation-points-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-and-bifurcation-points" title="Permalink"></a></h2><p>We can now continue this solution as follows. We want to detect bifurcations along the branches. We thus need an eigensolver. However, if we use an iterative eigensolver, like <code>eig = EigArpack()</code>, it has trouble computing the eigenvalues. One can see that using</p><pre><code class="language-julia hljs"># compute the jacobian
J0 = dF_sh(sol_hexa.u, par);</code></pre><p>The reason is that the jacobian operator is not very well conditioned unlike its inverse. We thus opt for the <em>shift-invert</em> method (see <a href="../../eigensolver/#Eigen-solvers-(Eig)">Eigen solvers (Eig)</a> for more information) with shift <code>0.1</code>:</p><pre><code class="language-julia hljs">eig = EigArpack(0.1, :LM)

# compute 10 eigenvalues
eig(J0, 10)</code></pre><p>If we want to compute the bifurcation points along the branches, we have to tell the solver by setting <code>detect_bifurcation = 2</code>. However, this won&#39;t be very precise and each bifurcation point will be located at best at the step size precision. We can use bisection to locate this points more precisely using the option <code>detect_bifurcation = 3</code> (see <a href="../../detectionBifurcation/#Detection-of-bifurcation-points-of-Equilibria">Detection of bifurcation points of Equilibria</a> for more information).</p><p>We are now ready to compute the branches:</p><pre><code class="language-julia hljs">optcont = ContinuationPar(p_max = 0.0, p_min = -1.0,
	dsmin = 0.0001, dsmax = 0.005, ds= -0.001, 
	newton_options = setproperties(optnewton; tol = 1e-9,
	eigsolver = EigArpack(0.1, :LM)),
	nev = 40)

br = continuation(
	re_make(prob, u0 = sol_hexa.u), PALC(), optcont;
	plot = true,
	normC = norminf)</code></pre><p>Note that we can get some information about the branch as follows. The <code>[converged]</code> indicates if the bisection routine was successful, otherwise it shows <code>[guess]</code>. Finally <code>Œ¥ = ( 2,  0)</code> says that the bifurcation point has been detected by 2 new eigenvalues with zero real part among which zero have non zero imaginary part. A Hopf bifurcation point would thus have <code>Œ¥ = ( 2,  2)</code> or <code>Œ¥ = ( -2,  2)</code>.</p><pre><code class="language-julia hljs">julia&gt; br
 ‚îå‚îÄ Curve type: EquilibriumCont
 ‚îú‚îÄ Number of points: 98
 ‚îú‚îÄ Type of vectors: Vector{Float64}
 ‚îú‚îÄ Parameter l starts at -0.1, ends at 0.0
 ‚îú‚îÄ Algo: PALC
 ‚îî‚îÄ Special points:

If `br` is the name of the branch,
ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`

- #  1,       bp at l ‚âà -0.21554729 ‚àà (-0.21554729, -0.21554481), |Œ¥p|=2e-06, [converged], Œ¥ = ( 1,  0), step =  35, eigenelements in eig[ 36], ind_ev =   1
- #  2,       bp at l ‚âà -0.21551019 ‚àà (-0.21551494, -0.21551019), |Œ¥p|=5e-06, [converged], Œ¥ = ( 1,  0), step =  36, eigenelements in eig[ 37], ind_ev =   2
- #  3,       bp at l ‚âà -0.21498022 ‚àà (-0.21505410, -0.21498022), |Œ¥p|=7e-05, [converged], Œ¥ = ( 1,  0), step =  38, eigenelements in eig[ 39], ind_ev =   3
- #  4,       bp at l ‚âà -0.21287212 ‚àà (-0.21295316, -0.21287212), |Œ¥p|=8e-05, [converged], Œ¥ = ( 1,  0), step =  41, eigenelements in eig[ 42], ind_ev =   4
- #  5,       bp at l ‚âà -0.20989694 ‚àà (-0.21012690, -0.20989694), |Œ¥p|=2e-04, [converged], Œ¥ = ( 1,  0), step =  43, eigenelements in eig[ 44], ind_ev =   6
- #  6,       bp at l ‚âà -0.20683673 ‚àà (-0.20687197, -0.20683673), |Œ¥p|=4e-05, [converged], Œ¥ = ( 1,  0), step =  45, eigenelements in eig[ 46], ind_ev =   7
- #  7,       bp at l ‚âà -0.20682087 ‚àà (-0.20682308, -0.20682087), |Œ¥p|=2e-06, [converged], Œ¥ = ( 1,  0), step =  46, eigenelements in eig[ 47], ind_ev =   8
- #  8,       bp at l ‚âà -0.19968465 ‚àà (-0.20040489, -0.19968465), |Œ¥p|=7e-04, [converged], Œ¥ = ( 1,  0), step =  49, eigenelements in eig[ 50], ind_ev =   9
- #  9,       bp at l ‚âà -0.18874190 ‚àà (-0.18918387, -0.18874190), |Œ¥p|=4e-04, [converged], Œ¥ = ( 1,  0), step =  53, eigenelements in eig[ 54], ind_ev =  10
- # 10,       bp at l ‚âà -0.18097123 ‚àà (-0.18109194, -0.18097123), |Œ¥p|=1e-04, [converged], Œ¥ = ( 1,  0), step =  56, eigenelements in eig[ 57], ind_ev =  11
- # 11,       bp at l ‚âà -0.14527574 ‚àà (-0.14531247, -0.14527574), |Œ¥p|=4e-05, [converged], Œ¥ = (-1,  0), step =  65, eigenelements in eig[ 66], ind_ev =  11
- # 12,       bp at l ‚âà -0.13844755 ‚àà (-0.13874721, -0.13844755), |Œ¥p|=3e-04, [converged], Œ¥ = (-1,  0), step =  67, eigenelements in eig[ 68], ind_ev =  10
- # 13,       bp at l ‚âà -0.11133440 ‚àà (-0.11141358, -0.11133440), |Œ¥p|=8e-05, [converged], Œ¥ = (-1,  0), step =  73, eigenelements in eig[ 74], ind_ev =   9
- # 14,       nd at l ‚âà -0.08965981 ‚àà (-0.08982220, -0.08965981), |Œ¥p|=2e-04, [converged], Œ¥ = (-2,  0), step =  78, eigenelements in eig[ 79], ind_ev =   8
- # 15,       bp at l ‚âà -0.07003255 ‚àà (-0.07134810, -0.07003255), |Œ¥p|=1e-03, [converged], Œ¥ = (-1,  0), step =  82, eigenelements in eig[ 83], ind_ev =   6
- # 16,       bp at l ‚âà -0.06080467 ‚àà (-0.06212463, -0.06080467), |Œ¥p|=1e-03, [converged], Œ¥ = (-1,  0), step =  84, eigenelements in eig[ 85], ind_ev =   5
- # 17,       bp at l ‚âà -0.05304226 ‚àà (-0.05320751, -0.05304226), |Œ¥p|=2e-04, [converged], Œ¥ = (-1,  0), step =  86, eigenelements in eig[ 87], ind_ev =   4
- # 18,       bp at l ‚âà -0.02465608 ‚àà (-0.02531351, -0.02465608), |Œ¥p|=7e-04, [converged], Œ¥ = (-1,  0), step =  92, eigenelements in eig[ 93], ind_ev =   3
- # 19,       bp at l ‚âà -0.00506953 ‚àà (-0.00636490, -0.00506953), |Œ¥p|=1e-03, [converged], Œ¥ = (-1,  0), step =  96, eigenelements in eig[ 97], ind_ev =   2
- # 20, endpoint at l ‚âà +0.00000000,</code></pre><p>We get the following plot during computation:</p><p><img src="../sh2dbrhexa.png" alt/></p><div class="admonition is-success" id="Tip-95e24f263737f877"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-95e24f263737f877" title="Permalink"></a></header><div class="admonition-body"><p>We don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><h2 id="Snaking-computed-with-deflation"><a class="docs-heading-anchor" href="#Snaking-computed-with-deflation">Snaking computed with deflation</a><a id="Snaking-computed-with-deflation-1"></a><a class="docs-heading-anchor-permalink" href="#Snaking-computed-with-deflation" title="Permalink"></a></h2><p>We know that there is snaking near the left fold. Let us look for other solutions like fronts. The problem is that if the guess is not precise enough, the newton iterations will converge to the solution with hexagons <code>sol_hexa</code>. We appeal to the technique initiated by P. Farrell and use a <strong>deflated problem</strong> (see <a href="../../library/#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a> and <a href="../../library/#BifurcationKit.DeflatedProblem"><code>DeflatedProblem</code></a> for more information). More precisely, we apply the newton iterations to the following functional <span>$u\to \Pi_{i=1}^{n_s}\left( \|u-sol_{hexa,i}\|^{-p} + \sigma\right)F_{sh}(u)$</span> which penalizes <code>sol_hexa</code>.</p><pre><code class="language-julia hljs"># this define the above penalizing factor with p=2, sigma=1, norm associated to dot
# and the set of sol_{hexa} is of length ns=1
deflationOp = DeflationOperator(2, 1.0, [sol_hexa.u])
optnewton = @set optnewton.max_iterations = 250
outdef = BK.solve(
				re_make(prob, u0 = 0.2vec(sol_hexa.u) .* vec([exp.(-(x+lx)^2/25) for x in X, y in Y])),
				deflationOp,
				optnewton, normN = norminf)
heatmapsol(outdef.u) |&gt; display
BK.converged(outdef) &amp;&amp; push!(deflationOp, outdef.u)</code></pre><p>which gives:</p><p><img src="../sh2dfrontleft.png" alt/></p><p>Note that <code>push!(deflationOp, outdef)</code> deflates the newly found solution so that by repeating the process we find another one:</p><pre><code class="language-julia hljs">outdef = BK.solve(
				re_make(prob, u0 = 0.2vec(sol_hexa.u) .* vec([exp.(-(x)^2/25) for x in X, y in Y])),
				deflationOp, optnewton, normN = norminf)
heatmapsol(outdef.u) |&gt; display
BK.converged(outdef) &amp;&amp; push!(deflationOp, outdef.u)</code></pre><p><img src="../sh2dfrontmiddle.png" alt/></p><p>Again, repeating this from random guesses, we find several more solutions, like for example</p><p><img src="../sh2dsol4.png" alt/></p><p><img src="../sh2dsol5.png" alt/></p><p>We can now continue the solutions located in <code>deflationOp.roots</code></p><pre><code class="language-julia hljs">br1 = @time continuation(re_make(prob, u0 = deflationOp[2]),
	PALC(), optcont;
	plot = true)</code></pre><p>and using <code>plot(br, br1)</code>, we obtain:</p><p><img src="../sh2dbranches.png" alt/></p><p>Note that the plot provides the stability of solutions and bifurcation points. Interested readers should consult the associated file <code>example/SH2d-fronts.jl</code> in the <code>example</code> folder.</p><h2 id="Automatic-branch-switching"><a class="docs-heading-anchor" href="#Automatic-branch-switching">Automatic branch switching</a><a id="Automatic-branch-switching-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-branch-switching" title="Permalink"></a></h2><p>Instead of relying on deflated newton, we can use <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/branchswitching/">Branch switching</a> to compute the different branches emanating from the bifurcation point. For example, the following code will perform automatic branch switching from the second bifurcation point of <code>br</code>:</p><pre><code class="language-julia hljs">br2 = continuation(br, 2, setproperties(optcont; ds = -0.001, detect_bifurcation = 3, plot_every_step = 5, max_steps = 170);  nev = 30,
	plot = true, verbosity = 2,
	normC = norminf)</code></pre><p>We can then plot the branches using <code>plot(br, br1, br2)</code> and get</p><p><img src="../SH2daBS.png" alt/></p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 23 November 2025 10:24">Sunday 23 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
