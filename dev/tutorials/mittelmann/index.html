<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2d generalized Bratu–Gelfand problem · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../plotting/">Plotting</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Nonlinear Equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose Continuation</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated Continuation</a></li></ul></li><li><a class="tocitem" href="../../EventCallback/">Event Handling and Callback</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Bifurcations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../../constrainedproblem/">Constrained problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>2d generalized Bratu–Gelfand problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>2d generalized Bratu–Gelfand problem</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/master/docs/src/tutorials/mittelmann.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="d-generalized-Bratu–Gelfand-problem"><a class="docs-heading-anchor" href="#d-generalized-Bratu–Gelfand-problem">2d generalized Bratu–Gelfand problem</a><a id="d-generalized-Bratu–Gelfand-problem-1"></a><a class="docs-heading-anchor-permalink" href="#d-generalized-Bratu–Gelfand-problem" title="Permalink"></a></h1><ul><li><a href="#d-generalized-Bratu–Gelfand-problem">2d generalized Bratu–Gelfand problem</a></li><li class="no-marker"><ul><li><a href="#Branch-of-homogenous-solutions">Branch of homogenous solutions</a></li><li><a href="#Automatic-branch-switching-at-simple-branch-points">Automatic branch switching at simple branch points</a></li><li><a href="#Analysis-at-the-2d-branch-points-(manual)">Analysis at the 2d-branch points (manual)</a></li><li><a href="#Branch-switching-with-deflated-newton-(manual)">Branch switching with deflated newton (manual)</a></li><li><a href="#Automatic-branch-switching-at-the-2d-branch-points">Automatic branch switching at the 2d-branch points</a></li></ul></li></ul><div class="admonition is-category-unknown"><header class="admonition-header">References</header><div class="admonition-body"><p>The following example is exposed in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. <strong>The Computation of Disconnected Bifurcation Diagrams.</strong> ArXiv:1603.00809 [Math], March 2, 2016. It is also treated in Michiel Wouters. <strong>Automatic Exploration Techniques for the Numerical Continuation of Large–Scale Nonlinear Systems</strong>, 2019.</p></div></div><p>We consider the problem of Mittelmann:</p><p class="math-container">\[\Delta u + NL(\lambda,u) = 0\]</p><p>with Neumann boundary condition on <span>$\Omega = (0,1)^2$</span> and where <span>$NL(\lambda,u)\equiv-10(u-\lambda e^u)$</span>. This is a good example to show how automatic branch switching works and also nonlinear deflation.</p><p>We start with some imports:</p><pre><code class="language-julia hljs">using Revise
using DiffEqOperators, ForwardDiff
using BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield
const BK = BifurcationKit

# define the sup norm and a L2 norm
norminf(x) = norm(x, Inf)
normbratu(x) = norm(x .* w) / sqrt(length(x)) # the weight w is defined below

# some plotting functions to simplify our life
plotsol!(x, nx = Nx, ny = Ny; kwargs...) = heatmap!(reshape(x, nx, ny); color = :viridis, kwargs...)
plotsol(x, nx = Nx, ny = Ny; kwargs...) = (plot();plotsol!(x, nx, ny; kwargs...))</code></pre><p>and with the discretization of the problem</p><pre><code class="language-julia hljs">function Laplacian2D(Nx, Ny, lx, ly, bc = :Neumann)
	hx = 2lx/Nx
	hy = 2ly/Ny
	D2x = CenteredDifference(2, 2, hx, Nx)
	D2y = CenteredDifference(2, 2, hy, Ny)

	Qx = Neumann0BC(hx)
	Qy = Neumann0BC(hy)

	D2xsp = sparse(D2x * Qx)[1]
	D2ysp = sparse(D2y * Qy)[1]
	A = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))
	return A
end

ϕ(u, λ)  = -10(u-λ*exp(u))
dϕ(u, λ) = -10(1-λ*exp(u))

function NL!(dest, u, p)
	@unpack λ = p
	dest .= ϕ.(u, λ)
	return dest
end

NL(u, p) = NL!(similar(u), u, p)

function Fmit!(f, u, p)
	mul!(f, p.Δ, u)
	f .= f .+ NL(u, p)
	return f
end

Fmit(u, p) = Fmit!(similar(u), u, p)</code></pre><p>It will also prove useful to have the derivatives of our functional:</p><pre><code class="language-julia hljs">function JFmit(x,p)
	J = p.Δ
	dg = dϕ.(x, p.λ)
	return J + spdiagm(0 =&gt; dg)
end

# compute 3-Jet
jet = BK.getJet(Fmit, JFmit)</code></pre><p>We need to define the parameters associated to this problem:</p><pre><code class="language-julia hljs">Nx = 30; Ny = 30
lx = 0.5; ly = 0.5
# weight for the weighted norm
const w = (lx .+ LinRange(-lx,lx,Nx)) * (LinRange(-ly,ly,Ny))&#39; |&gt; vec

Δ = Laplacian2D(Nx, Ny, lx, ly)
par_mit = (λ = .05, Δ = Δ)

# initial guess f for newton
sol0 = zeros(Nx, Ny) |&gt; vec</code></pre><p>To compute the eigenvalues, we opt for the shift-invert strategy with shift <code>=0.5</code></p><pre><code class="language-julia hljs"># eigensolver
eigls = EigKrylovKit(dim = 70)

# options for Newton solver, we pass the eigensolverr
opt_newton = BK.NewtonPar(tol = 1e-8, verbose = true, eigsolver = eigls, maxIter = 20)

# options for continuation
opts_br = ContinuationPar(pMax = 3.5, pMin = 0.025,
	# for a good looking curve
	dsmin = 0.001, dsmax = 0.05, ds = 0.01,
	# number of eigenvalues to compute
	nev = 30,
	plotEveryStep = 10, newtonOptions = (@set opt_newton.verbose = true),
	maxSteps = 100, precisionStability = 1e-6,
	# detect codim 1 bifurcations
	detectBifurcation = 3,
	# Optional: bisection options for locating bifurcations
	nInversion = 4, dsminBisection = 1e-7, maxBisectionSteps = 25)</code></pre><p>Note that we put the option <code>detectBifurcation = 3</code> to detect bifurcations precisely with a bisection method. Indeed, we need to locate these branch points precisely to be able to call automatic branch switching.</p><h2 id="Branch-of-homogenous-solutions"><a class="docs-heading-anchor" href="#Branch-of-homogenous-solutions">Branch of homogenous solutions</a><a id="Branch-of-homogenous-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-of-homogenous-solutions" title="Permalink"></a></h2><p>At this stage, we note that the problem has a curve of homogenous (constant in space) solutions <span>$u_h$</span> solving <span>$N(\lambda, u_h)=0$</span>. We shall compute this branch now.</p><p>Given that we will use these arguments for <code>continuation</code> many times, it is wise to collect them:</p><pre><code class="language-julia hljs"># optional arguments for continuation
kwargsC = (verbosity = 3, plot = true,
	recordFromSolution = (x, p) -&gt; (x = normbratu(x), n2 = norm(x), n∞ = norminf(x)),
	plotSolution = (x, p; k...) -&gt; plotsol!(x ; k...),
	normC = norminf
	)</code></pre><p>We call <code>continuation</code> with the initial guess <code>sol0</code> which is homogenous, thereby generating homogenous solutions:</p><pre><code class="language-julia hljs">br, = BK.continuation(Fmit, JFmit, sol0, par_mit, (@lens _.λ), opts_br; kwargsC...)</code></pre><p>You should see the following result:</p><p><img src="../mittlemann1.png" alt/></p><p>Several branch point were detected as can be seen using the command</p><pre><code class="language-julia hljs">julia&gt; br
Branch number of points: 84
Branch of Equilibrium
Parameters λ from 0.05 to 0.025
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.36787944 ∈ (+0.36787944, +0.36787944), |δp|=2e-10, [converged], δ = ( 1,  0), step =  18, eigenelements in eig[ 19], ind_ev =   1
- #  2,    nd at λ ≈ +0.27255474 ∈ (+0.27255474, +0.27255937), |δp|=5e-06, [converged], δ = ( 2,  0), step =  33, eigenelements in eig[ 34], ind_ev =   3
- #  3,    bp at λ ≈ +0.15215124 ∈ (+0.15215124, +0.15215818), |δp|=7e-06, [converged], δ = ( 1,  0), step =  48, eigenelements in eig[ 49], ind_ev =   4
- #  4,    nd at λ ≈ +0.03551852 ∈ (+0.03551852, +0.03554981), |δp|=3e-05, [converged], δ = ( 2,  0), step =  76, eigenelements in eig[ 77], ind_ev =   6</code></pre><p>We notice several simple bifurcation points for which the dimension of the kernel of the jacobian is one dimensional. In the above box, <code>δ = ( 1,  0)</code> gives the change in the stability. In this case, there is one vector in the kernel which is real. The bifurcation point 2 has a 2d kernel and is thus not amenable to automatic branch switching.</p><h2 id="Automatic-branch-switching-at-simple-branch-points"><a class="docs-heading-anchor" href="#Automatic-branch-switching-at-simple-branch-points">Automatic branch switching at simple branch points</a><a id="Automatic-branch-switching-at-simple-branch-points-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-branch-switching-at-simple-branch-points" title="Permalink"></a></h2><p>We can compute the branch off the third bifurcation point:</p><pre><code class="language-julia hljs">br1, = continuation(jet..., br, 3,
	setproperties(opts_br;ds = 0.001, maxSteps = 40); kwargsC...)</code></pre><p>and you should see:</p><p><img src="../mittlemann2.png" alt/></p><p>You can also plot the two branches together <code>plot(br,br1,plotfold=false)</code> and get</p><p><img src="../mittlemann3.png" alt/></p><p>We continue our journey and compute the branch bifurcating of the first bifurcation point from the last branch we computed:</p><pre><code class="language-julia hljs">br2, = continuation(jet..., br1, 1,
	setproperties(opts_br;ds = 0.001, maxSteps = 40); kwargsC...)</code></pre><p><img src="../mittlemann4.png" alt/></p><h2 id="Analysis-at-the-2d-branch-points-(manual)"><a class="docs-heading-anchor" href="#Analysis-at-the-2d-branch-points-(manual)">Analysis at the 2d-branch points (manual)</a><a id="Analysis-at-the-2d-branch-points-(manual)-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-at-the-2d-branch-points-(manual)" title="Permalink"></a></h2><p>The second bifurcation point on the branch <code>br</code> of homogenous solutions has a 2d kernel. we provide two methods to deal with such case</p><ul><li>automatic local bifurcation diagram (see below)</li><li>branch switching with deflation (see next section)</li></ul><p>We provide a generic way to study branch points of arbitrary dimensions by computing a reduced equation. The general method is based on a Lyapunov-Schmidt reduction. We can compute the information about the branch point using the generic function (valid for simple branch points, Hopf bifurcation points,...)</p><pre><code class="language-julia hljs">bp2d = computeNormalForm(jet..., br, 2;  verbose=true, nev = 50)</code></pre><p>You can print the 2d reduced equation as follows. Note that this is a multivariate polynomials. For more information, see <a href="../../nonsimplebp/#Non-simple-branch-point">Non-simple branch point</a>.</p><pre><code class="language-julia hljs">julia&gt; bp2d
Non simple bifurcation point at p ≈ 0.27255473583423123.
Kernel dimension = 2
Normal form :
 + -73.8978 * x1 ⋅ p + 0.0071 ⋅ x1³ + 0.0231 ⋅ x1² ⋅ x2 + -0.0273 ⋅ x1 ⋅ x2² + -0.0076 ⋅ x2³
 + -73.8978 * x2 ⋅ p + 0.0079 ⋅ x1³ + -0.027 ⋅ x1² ⋅ x2 + -0.0231 ⋅ x1 ⋅ x2² + 0.0072 ⋅ x2³</code></pre><p>You can evaluate this polynomial as follows <code>bp2d(Val(:reducedForm),[0.1,0.2], 0.01)</code> which returns a 2d vector or <code>bp2d([0.1,0.2], 0.01)</code>. This last expression actually returns a vector corresponding to the PDE problem.</p><p>You need to solve these equations to compute the bifurcation diagram in the neighborhood of the bifurcation point. In the present case, we do it using brute force. We suggest to use <code>IntervalConstraintProgramming.jl</code> for a more precise way.</p><pre><code class="language-julia hljs">using ProgressMeter
Nd = 200; L = 0.9
# sampling grid
X = LinRange(-L,L, Nd); Y = LinRange(-L,L, Nd); P = LinRange(-0.0001,0.0001, Nd+1)

# sample reduced equation on the grid for the first component
V1a = @showprogress [bp2d(Val(:reducedForm),[x1,y1], p1)[1] for p1 in P, x1 in X, y1 in Y]
Ind1 = findall( abs.(V1a) .&lt;= 9e-4 * maximum(abs.(V1a)))
# intersect with second component
V2a = @showprogress [bp2d(Val(:reducedForm),[X[ii[2]],Y[ii[3]]], P[ii[1]])[2] for ii in Ind1]
Ind2 = findall( abs.(V2a) .&lt;= 3e-3 * maximum(abs.(V2a)))

# get solutions
resp = Float64[]; resx = Vector{Float64}[]; resnrm = Float64[]
	@showprogress for k in Ind2
		ii = Ind1[k]
		push!(resp, P[ii[1]])
		push!(resnrm, sqrt(X[ii[2]]^2+Y[ii[3]]^2))
		push!(resx, [X[ii[2]], Y[ii[3]]])
	end</code></pre><p>We can now plot the local bifurcation diagram as follows</p><pre><code class="language-julia hljs">using LaTeXStrings
plot(
	scatter(1e4resp, map(x-&gt;x[1], resx), map(x-&gt;x[2], resx); label = &quot;&quot;, markerstrokewidth=0, xlabel = L&quot;10^4 \cdot \lambda&quot;, ylabel = L&quot;x_1&quot;, zlabel = L&quot;x_2&quot;, zcolor = resnrm, color = :viridis,colorbar=false),
	scatter(1e4resp, resnrm; label = &quot;&quot;, markersize =2, markerstrokewidth=0, xlabel = L&quot;10^4 \cdot \lambda&quot;, ylabel = L&quot;\|x\|&quot;))</code></pre><p><img src="../mittlemann4a.png" alt/></p><blockquote><p>This looks like a Pitchfork bifurcation with D4 symmetry</p></blockquote><p>We can see that there are two types of solutions. After the bifurcation point, the solutions are of the form <span>$(x_1,x_2) = (\pm x,\pm x)$</span> for some real <span>$x$</span>. Before the bifurcation point, the solutions are of the form <span>$(x_1,x_2) = (\pm x,0), (0, \pm x)$</span> for some real <span>$x$</span>. Here is an example <code>plotsol(bp2d(resx[10], resp[10]))</code></p><p><img src="../mittlemann4b.png" alt/></p><p>We could use the solutions saved in <code>resp, resx</code> as initial guesses for a call to <code>continuation</code> but we turn to a different method.</p><div class="admonition is-success"><header class="admonition-header">Solutions</header><div class="admonition-body"><p>The brute force method provided all solutions in a neighborhood of the bifurcation point.</p></div></div><div class="admonition is-info"><header class="admonition-header">Advanced computation</header><div class="admonition-body"><p>Instead of using brute force and computing the vector field on a grid. One can rely on <code>IntervalConstraintProgramming.jl</code> to do better using bisection. See also this <a href="https://discourse.julialang.org/t/nd-level-sets/38532/13">discourse post</a> where the same example is treated by D. P. Sanders.    </p></div></div><h2 id="Branch-switching-with-deflated-newton-(manual)"><a class="docs-heading-anchor" href="#Branch-switching-with-deflated-newton-(manual)">Branch switching with deflated newton (manual)</a><a id="Branch-switching-with-deflated-newton-(manual)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-with-deflated-newton-(manual)" title="Permalink"></a></h2><p>At this stage, we know what happens at the 2d bifurcation point of the curve of homogenous solutions. We chose another method based on <a href="../../deflatedproblem/#Deflated-problems">Deflated problems</a>. We want to find all nearby solutions of the problem close to this bifurcation point. This is readily done by trying several initial guesses in a brute force manner:</p><pre><code class="language-julia hljs">out = zeros(Nx*Ny)
# deflation operator to
deflationOp = DeflationOperator(2, 1.0, [zeros(Nx*Ny)])

# options for the newton solver
optdef = setproperties(opt_newton; tol = 1e-8, maxIter = 100)

# eigen-elements close to the second bifurcation point on the branch
# of homogenous solutions
vp, ve, _, _= eigls(JFmit(out, @set par_mit.λ = br.specialpoint[2].param), 5)

for ii=1:length(ve)
	outdef1, _, flag, _ = @time newton(
		Fmit, JFmit,
		# initial guess for newton
		br.specialpoint[2].x .+ 0.01 .*  real.(ve[ii]) .* (1 .+ 0.01 .* rand(Nx*Ny)),
		(@set par_mit.λ = br.specialpoint[2].param + 0.005),
		optdef, deflationOp)
		flag &amp;&amp; push!(deflationOp, outdef1)
end</code></pre><p>This provides <code>length(deflationOp) = 5</code> solutions as there are some symmetries in the problem. For example <code>plotsol(deflationOp[5])</code> gives</p><p><img src="../mittlemann5.png" alt/></p><p>We can continue this solution as follows in one direction</p><pre><code class="language-julia hljs">brdef1, = continuation(
	Fmit, JFmit,
	deflationOp[3], (@set par_mit.λ = br.specialpoint[2].param + 0.005), (@lens _.λ),
	setproperties(opts_br;ds = -0.001, detectBifurcation = 3, dsmax = 0.01, maxSteps = 500);
	kwargsC...)</code></pre><p>If we repeat the above loop but before the branch point by using <code>@set par_mit.λ = br.specialpoint[2].param + 0.005</code>, we get 3 new solutions that we can continue</p><pre><code class="language-julia hljs">brdef2, = continuation(
	Fmit, JFmit,
	deflationOp[5], (@set par_mit.λ = br.specialpoint[2].param + 0.005), (@lens _.λ),
	setproperties(opts_br;ds = 0.001, detectBifurcation = 3, dsmax = 0.01);
	kwargsC...)</code></pre><p>thereby providing the following bifurcation diagram with <code>plot(br,br1,br2,brdef1, brdef2,plotfold=false, putbifptlegend = false)</code></p><p><img src="../mittlemann6.png" alt/></p><h2 id="Automatic-branch-switching-at-the-2d-branch-points"><a class="docs-heading-anchor" href="#Automatic-branch-switching-at-the-2d-branch-points">Automatic branch switching at the 2d-branch points</a><a id="Automatic-branch-switching-at-the-2d-branch-points-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-branch-switching-at-the-2d-branch-points" title="Permalink"></a></h2><p>We now show how to perform automatic branch switching at the nonsimple branch points. However, we think it is important that the user is able to use the previous tools in case automatic branch switching fails.</p><p>The call for automatic branch switching is the same as in the case of simple branch points (see above) except that many branches are returned.</p><pre><code class="language-julia hljs">branches, = continuation(jet..., br, 2,
	setproperties(opts_br; detectBifurcation = 3, ds = 0.001, pMin = 0.01, maxSteps = 32 ) ;
	kwargsC...,
	nev = 30, tangentAlgo = BorderedPred()
	)</code></pre><p>You can plot the branches using <code>plot(branches...)</code>. The branches are as follows</p><pre><code class="language-julia hljs">julia&gt; branches
8-element Vector{Branch}:
 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.0656104381834156
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.14414814 ∈ (+0.14414814, +0.14424073), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3

 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.06561043854512201
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.14414814 ∈ (+0.14414814, +0.14424073), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3

 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.06561044134787948
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.14414815 ∈ (+0.14414815, +0.14424074), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3

 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.06561043798345574
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255723 ∈ (+0.27255723, +0.27255723), |δp|=7e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.14414814 ∈ (+0.14414814, +0.14424073), |δp|=9e-05, [converged], δ = ( 1,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3

 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.09945404995078021
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2

 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.09945405127587528
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2

 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.09945404945914721
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2

 Branch number of points: 33
Branch of Equilibrium from NonSimpleBranchPoint bifurcation point.
Parameters λ from 0.27255473583423384 to 0.09945404935297063
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at λ ≈ +0.27255724 ∈ (+0.27255724, +0.27255724), |δp|=9e-10, [converged], δ = (-1,  0), step =   1, eigenelements in eig[  2], ind_ev =   3
- #  2,    bp at λ ≈ +0.27868730 ∈ (+0.27868728, +0.27868730), |δp|=3e-08, [converged], δ = (-1,  0), step =  15, eigenelements in eig[ 16], ind_ev =   2</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 1 December 2021 18:36">Wednesday 1 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
