<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2d Ginzburg-Landau equation (shooting) · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../educational/">Educational introduction</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guidelines/">Overview</a></li><li><a class="tocitem" href="../../plotting/">Plotting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose Continuation</a></li><li><a class="tocitem" href="../../ANM/">ANM</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated Continuation</a></li><li><a class="tocitem" href="../../EventCallback/">Event Handling and Callback</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Nonlinear Equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Bifurcations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li><li><a class="tocitem" href="../../codim3Continuation/">Bogdanov-Takens refinement (codim 3)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../../cusp/">Cusp</a></li><li><a class="tocitem" href="../../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../../bautin/">Bautin</a></li><li><span class="tocitem">Normal form (periodic orbit)</span></li></ul></li><li><a class="tocitem" href="../../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../../constrainedproblem/">Constrained problem</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../../interfaceLS/">Linear / Eigen Solvers</a></li><li><a class="tocitem" href="../../interfacePred/">Predictor / Corrector</a></li><li><a class="tocitem" href="../../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>2d Ginzburg-Landau equation (shooting)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>2d Ginzburg-Landau equation (shooting)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/tutorials/tutorialsCGLShoot.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="d-Ginzburg-Landau-equation-(shooting)"><a class="docs-heading-anchor" href="#d-Ginzburg-Landau-equation-(shooting)">2d Ginzburg-Landau equation (shooting)</a><a id="d-Ginzburg-Landau-equation-(shooting)-1"></a><a class="docs-heading-anchor-permalink" href="#d-Ginzburg-Landau-equation-(shooting)" title="Permalink"></a></h1><ul><li><a href="#d-Ginzburg-Landau-equation-(shooting)">2d Ginzburg-Landau equation (shooting)</a></li><li class="no-marker"><ul><li><a href="#Automatic-branch-switching-from-the-Hopf-points">Automatic branch switching from the Hopf points</a></li><li><a href="#Manual-branch-switching-from-the-Hopf-points">Manual branch switching from the Hopf points</a></li></ul></li></ul><p>In this tutorial, we re-visit the example <a href="../tutorialsCGL/#d-Ginzburg-Landau-equation-(finite-differences,-codim-2,-Hopf-aBS)">2d Ginzburg-Landau equation (finite differences, codim 2, Hopf aBS)</a> using a Standard Simple Shooting method. In the tutorial <a href="../tutorials3b/#d-Brusselator-(advanced-user)">1d Brusselator (advanced user)</a>, we used the implicit solver <code>Rodas4P</code> for the shooting. We will use the exponential-RK scheme <code>ETDRK2</code> ODE solver to compute the solution of cGL equations. This method is convenient for solving semilinear problems of the form</p><p class="math-container">\[\dot x = Ax+g(x)\]</p><p>where <span>$A$</span> is the infinitesimal generator of a <span>$C_0$</span>-semigroup. We use the same beginning as in <a href="../tutorialsCGL/#d-Ginzburg-Landau-equation-(finite-differences,-codim-2,-Hopf-aBS)">2d Ginzburg-Landau equation (finite differences, codim 2, Hopf aBS)</a>:</p><pre><code class="language-julia hljs">using Revise
	using DiffEqOperators, DifferentialEquations
	using BifurcationKit, LinearAlgebra, Plots, SparseArrays, Parameters, Setfield
	const BK = BifurcationKit

norminf(x) = norm(x, Inf)

function Laplacian2D(Nx, Ny, lx, ly)
	hx = 2lx/Nx
	hy = 2ly/Ny
	D2x = CenteredDifference(2, 2, hx, Nx)
	D2y = CenteredDifference(2, 2, hy, Ny)

	Qx = Dirichlet0BC(typeof(hx))
	Qy = Dirichlet0BC(typeof(hy))

	D2xsp = sparse(D2x * Qx)[1]
	D2ysp = sparse(D2y * Qy)[1]

	A = kron(sparse(I, Ny, Ny), D2xsp) + kron(D2ysp, sparse(I, Nx, Nx))
	return A, D2x
end</code></pre><p>We then encode the PDE:</p><pre><code class="language-julia hljs">function NL!(f, u, p, t = 0.)
	@unpack r, μ, ν, c3, c5 = p
	n = div(length(u), 2)
	u1 = @view u[1:n]
	u2 = @view u[n+1:2n]

	ua = u1.^2 .+ u2.^2

	f1 = @view f[1:n]
	f2 = @view f[n+1:2n]

	@. f1 .= r * u1 - ν * u2 - ua * (c3 * u1 - μ * u2) - c5 * ua^2 * u1
	@. f2 .= r * u2 + ν * u1 - ua * (c3 * u2 + μ * u1) - c5 * ua^2 * u2

	return f
end

function Fcgl!(f, u, p, t = 0.)
	mul!(f, p.Δ, u)
	f .= f .+ NL(u, p)
end

NL(u, p) = NL!(similar(u), u, p)
Fcgl(u, p, t = 0.) = Fcgl!(similar(u), u, p, t)

function Jcgl(u, p, t = 0.)
	@unpack r, μ, ν, c3, c5, Δ = p

	n = div(length(u), 2)
	u1 = @view u[1:n]
	u2 = @view u[n+1:2n]

	ua = u1.^2 .+ u2.^2

	f1u = zero(u1)
	f2u = zero(u1)
	f1v = zero(u1)
	f2v = zero(u1)

	@. f1u =  r - 2 * u1 * (c3 * u1 - μ * u2) - c3 * ua - 4 * c5 * ua * u1^2 - c5 * ua^2
	@. f1v = -ν - 2 * u2 * (c3 * u1 - μ * u2)  + μ * ua - 4 * c5 * ua * u1 * u2
	@. f2u =  ν - 2 * u1 * (c3 * u2 + μ * u1)  - μ * ua - 4 * c5 * ua * u1 * u2
	@. f2v =  r - 2 * u2 * (c3 * u2 + μ * u1) - c3 * ua - 4 * c5 * ua * u2 ^2 - c5 * ua^2

	jacdiag = vcat(f1u, f2v)

	Δ + spdiagm(0 =&gt; jacdiag, n =&gt; f1v, -n =&gt; f2u)
end</code></pre><p>with parameters</p><pre><code class="language-julia hljs">Nx = 41
Ny = 21
n = Nx*Ny
lx = pi
ly = pi/2

Δ = Laplacian2D(Nx, Ny, lx, ly)[1]
par_cgl = (r = 0.5, μ = 0.1, ν = 1.0, c3 = -1.0, c5 = 1.0, Δ = blockdiag(Δ, Δ))
sol0 = 0.1rand(2Nx, Ny)
sol0_f = vec(sol0)

prob = BK.BifurcationProblem(Fcgl, sol0_f, par_cgl, (@lens _.r); J = Jcgl)</code></pre><p>and the ODE problem</p><pre><code class="language-julia hljs">f1 = DiffEqArrayOperator(par_cgl.Δ)
f2 = NL!
prob_sp = SplitODEProblem(f1, f2, sol0_f, (0.0, 120.0), (@set par_cgl.r = 1.2), dt = 0.1)
# we solve the PDE!!!
sol = @time solve(prob_sp, ETDRK2(krylov=true); abstol=1e-14, reltol=1e-14)</code></pre><h2 id="Automatic-branch-switching-from-the-Hopf-points"><a class="docs-heading-anchor" href="#Automatic-branch-switching-from-the-Hopf-points">Automatic branch switching from the Hopf points</a><a id="Automatic-branch-switching-from-the-Hopf-points-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-branch-switching-from-the-Hopf-points" title="Permalink"></a></h2><p>We show how to use automatic branch switching from the Hopf points computed in the previous section. To compute the periodic orbits, we use a Standard Shooting method.</p><p>We first recompute the Hopf points as in the previous tutorial:</p><pre><code class="language-julia hljs">eigls = EigArpack(1.0, :LM)
opt_newton = NewtonPar(tol = 1e-9, verbose = true, eigsolver = eigls, maxIter = 20)
opts_br = ContinuationPar(dsmax = 0.02, ds = 0.01, pMax = 2., detectBifurcation = 3, nev = 15, newtonOptions = (@set opt_newton.verbose = false), nInversion = 4)

br = @time continuation(prob, PALC(), opts_br, verbosity = 0)</code></pre><p>We then compute the differentials of the vector field, this is needed by the branch switching method because it first computes the Hopf normal form. Thankfully, this is little work using Automatic Differentiation.</p><p>We define the linear solvers to be use by the (Matrix-Free) shooting method</p><pre><code class="language-julia hljs">ls = GMRESIterativeSolvers(reltol = 1e-4, maxiter = 50, verbose = false)
eig = EigKrylovKit(tol = 1e-7, x₀ = rand(2Nx*Ny), verbose = 2, dim = 40)
optn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 25, linsolver = ls, eigsolver = eig)
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.02, ds= 0.01, pMax = 2.5, maxSteps = 32, newtonOptions = optn, nev = 7, tolStability = 1e-3, detectBifurcation = 3, plotEveryStep = 1)</code></pre><p>as</p><pre><code class="language-julia hljs">Mt = 1 # number of time sections
br_po = continuation(
	# we want to compute the bifurcated branch from
	# the first Hopf point
	br, 1,
	# arguments for continuation
	opts_po_cont,
	# this is how to pass the method to compute the periodic
	# orbits. We shall use 1 section and the ODE solver ETDRK2
	ShootingProblem(Mt, prob_sp, ETDRK2(krylov = true); abstol = 1e-10, reltol = 1e-8, jacobian = :FiniteDifferences) ;
	# linear solver for bordered linear system
	# we combine the 2 solves. It is here faster than BorderingBLS()
	linearAlgo = MatrixFreeBLS(@set ls.N = Mt*2n+2),
	# to help branching from the Hopf point
	ampfactor = 1.5, δp = 0.01,
	# regular parameters for the continuation
	verbosity = 3, plot = true,
	# a few parameters saved during run
	recordFromSolution = (u, p) -&gt; (amp = BK.getAmplitude(p.prob, u, (@set par_cgl.r = p.p)), period = u[end]),
	# plotting of a section
	plotSolution = (x, p; k...) -&gt; heatmap!(reshape(x[1:Nx*Ny], Nx, Ny); color=:viridis, k...),
	# print the Floquet exponent
	finaliseSolution = (z, tau, step, contResult; k...) -&gt;
		(Base.display(contResult.eig[end].eigenvals) ;true),
	normC = norminf)</code></pre><p><img src="../cgl-sh-br.png" alt/></p><h2 id="Manual-branch-switching-from-the-Hopf-points"><a class="docs-heading-anchor" href="#Manual-branch-switching-from-the-Hopf-points">Manual branch switching from the Hopf points</a><a id="Manual-branch-switching-from-the-Hopf-points-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-branch-switching-from-the-Hopf-points" title="Permalink"></a></h2><p>The goal of this section is to show how to use the package in case automatic branch switching fails. This can happen for tedious PDEs and &quot;one has to get his hands dirty&quot;.</p><p>We decide to use Standard Shooting and thus define a Shooting functional</p><pre><code class="language-julia hljs">probSh = ShootingProblem(
	# we pass the ODEProblem encoding the flow and the time stepper
	remake(prob_sp, p = (@set par_cgl.r = 1.2)), ETDRK2(krylov = true),

	# this is the phase condition
	[sol[:, end]];

	# parameter axis
	lens = (@lens _.r),

	# jacobian of the periodic orbit functional
	jacobian = :FiniteDifferences,

	# these are options passed to the ODE time stepper
	abstol = 1e-14, reltol = 1e-14)</code></pre><p>We use the solution from the ODE solver as a starting guess for the shooting method.</p><pre><code class="language-julia hljs"># initial guess with period 6.9 using solution at time t = 116
initpo = vcat(sol(116.), 6.9) |&gt; vec

# linear solver for shooting functional
ls = GMRESIterativeSolvers(reltol = 1e-4, N = 2Nx * Ny + 1, maxiter = 50, verbose = false)

# newton parameters
optn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)

# continuation parameters
eig = EigKrylovKit(tol=1e-7, x₀ = rand(2Nx*Ny), verbose = 2, dim = 40)
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds= -0.01, pMax = 1.5, maxSteps = 60, newtonOptions = (@set optn.eigsolver = eig), nev = 5, tolStability = 1e-3, detectBifurcation = 0)

br_po = @time continuation(probSh,
	initpo, PALC(), opts_po_cont;
	verbosity = 3, plot = true,
	linearAlgo = MatrixFreeBLS(@set ls.N = probSh.M*2n+2),
	plotSolution = (x, p; kwargs...) -&gt; heatmap!(reshape(x[1:Nx*Ny], Nx, Ny); color=:viridis, kwargs...),
	recordFromSolution = (u, p) -&gt; BK.getAmplitude(probSh, u, (@set par_cgl.r = p.p); ratio = 2), normC = norminf)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 15 November 2022 18:53">Tuesday 15 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
