<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU Â· Bifurcation Analysis in Julia</title><meta name="title" content="ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU Â· Bifurcation Analysis in Julia"/><meta property="og:title" content="ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU Â· Bifurcation Analysis in Julia"/><meta property="twitter:title" content="ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU Â· Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../../educational/">Educational introduction</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../../ANM/">ANM</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../../cusp/">Cusp</a></li><li><a class="tocitem" href="../../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../../bautin/">Bautin</a></li><li><a class="tocitem" href="../../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../../pd/">Period-doubling</a></li><li><a class="tocitem" href="../../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/tutorials/tutorials2b.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sh2dgpu"><a class="docs-heading-anchor" href="#sh2dgpu">ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU</a><a id="sh2dgpu-1"></a><a class="docs-heading-anchor-permalink" href="#sh2dgpu" title="Permalink"></a></h1><ul><li><a href="#sh2dgpu">ğŸŸ  2d Swift-Hohenberg equation (non-local) on the GPU</a></li><li class="no-marker"><ul><li><a href="#Linear-Algebra-on-the-GPU">Linear Algebra on the GPU</a></li><li><a href="#Computing-the-inverse-of-the-differential-operator">Computing the inverse of the differential operator</a></li><li><a href="#Newton-iterations-and-deflation">Newton iterations and deflation</a></li><li><a href="#Computation-of-the-branches">Computation of the branches</a></li></ul></li></ul><p>Here we give an example where the continuation can be done <strong>entirely</strong> on the GPU, <em>e.g.</em> on a single V100 NIVDIA.</p><div class="admonition is-info"><header class="admonition-header">Why this example?</header><div class="admonition-body"><p>This is not the simplest GPU example because we need a preconditioned linear solver and shift-invert eigen solver for this problem. On the other hand, you will be shown how to set up your own linear/eigen solver.</p></div></div><p>We choose the 2d Swift-Hohenberg as an example and consider a larger grid. See <a href="../tutorials2/#sh2dfd">2d Swift-Hohenberg equation</a> for more details. Solving the sparse linear problem in <span>$v$</span></p><p class="math-container">\[-(I+\Delta)^2 v+(l +2\nu u-3u^2)v = rhs\]</p><p>with a <strong>direct</strong> solver becomes prohibitive. Looking for an iterative method, the conditioning of the jacobian is not good enough to have fast convergence, mainly because of the Laplacian operator. However, the above problem is equivalent to:</p><p class="math-container">\[-v + L \cdot (d \cdot v) = L\cdot rhs\]</p><p>where</p><p class="math-container">\[L := ((I+\Delta)^2 + I)^{-1}\]</p><p>is very well conditioned and</p><p class="math-container">\[d := l+1+2\nu v-3v^2.\]</p><p>Hence, to solve the previous equation, only a <strong>few</strong> GMRES iterations are required.</p><blockquote><p>In effect, the preconditioned PDE is an example of nonlocal problem.</p></blockquote><h2 id="Linear-Algebra-on-the-GPU"><a class="docs-heading-anchor" href="#Linear-Algebra-on-the-GPU">Linear Algebra on the GPU</a><a id="Linear-Algebra-on-the-GPU-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra-on-the-GPU" title="Permalink"></a></h2><p>We plan to use <code>KrylovKit</code> on the GPU. We define the following types so it is easier to switch to <code>Float32</code> for example:</p><pre><code class="language-julia hljs">using Revise, CUDA

# this disable slow operations but errors if you use one of them
CUDA.allowscalar(false)

# type used for the arrays, can be Float32 if GPU requires it
TY = Float64

# put the AF = Array{TY} instead to make the code on the CPU
AF = CuArray{TY}</code></pre><h2 id="Computing-the-inverse-of-the-differential-operator"><a class="docs-heading-anchor" href="#Computing-the-inverse-of-the-differential-operator">Computing the inverse of the differential operator</a><a id="Computing-the-inverse-of-the-differential-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-inverse-of-the-differential-operator" title="Permalink"></a></h2><p>The issue now is to compute <span>$L$</span> but this is easy using Fourier transforms.</p><p>Hence, that&#39;s why we slightly modify the previous Example by considering <strong>periodic</strong> boundary conditions. Let us now show how to compute <span>$L$</span>. Although the code looks quite technical, it is based on two facts. First, the Fourier transform symbol associated to <span>$L$</span> is</p><p class="math-container">\[l_1 = 1+(1-k_x^2-k_y^2)^2\]</p><p>which is pre-computed in the composite type <code>SHLinearOp</code>. Then, the effect of <code>L</code> on <code>u</code> is as simple as <code>real.(ifft( l1 .* fft(u) ))</code> and the inverse <code>L\u</code> is <code>real.(ifft( fft(u) ./ l1 ))</code>. However, in order to save memory on the GPU, we use inplace FFTs to reduce temporaries which explains the following code.</p><pre><code class="language-julia hljs">using AbstractFFTs, FFTW, KrylovKit, Setfield, Parameters
using BifurcationKit, LinearAlgebra, Plots
const BK = BifurcationKit

# the following struct encodes the operator L1
# Making the linear operator a subtype of BK.AbstractLinearSolver is handy as it will be used
# in the Newton iterations.
struct SHLinearOp{Treal, Tcomp, Tl1, Tplan, Tiplan} &lt;: BK.AbstractLinearSolver
	tmp_real::Treal         # temporary
	tmp_complex::Tcomp      # temporary
	l1::Tl1
	fftplan::Tplan
	ifftplan::Tiplan
end

# this is a constructor for the above struct
function SHLinearOp(Nx, lx, Ny, ly; AF = Array{TY})
	# AF is a type, it could be CuArray{TY} to run the following on GPU
	k1 = vcat(collect(0:Nx/2), collect(Nx/2+1:Nx-1) .- Nx)
	k2 = vcat(collect(0:Ny/2), collect(Ny/2+1:Ny-1) .- Ny)
	d2 = [(1-(pi/lx * kx)^2 - (pi/ly * ky)^2)^2 + 1. for kx in k1, ky in k2]
	tmpc = Complex.(AF(zeros(Nx, Ny)))
	return SHLinearOp(AF(zeros(Nx, Ny)), tmpc, AF(d2), plan_fft!(tmpc), plan_ifft!(tmpc))
end

import Base: *, \

# generic function to apply operator op to u
function apply(c::SHLinearOp, u, multiplier, op = *)
	c.tmp_complex .= Complex.(u)
	c.fftplan * c.tmp_complex
	c.tmp_complex .= op.(c.tmp_complex, multiplier)
	c.ifftplan * c.tmp_complex
	c.tmp_real .= real.(c.tmp_complex)
	return copy(c.tmp_real)
end

# action of L
*(c::SHLinearOp, u) = apply(c, u, c.l1)

# inverse of L
\(c::SHLinearOp, u) = apply(c, u, c.l1, /)</code></pre><p>Before applying a Newton solver, we need to tell how to solve the linear equation arising in the Newton Algorithm.</p><pre><code class="language-julia hljs"># inverse of the jacobian of the PDE
function (sh::SHLinearOp)(J, rhs; shift = 0., tol =  1e-9)
	u, l, Î½ = J
	udiag = l .+ 1 .+ 2Î½ .* u .- 3 .* u.^2 .- shift
	res, info = KrylovKit.linsolve( du -&gt; -du .+ sh \ (udiag .* du), sh \ rhs,
	tol = tol, maxiter = 6)
	return res, true, info.numops
end</code></pre><p>Now that we have our operator <code>L</code>, we can encode our functional:</p><pre><code class="language-julia hljs">function F_shfft(u, p)
	@unpack l, Î½, L = p
	return -(L * u) .+ ((l+1) .* u .+ Î½ .* u.^2 .- u.^3)
end</code></pre><p>Let us now show how to build our operator <code>L</code> and an initial guess <code>sol0</code> using the above defined structures.</p><pre><code class="language-julia hljs">using LinearAlgebra, Plots

# to simplify plotting of the solution
plotsol(x; k...) = heatmap(reshape(Array(x), Nx, Ny)&#39;; color=:viridis, k...)
plotsol!(x; k...) = heatmap!(reshape(Array(x), Nx, Ny)&#39;; color=:viridis, k...)
norminf(x) = maximum(abs.(x))

# norm compatible with CUDA
norminf(x) = maximum(abs.(x))

Nx = 2^10
Ny = 2^10
lx = 8pi * 2
ly = 2*2pi/sqrt(3) * 2

X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)
Y = -ly .+ 2ly/(Ny) * collect(0:Ny-1)

sol0 = [(cos(x) .+ cos(x/2) * cos(sqrt(3) * y/2) ) for x in X, y in Y]
		sol0 .= sol0 .- minimum(vec(sol0))
		sol0 ./= maximum(vec(sol0))
		sol0 = sol0 .- 0.25
		sol0 .*= 1.7

L = SHLinearOp(Nx, lx, Ny, ly, AF = AF)
J_shfft(u, p) = (u, p.l, p.Î½)

# parameters of the PDE
par = (l = -0.15, Î½ = 1.3, L = L)

# Bifurcation Problem
prob = BK.BifurcationProblem(F_shfft, AF(sol0), par, (@lens _.l) ;
	J =  J_shfft,
	plot_solution = (x, p;kwargs...) -&gt; plotsol!(x; color=:viridis, kwargs...),
	record_from_solution = (x, p) -&gt; norm(x))</code></pre><h2 id="Newton-iterations-and-deflation"><a class="docs-heading-anchor" href="#Newton-iterations-and-deflation">Newton iterations and deflation</a><a id="Newton-iterations-and-deflation-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-iterations-and-deflation" title="Permalink"></a></h2><p>We are now ready to perform Newton iterations:</p><pre><code class="language-julia hljs">opt_new = NewtonPar(verbose = true, tol = 1e-6, max_iterations = 100, linsolver = L)
sol_hexa = @time newton(prob, opt_new, normN = norminf)
println(&quot;--&gt; norm(sol) = &quot;, maximum(abs.(sol_hexa.u)))
plotsol(sol_hexa.u)</code></pre><p>You should see this:</p><pre><code class="language-julia hljs">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Newton step         residual     linear iterations  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       0     â”‚       3.3758e-01     â”‚        0       â”‚
â”‚       1     â”‚       8.0152e+01     â”‚       12       â”‚
â”‚       2     â”‚       2.3716e+01     â”‚       28       â”‚
â”‚       3     â”‚       6.7353e+00     â”‚       22       â”‚
â”‚       4     â”‚       1.9498e+00     â”‚       17       â”‚
â”‚       5     â”‚       5.5893e-01     â”‚       14       â”‚
â”‚       6     â”‚       1.0998e-01     â”‚       12       â”‚
â”‚       7     â”‚       1.1381e-02     â”‚       11       â”‚
â”‚       8     â”‚       1.6393e-04     â”‚       11       â”‚
â”‚       9     â”‚       7.3277e-08     â”‚       10       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  0.317790 seconds (42.67 k allocations: 1.256 MiB)
--&gt; norm(sol) = 1.26017611779702</code></pre><p><strong>Note that this is about the 10x faster than Example 2 but for a problem almost 100x larger! (On a V100 GPU)</strong></p><p>The solution is:</p><p><img src="../SH-GPU.png" alt/></p><p>We can also use the deflation technique (see <a href="../../library/#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a> and <a href="../../library/#BifurcationKit.DeflatedProblem"><code>DeflatedProblem</code></a> for more information) on the GPU as follows</p><pre><code class="language-julia hljs">deflationOp = DeflationOperator(2, dot, 1.0, [sol_hexa.u])

opt_new = @set opt_new.max_iterations = 250
outdef = @time newton(re_make(prob, u0 = AF(0.4 .* sol_hexa.u .* AF([exp(-1(x+0lx)^2/25) for x in X, y in Y]))),
		deflationOp, opt_new, normN = x-&gt; maximum(abs.(x)))
println(&quot;--&gt; norm(sol) = &quot;, norm(outdef.u))
plotsol(outdef.u) |&gt; display
BK.converged(outdef) &amp;&amp; push!(deflationOp, outdef.u)</code></pre><p>and get:</p><p><img src="../SH-GPU-deflation.png" alt/></p><h2 id="Computation-of-the-branches"><a class="docs-heading-anchor" href="#Computation-of-the-branches">Computation of the branches</a><a id="Computation-of-the-branches-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-of-the-branches" title="Permalink"></a></h2><p>Finally, we can perform continuation of the branches on the GPU:</p><pre><code class="language-julia hljs">opts_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.007, ds= -0.005,
	p_max = 0., p_min = -1.0, plot_every_step = 5, detect_bifurcation = 0,
	newton_options = setproperties(opt_new; tol = 1e-6, max_iterations = 15), max_steps = 100)

br = @time continuation(re_make(prob, u0 = deflationOp[1]),
PALC(bls = BorderingBLS(solver = L, check_precision = false)),
opts_cont;
	plot = true, verbosity = 3,
	normC = x -&gt; maximum(abs.(x))
	)</code></pre><p>We did not detail how to compute the eigenvalues on the GPU and detect the bifurcations. It is based on a simple Shift-Invert strategy, please look at <code>examples/SH2d-fronts-cuda.jl</code>.</p><p><img src="../GPU-branch.png" alt/></p><p>We have the following information about the branch of hexagons</p><pre><code class="language-julia hljs">julia&gt; br
Branch number of points: 67
Branch of Equilibrium
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    nd at p â‰ˆ -0.21522461 âˆˆ (-0.21528614, -0.21522461), |Î´p|=6e-05, [converged], Î´ = ( 3,  0), step =  24, eigenelements in eig[ 25], ind_ev =   3
- #  2,    nd at p â‰ˆ -0.21469007 âˆˆ (-0.21479652, -0.21469007), |Î´p|=1e-04, [converged], Î´ = ( 2,  0), step =  25, eigenelements in eig[ 26], ind_ev =   5
- #  3,    nd at p â‰ˆ -0.21216919 âˆˆ (-0.21264341, -0.21216919), |Î´p|=5e-04, [converged], Î´ = ( 2,  0), step =  27, eigenelements in eig[ 28], ind_ev =   7
- #  4,    nd at p â‰ˆ -0.21052576 âˆˆ (-0.21110899, -0.21052576), |Î´p|=6e-04, [converged], Î´ = ( 2,  0), step =  28, eigenelements in eig[ 29], ind_ev =   9
- #  5,    nd at p â‰ˆ -0.20630678 âˆˆ (-0.21052576, -0.20630678), |Î´p|=4e-03, [converged], Î´ = ( 8,  0), step =  29, eigenelements in eig[ 30], ind_ev =  17
- #  6,    nd at p â‰ˆ -0.19896508 âˆˆ (-0.19897308, -0.19896508), |Î´p|=8e-06, [converged], Î´ = ( 6,  0), step =  30, eigenelements in eig[ 31], ind_ev =  23
- #  7,    nd at p â‰ˆ -0.18621673 âˆˆ (-0.18748234, -0.18621673), |Î´p|=1e-03, [converged], Î´ = ( 2,  0), step =  33, eigenelements in eig[ 34], ind_ev =  25
- #  8,    nd at p â‰ˆ -0.17258147 âˆˆ (-0.18096574, -0.17258147), |Î´p|=8e-03, [converged], Î´ = ( 4,  0), step =  35, eigenelements in eig[ 36], ind_ev =  29
- #  9,    nd at p â‰ˆ -0.14951737 âˆˆ (-0.15113148, -0.14951737), |Î´p|=2e-03, [converged], Î´ = (-4,  0), step =  39, eigenelements in eig[ 40], ind_ev =  29
- # 10,    nd at p â‰ˆ -0.14047758 âˆˆ (-0.14130979, -0.14047758), |Î´p|=8e-04, [converged], Î´ = (-2,  0), step =  41, eigenelements in eig[ 42], ind_ev =  25
- # 11,    nd at p â‰ˆ -0.11304882 âˆˆ (-0.11315916, -0.11304882), |Î´p|=1e-04, [converged], Î´ = (-4,  0), step =  45, eigenelements in eig[ 46], ind_ev =  23
- # 12,    nd at p â‰ˆ -0.09074623 âˆˆ (-0.09085968, -0.09074623), |Î´p|=1e-04, [converged], Î´ = (-6,  0), step =  49, eigenelements in eig[ 50], ind_ev =  19
- # 13,    nd at p â‰ˆ -0.07062574 âˆˆ (-0.07246519, -0.07062574), |Î´p|=2e-03, [converged], Î´ = (-4,  0), step =  52, eigenelements in eig[ 53], ind_ev =  13
- # 14,    nd at p â‰ˆ -0.06235903 âˆˆ (-0.06238787, -0.06235903), |Î´p|=3e-05, [converged], Î´ = (-2,  0), step =  54, eigenelements in eig[ 55], ind_ev =   9
- # 15,    nd at p â‰ˆ -0.05358077 âˆˆ (-0.05404312, -0.05358077), |Î´p|=5e-04, [converged], Î´ = (-2,  0), step =  56, eigenelements in eig[ 57], ind_ev =   7
- # 16,    nd at p â‰ˆ -0.02494422 âˆˆ (-0.02586444, -0.02494422), |Î´p|=9e-04, [converged], Î´ = (-2,  0), step =  60, eigenelements in eig[ 61], ind_ev =   5
- # 17,    nd at p â‰ˆ -0.00484022 âˆˆ (-0.00665356, -0.00484022), |Î´p|=2e-03, [converged], Î´ = (-2,  0), step =  63, eigenelements in eig[ 64], ind_ev =   3
- # 18,    nd at p â‰ˆ +0.00057801 âˆˆ (-0.00122418, +0.00057801), |Î´p|=2e-03, [converged], Î´ = ( 5,  0), step =  64, eigenelements in eig[ 65], ind_ev =   6
- # 19,    nd at p â‰ˆ +0.00320921 âˆˆ (+0.00141327, +0.00320921), |Î´p|=2e-03, [converged], Î´ = (10,  0), step =  65, eigenelements in eig[ 66], ind_ev =  16
Fold points:
- #  1, fold at p â‰ˆ -0.21528694 âˆˆ (-0.21528694, -0.21528694), |Î´p|=-1e+00, [    guess], Î´ = ( 0,  0), step =  24, eigenelements in eig[ 24], ind_ev =   0</code></pre><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 3 June 2024 17:38">Monday 3 June 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
