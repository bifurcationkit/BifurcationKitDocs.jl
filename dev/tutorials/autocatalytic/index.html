<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>🟤 Modulated fronts in 1d autocatalytic model (Manual) · Bifurcation Analysis in Julia</title><meta name="title" content="🟤 Modulated fronts in 1d autocatalytic model (Manual) · Bifurcation Analysis in Julia"/><meta property="og:title" content="🟤 Modulated fronts in 1d autocatalytic model (Manual) · Bifurcation Analysis in Julia"/><meta property="twitter:title" content="🟤 Modulated fronts in 1d autocatalytic model (Manual) · Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../../educational/">Educational introduction</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../../hybrid/">AutoSwitch</a></li><li><a class="tocitem" href="../../ANM/">ANM</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../../cusp/">Cusp</a></li><li><a class="tocitem" href="../../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../../bautin/">Bautin</a></li><li><a class="tocitem" href="../../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../../pd/">Period-doubling</a></li><li><a class="tocitem" href="../../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>🟤 Modulated fronts in 1d autocatalytic model (Manual)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>🟤 Modulated fronts in 1d autocatalytic model (Manual)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/tutorials/autocatalytic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modulated-fronts-in-1d-autocatalytic-model-(Manual)"><a class="docs-heading-anchor" href="#Modulated-fronts-in-1d-autocatalytic-model-(Manual)">🟤 Modulated fronts in 1d autocatalytic model (Manual)</a><a id="Modulated-fronts-in-1d-autocatalytic-model-(Manual)-1"></a><a class="docs-heading-anchor-permalink" href="#Modulated-fronts-in-1d-autocatalytic-model-(Manual)" title="Permalink"></a></h1><ul><li><a href="#Modulated-fronts-in-1d-autocatalytic-model-(Manual)">🟤 Modulated fronts in 1d autocatalytic model (Manual)</a></li><li class="no-marker"><ul><li><a href="#Freezing-method">Freezing method</a></li><li><a href="#Continuation-of-front-solutions">Continuation of front solutions</a></li><li><a href="#Branch-of-modulated-fronts">Branch of modulated fronts</a></li><li><a href="#References">References</a></li></ul></li></ul><p>We consider the model <sup class="footnote-reference"><a id="citeref-Balmforth" href="#footnote-Balmforth">[Balmforth]</a></sup><sup class="footnote-reference"><a id="citeref-Malham" href="#footnote-Malham">[Malham]</a></sup> which is also treated in <sup class="footnote-reference"><a id="citeref-Beyn" href="#footnote-Beyn">[Beyn]</a></sup></p><p class="math-container">\[\begin{array}{l}
u_{t}=a u_{x x}-u f(v), \quad a&gt;0, u, v: \mathbb{R} \rightarrow \mathbb{R} \\
v_{t}=v_{x x}+u f(v)
\end{array}\]</p><p>where <span>$f(u) = u^m 1_{u\geq 0}$</span>. We chose the boundary conditions</p><p class="math-container">\[\left(u_{-}, v_{-}\right)=(0,1),\quad \left(u_{+}, v_{+}\right)=(1,0)\tag{BC}.\]</p><p>It is straightforward to implement this problem as follows:</p><pre><code class="language-julia hljs">using Revise
using ForwardDiff, SparseArrays
using BifurcationKit, LinearAlgebra, Plots
const BK = BifurcationKit

# supremum norm
f(u) = u^9 # solutions are positive, so remove the heaviside

# helper function to plot solutions
function plotsol!(x; k...)
	u = @view x[1:end÷2]
	v = @view x[end÷2:end]
	plot!(u; label=&quot;u&quot;, k...)
	plot!(v; label=&quot;v&quot;, k...)
end
plotsol(x; k...) = (plot();plotsol!(x; k...))

# encode the nonlinearity
@views function NL!(dest, U, p, t = 0.)
	N = p.N
	u = U[1:N]
	v = U[N+1:2N]
	dest[1:N]    .= -u .* f.(v)
	dest[N+1:2N] .=  -dest[1:N]#u .* f.(v)
	return dest
end

# function for the differential with specific boundary conditions
# for fronts
@views function applyD_add!(f, U, p, a)
	uL = 0; uR = 1; vL = 1; vR = 0
	n = p.N
	u = U[1:n]
	v = U[n+1:2n]

	c1 = 1 / (2p.h)
	f[1]   += a * (uL      - u[2] ) * c1
	f[end] += a * (v[n-1]  - vR   ) * c1

	f[n]   += a * (u[n-1] - uR  ) * c1
	f[n+1] += a * (    vL - v[2] ) * c1

	@inbounds for i=2:n-1
		  f[i] += a * (u[i-1] - u[i+1]) * c1
		f[n+i] += a * (v[i-1] - v[i+1]) * c1
	end
	return f
end

# function which encodes the full PDE
@views function Fcat!(f, U, p, t = 0)
	uL = 0; uR = 1; vL = 1; vR = 0
	n = p.N
	# nonlinearity
	NL!(f, U, p)

	# Dirichlet boundary conditions
	h2 = p.h * p.h
	c1 = 1 / h2

	u = U[1:n]
	v = U[n+1:2n]

	f[1]   += p.a * (uL      - 2u[1] + u[2] ) * c1
	f[end] +=       (v[n-1]  - 2v[n] + vR   ) * c1

	f[n]   += p.a * (u[n-1] - 2u[n] +  uR  ) * c1
	f[n+1] +=       (vL - 2v[1] + v[2] ) * c1

	@inbounds for i=2:n-1
		  f[i] += p.a * (u[i-1] - 2u[i] + u[i+1]) * c1
		f[n+i] +=       (v[i-1] - 2v[i] + v[i+1]) * c1
	end
	return f
end
Jcat(x,p) = sparse(ForwardDiff.jacobian(x -&gt; Fcat!(similar(x), x, p), x))</code></pre><p>We chose the following parameters:</p><pre><code class="language-julia hljs">N = 200
lx = 25.
X = LinRange(-lx,lx, N)
par_cat = (N = N, a = 0.18, h = 2lx/N)

u0 = @. (tanh(2X)+1)/2
U0 = vcat(u0, 1 .- u0)

# we define a problem to hold the vector field
prob = BifurcationProblem(Fcat!, u0, par_cat, (@optic _.a); J = Jcat)</code></pre><h2 id="Freezing-method"><a class="docs-heading-anchor" href="#Freezing-method">Freezing method</a><a id="Freezing-method-1"></a><a class="docs-heading-anchor-permalink" href="#Freezing-method" title="Permalink"></a></h2><p>The problem may feature fronts, solutions of the form <span>$u(x,t) = \tilde u(x-st)$</span> (same for <span>$v$</span>) for a fixed value of the profile <span>$\tilde u$</span> and the speed <span>$s$</span>. The equation for the front profile is, up to an abuse of notations (we removed the tildes)</p><p class="math-container">\[\begin{array}{l}
0=a u_{\xi\xi}+s\cdot u_{\xi}-u f(v)\\
0=v_{\xi\xi}+s\cdot v_{\xi}+u f(v)
\end{array}\]</p><p>with unknowns <span>$u,v,s$</span>. The front is solution of these equations but it is not uniquely determined because of the phase invariance. Hence, we add the phase condition (see <sup class="footnote-reference"><a id="citeref-Beyn" href="#footnote-Beyn">[Beyn]</a></sup>)</p><p class="math-container">\[0 = \left\langle (u,v), \partial_\xi (u_0,v_0) \right\rangle\]</p><p>where <span>$U_0:=(u_0,v_0)$</span> is some fixed profile. This is easily coded in the following functional</p><pre><code class="language-julia hljs">@views function FcatWave!(out, x, p)
	N = p.N
	U = x[1:end-1]
	Fcat!(out[1:2N], U, p)
	applyD_add!(out[1:2N], U, p, x[end])
	# phase condition
	out[2N+1] = dot(U, p.Du0)
	return out
end
FcatWave(x, p, t = 0) = FcatWave!(similar(x), x, p)
JcatWave(u, p) = sparse(ForwardDiff.jacobian(z -&gt; FcatWave!(similar(z),z,p), u))</code></pre><p>We now define the <span>$U_0$</span> profile</p><pre><code class="language-julia hljs">uold = vcat(u0, (1 .- u0))
Duold = zero(uold); applyD_add!(Duold, uold, par_cat,1)

# update problem parameters for front problem
par_cat_wave = (par_cat..., u0Du0 = dot(uold, Duold), Du0 = Duold, uold = uold)</code></pre><p>Let us find the front using <code>newton</code></p><pre><code class="language-julia hljs"># we define a problem for solving for the wave
probtw = BifurcationProblem(FcatWave!, vcat(U0, -1.), par_cat_wave, (@optic _.a);
	J = JcatWave,
	record_from_solution = (x,p;k...) -&gt; (s = x[end], nrm = norm(x[1:end-1])),
	plot_solution = (x, p; k...) -&gt; plotsol!(x[1:end-1];k...))

front = BK.solve(probtw, Newton(), NewtonPar())
println(&quot;front speed s = &quot;, front.u[end], &quot;, norm = &quot;, front.u[1:end-1] |&gt; norminf)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">front speed s = -0.2627125504927461, norm = 1.0000000000000002</code></pre><pre><code class="language-julia hljs">plotsol(front.u[1:end-1], title=&quot;front solution&quot;)</code></pre><img src="18ac7809.svg" alt="Example block output"/><h2 id="Continuation-of-front-solutions"><a class="docs-heading-anchor" href="#Continuation-of-front-solutions">Continuation of front solutions</a><a id="Continuation-of-front-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-front-solutions" title="Permalink"></a></h2><p>Following <sup class="footnote-reference"><a id="citeref-Malham" href="#footnote-Malham">[Malham]</a></sup>, the modulated fronts are solutions of the following DAE</p><p class="math-container">\[\begin{array}{l}\tag{DAE}
u_{t}=a u_{x x}+s\cdot u_x-u f(v)\\
v_{t}=v_{x x}+s\cdot v_x+u f(v)\\
0 = \left\langle U, \partial_\xi U_0	\right\rangle
\end{array}\]</p><p>which can be written with a PDE <span>$M_aU_t = G(u)$</span> with mass matrix <span>$M_a = (Id, Id, 0)$</span>. We have already written the vector field of (MF) in the function <code>FcatWave</code>.</p><p>Having found a front <span>$U^f$</span>, we can continue it as function of the parameter <span>$a$</span> and detect instabilities. The stability of the front is linked to the eigenelements <span>$(\lambda, V)$</span> solution of the generalized eigenvalue problem:</p><p class="math-container">\[\lambda M_a\cdot V = dG(U^f)\cdot V.\]</p><p>However <code>BifurcationKit</code> does not provide a generalized eigenvalue solver for now, so we devise one:</p><pre><code class="language-julia hljs"># we need  a specific eigensolver
struct EigenWave &lt;: BK.AbstractEigenSolver end

# implementation of the solver for the generalized Eigen problem
function (eig::EigenWave)(Jac, nev; k...)
	N = size(Jac,1)
	B = diagm(vcat(ones(N-1),0))
	F = eigen(Array(Jac), B)
	I = sortperm(F.values, by = real, rev = true)
	nev2 = min(nev, length(I))
	J = findall( abs.(F.values[I]) .&lt; 100000)
	return Complex.(F.values[I[J[1:nev2]]]), Complex.(F.vectors[:, I[J[1:nev2]]]), true, 1
end

optn = NewtonPar(tol = 1e-8, eigsolver = EigenWave())
opt_cont_br = ContinuationPar(p_min = 0.05, p_max = 1., newton_options = optn, ds= -0.001, plot_every_step = 2, detect_bifurcation = 3, nev = 10, n_inversion = 6)
br = continuation(probtw, PALC(), opt_cont_br)
plot(br)</code></pre><img src="a6b735bd.svg" alt="Example block output"/><p>We have detected a Hopf instability in front dynamics, this will give rise of modulated fronts. Let us try to compute them.</p><h2 id="Branch-of-modulated-fronts"><a class="docs-heading-anchor" href="#Branch-of-modulated-fronts">Branch of modulated fronts</a><a id="Branch-of-modulated-fronts-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-of-modulated-fronts" title="Permalink"></a></h2><p>To branch from the Hopf bifurcation point, we just have to pass the mass matrix as follows:</p><pre><code class="language- hljs"># we compute the periodic solutions using Mt time steps and a Trapezoidal time stepper
# note that we pass the parameter massmatrix which
# allows to solver the DAE
Mt = 30
probTP = PeriodicOrbitTrapProblem(M = Mt ;
		massmatrix = spdiagm(0 =&gt; vcat(ones(2N),0.)),
		update_section_every_step = 1,
		# linear solver for the periodic orbit problem
		# OPTIONAL, one could use the default
		jacobian = :BorderedLU)

opts_po_cont = ContinuationPar(dsmin = 0.0001, dsmax = 0.01, ds= -0.001, p_min = 0.05, max_steps = 130, newton_options = optn, nev = 7, tol_stability = 1e-3, detect_bifurcation = 0, plot_every_step = 1)
opts_po_cont = @set opts_po_cont.newton_options.max_iterations = 10
opts_po_cont = @set opts_po_cont.newton_options.tol = 1e-6

br_po = continuation(
	# we want to compute the bifurcated branch from
	# the first Hopf point
	br, 1,
	# arguments for continuation
	opts_po_cont,
	# this is how we pass the method to compute the periodic
	probTP ;
	# OPTIONAL parameters
	# we want to jump on the new branch at phopf + δp
	δp = -0.0025,
	# tangent predictor
	alg = PALC(tangent = Secant(),
			# linear solver specific to PALC
			bls = BorderingBLS(solver = DefaultLS(), check_precision = false)),
	# regular parameters for the continuation
	# a few parameters saved during run
	record_from_solution = (u, p; k...) -&gt; begin
		outt = BK.get_periodic_orbit(p.prob, u, (@set  par_cat_wave.a=p))
		m = maximum(outt.u[end,:])
		return (s = m, period = u[end])
	end,
	# plotting of a section
	plot_solution = (x, p; k...) -&gt; begin
		outt = BK.get_periodic_orbit(p.prob, x, (@set  par_cat_wave.a=p.p))
		plot!(outt.t, outt.u[end, :]; label = &quot;&quot;, subplot=3)
		plot!(br, subplot=1)
	end,
	# print the Floquet exponent
	finalise_solution = (z, tau, step, contResult; k...) -&gt; begin
		true
	end,
	plot = true,
	normC = norminf)

plot(br);plot!(br_po, label = &quot;modulated fronts&quot;)</code></pre><p>Let us plot one modulated front:</p><pre><code class="language- hljs">modfront = get_periodic_orbit(br_po, length(br_po))
plot(plot(modfront.t, modfront.u[end,:], xlabel = &quot;t&quot;, ylabel = &quot;s&quot;, label = &quot;&quot;),
	contour(modfront.t, X, modfront.u[1:N,:], color = :viridis, xlabel = &quot;t&quot;, title = &quot;u for a = $(round(br_po.sol[length(br_po)].p,digits=4))&quot;, fill = true, ylims=(-10,10)))</code></pre><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Balmforth"><a class="tag is-link" href="#citeref-Balmforth">Balmforth</a><blockquote><p>N. J. Balmforth, R. V. Craster, and S. J. A. Malham. Unsteady fronts in an autocatalytic system. R. Soc. Lond. Proc. Ser. A Math. Phys. Eng. Sci., 455(1984):1401–1433, 1999.</p></blockquote></li><li class="footnote" id="footnote-Malham"><a class="tag is-link" href="#citeref-Malham">Malham</a><blockquote><p>S. J. A. Malham and M. Oliver. Accelerating fronts in autocatalysis. R. Soc. Lond. Proc. Ser. A Math. Phys. Eng. Sci., 456(1999):1609–1624, 2000.</p></blockquote></li><li class="footnote" id="footnote-Beyn"><a class="tag is-link" href="#citeref-Beyn">Beyn</a><blockquote><p>Beyn, Wolf-Jürgen, and Vera Thümmler. “Phase Conditions, Symmetries and PDE Continuation.” In Numerical Continuation Methods for Dynamical Systems: Path Following and Boundary Value Problems Springer Netherlands, 2007. https://doi.org/10.1007/978-1-4020-6356-5_10.</p></blockquote></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 28 December 2024 12:22">Saturday 28 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
