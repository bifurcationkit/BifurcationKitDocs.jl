<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ğŸŸ  3d Swift-Hohenberg equation, Finite differences Â· Bifurcation Analysis in Julia</title><meta name="title" content="ğŸŸ  3d Swift-Hohenberg equation, Finite differences Â· Bifurcation Analysis in Julia"/><meta property="og:title" content="ğŸŸ  3d Swift-Hohenberg equation, Finite differences Â· Bifurcation Analysis in Julia"/><meta property="twitter:title" content="ğŸŸ  3d Swift-Hohenberg equation, Finite differences Â· Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../../educational/">Educational introduction</a></li><li><a class="tocitem" href="../../overview/">Overview</a></li><li><a class="tocitem" href="../../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../../waveEigen/">Eigen Solvers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../../hybrid/">AutoSwitch</a></li><li><a class="tocitem" href="../../ANM/">ANM</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../../cusp/">Cusp</a></li><li><a class="tocitem" href="../../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../../bautin/">Bautin</a></li><li><a class="tocitem" href="../../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../../pd/">Period-doubling</a></li><li><a class="tocitem" href="../../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../../BifurcationDiagram/">Automatic Bifurcation diagram</a></li><li><a class="tocitem" href="../../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../../debug/">Debugging</a></li><li><a class="tocitem" href="../../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>ğŸŸ  3d Swift-Hohenberg equation, Finite differences</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ğŸŸ  3d Swift-Hohenberg equation, Finite differences</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/tutorials/tutorialsSH3d.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="sh3d"><a class="docs-heading-anchor" href="#sh3d">ğŸŸ  3d Swift-Hohenberg equation, Finite differences</a><a id="sh3d-1"></a><a class="docs-heading-anchor-permalink" href="#sh3d" title="Permalink"></a></h1><ul><li><a href="#sh3d">ğŸŸ  3d Swift-Hohenberg equation, Finite differences</a></li><li class="no-marker"><ul><li><a href="#Plotting-with-Makie">Plotting with Makie</a></li><li><a href="#Setting-up-the-problem">Setting up the problem</a></li><li><a href="#Choice-of-linear-solver">Choice of linear solver</a></li><li><a href="#Continuation-and-bifurcation-points">Continuation and bifurcation points</a></li><li><a href="#Automatic-branch-switching">Automatic branch switching</a></li></ul></li></ul><div class="admonition is-info" id="Why-this-example?-5d8ad38971e575fe"><header class="admonition-header">Why this example?<a class="admonition-anchor" href="#Why-this-example?-5d8ad38971e575fe" title="Permalink"></a></header><div class="admonition-body"><p>This example is challenging because we cannot employ the easy to use <code>\</code> sparse linear solver which takes too much time/memory to do the LU decomposition. Hence, one has to be tricky to devise a preconditioned linear solver that does not explode the memory budget. But then, one has to also devise a specific eigensolver. This is done in this tutorial. It also shows how this can be used for automatic branch switching. Hence, if you are not happy with the linear / eigen solvers in <code>BifurcationKit.jl</code>, this is perhaps the example you are looking for.</p></div></div><p>We look at the following PDE on a 3d domain, <em>e.g.</em> a cube:</p><p class="math-container">\[-(I+\Delta)^2 u+l\cdot u +\nu u^2-u^3 = 0\tag{E}\]</p><p>with Neumann boundary conditions. We use a Sparse Matrix to express the operator <span>$L_1\equiv(I+\Delta)^2$</span>. However, compared to the 2d case (see <a href="../tutorials2/#sh2dfd">2d Swift-Hohenberg equation: snaking</a>), we cannot use directly <code>\</code> to solve linear systems because the LU dÃ©composition is a bit slow, it uses a lot of memory.</p><p>We start by defining the associated functional to encode (E).</p><pre><code class="language-julia hljs">using Revise, KrylovKit
using GLMakie # must be imported before BifurcationKit to trigger some imports
using BifurcationKit
using LinearAlgebra, SparseArrays, LinearMaps
const BK = BifurcationKit

function Laplacian3D(Nx, Ny, Nz, lx, ly, lz)
    speye(n) = sparse(I, n, n)
    hx = 2lx/Nx
    hy = 2ly/Ny
    hz = 2lz/Nz
    D2x = spdiagm(0 =&gt; -2ones(Nx), 1 =&gt; ones(Nx-1), -1 =&gt; ones(Nx-1) ) / hx^2
    D2y = spdiagm(0 =&gt; -2ones(Ny), 1 =&gt; ones(Ny-1), -1 =&gt; ones(Ny-1) ) / hy^2
    D2z = spdiagm(0 =&gt; -2ones(Nz), 1 =&gt; ones(Nz-1), -1 =&gt; ones(Nz-1) ) / hz^2

    D2x[1,1] = -1/hx^2
    D2x[end,end] = -1/hx^2

    D2y[1,1] = -1/hy^2
    D2y[end,end] = -1/hy^2

    D2z[1,1] = -1/hz^2
    D2z[end,end] = -1/hz^2

    D2xsp = sparse(D2x)
    D2ysp = sparse(D2y)
    D2zsp = sparse(D2z)

    _A = kron(speye(Ny), D2xsp) + kron(D2ysp, speye(Nx))
    A = kron(speye(Nz), _A) + kron(kron(D2zsp, speye(Ny)), speye(Nx))
    return A, D2x
end

# main functional
function F_sh(u, p)
	(;l, Î½, L1) = p
	return -(L1 * u) .+ (l .* u .+ Î½ .* u.^2 .- u.^3)
end

# differential of the functional
function dF_sh(u, p, du)
	(;l, Î½, L1) = p
	return -(L1 * du) .+ (l .+ 2 .* Î½ .* u .- 3 .* u.^2) .* du
end

# various differentials
d2F_sh(u, p, dx1, dx2) = (2 .* p.Î½ .* dx2 .- 6 .* dx2 .* u) .* dx1
d3F_sh(u, p, dx1, dx2, dx3) = (-6 .* dx2 .* dx3) .* dx1

# these types are useful to switch to GPU
TY = Float64
AF = Array{TY}</code></pre><h2 id="Plotting-with-Makie"><a class="docs-heading-anchor" href="#Plotting-with-Makie">Plotting with Makie</a><a id="Plotting-with-Makie-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-with-Makie" title="Permalink"></a></h2><p>In most tutorials, we have used <code>Plots.jl</code> for the figures. However, it appears that <code>Makie.jl</code> is more convenient for 3d plots. We thus define the following convenience functions to display the solutions of (E).</p><pre><code class="language-julia hljs">contour3dMakie(x; k...) = GLMakie.contour(x;  k...)
contour3dMakie(x::AbstractVector; k...) = contour3dMakie(reshape(x,Nx,Ny,Nz); k...)

contour3dMakie(ax, x; k...) = (GLMakie.contour!(ax, x;  k...))
contour3dMakie(ax, x::AbstractVector; k...) = contour3dMakie(ax, reshape(x,Nx,Ny,Nz); k...)

contour3dMakie!(ax, x; k...) = (GLMakie.contour!(ax, x;  k...))
contour3dMakie!(ax, x::AbstractVector; k...) = contour3dMakie!(ax, reshape(x,Nx,Ny,Nz); k...)</code></pre><h2 id="Setting-up-the-problem"><a class="docs-heading-anchor" href="#Setting-up-the-problem">Setting up the problem</a><a id="Setting-up-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-the-problem" title="Permalink"></a></h2><p>We provide the parameters defining the PDE:</p><pre><code class="language-julia hljs">Nx = Ny = Nz = 22; N = Nx*Ny*Nz
lx = ly = lz = pi

X = -lx .+ 2lx/(Nx) * collect(0:Nx-1)
Y = -ly .+ 2ly/(Ny) * collect(0:Ny-1)
Z = -lz .+ 2lz/(Nz) * collect(0:Nz-1)

# initial guess for newton
sol0 = [(cos(x) .* cos(y )) for x in X, y in Y, z in Z]
sol0 .= sol0 .- minimum(vec(sol0))
sol0 ./= maximum(vec(sol0))
sol0 .*= 1.7

# parameters for PDE
Î”, D2x = Laplacian3D(Nx, Ny, Nz, lx, ly, lz);
L1 = (I + Î”)^2;
par = (l = 0.1, Î½ = 1.2, L1 = L1);</code></pre><h2 id="Choice-of-linear-solver"><a class="docs-heading-anchor" href="#Choice-of-linear-solver">Choice of linear solver</a><a id="Choice-of-linear-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Choice-of-linear-solver" title="Permalink"></a></h2><p>Let us run a quick benchmark to evaluate the direct linear solvers:</p><pre><code class="language-julia hljs">julia&gt; @time cholesky(Symmetric(L1)) \ vec(sol0);
  0.069329 seconds (67 allocations: 85.233 MiB)

julia&gt; @time lu(L1) \ vec(sol0);
  0.193397 seconds (91 allocations: 225.885 MiB, 0.81% gc time)

julia&gt; @time qr(L1) \ vec(sol0);
  0.652569 seconds (206 allocations: 988.797 MiB, 1.44% gc time)</code></pre><p>Hence, <code>cholesky</code> is the big winner but it requires a positive matrix so let&#39;s see how to do that.</p><p>As said in the introduction, the LU linear solver does not scale well with dimension <span>$N$</span>. Hence, we do something else. We note that the matrix <span>$L_1$</span> is hermitian positive and use it as a preconditioner. Thus, we pre-factorize it using a Cholesky decomposition:</p><pre><code class="language-julia hljs">Pr = cholesky(Symmetric(L1));
using SuiteSparse
# we need this &quot;hack&quot; to be able to use Pr as a preconditioner.
LinearAlgebra.ldiv!(o::Vector, P::SuiteSparse.CHOLMOD.Factor{Float64}, v::Vector) = o .= (P \ v)

# rtol must be small enough to pass the Fold points and to get precise eigenvalues
# we know that the jacobian is symmetric so we tell the solver
ls = GMRESKrylovKit(verbose = 0, rtol = 1e-9, maxiter = 150, Pl = Pr)</code></pre><p>Let&#39;s try this on a Krylov-Newton computation to refine the guess <code>sol0</code>:</p><pre><code class="language-julia hljs">prob = BifurcationProblem(F_sh, AF(vec(sol0)), par, (@optic _.l),
	J = (x, p) -&gt; (dx -&gt; dF_sh(x, p, dx)),
	plot_solution = (ax, x, p; ax1) -&gt; contour3dMakie(ax, x),
	issymmetric = true, # so we dont need to provide the adjoint (normal form)
	record_from_solution = (x, p; k...) -&gt; (n2 = norm(x), n8 = norm(x, 8)))

optnew = NewtonPar(verbose = true, tol = 1e-8, max_iterations = 20, linsolver = ls)
sol_hexa = @time BK.solve(prob, Newton(), optnew)</code></pre><p>which gives</p><pre><code class="language-julia hljs">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Newton step         residual     linear iterations  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚       0     â”‚       2.6003e+02     â”‚        0       â”‚
â”‚       1     â”‚       1.5414e+02     â”‚       25       â”‚
â”‚       2     â”‚       2.6040e+02     â”‚       21       â”‚
â”‚       3     â”‚       7.3531e+01     â”‚       21       â”‚
â”‚       4     â”‚       2.0513e+01     â”‚       23       â”‚
â”‚       5     â”‚       6.4608e+00     â”‚       18       â”‚
â”‚       6     â”‚       1.3743e+00     â”‚       18       â”‚
â”‚       7     â”‚       1.7447e-01     â”‚       17       â”‚
â”‚       8     â”‚       4.0924e-03     â”‚       17       â”‚
â”‚       9     â”‚       2.4048e-06     â”‚       17       â”‚
â”‚      10     â”‚       1.8389e-10     â”‚       17       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  0.472765 seconds (13.97 k allocations: 134.073 MiB, 1.91% gc time, 0.00% compilation time)</code></pre><p>and <code>contour3dMakie(sol_hexa.u)</code> produces</p><p><img src="../sh3dhexa.png" alt/></p><h2 id="Continuation-and-bifurcation-points"><a class="docs-heading-anchor" href="#Continuation-and-bifurcation-points">Continuation and bifurcation points</a><a id="Continuation-and-bifurcation-points-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-and-bifurcation-points" title="Permalink"></a></h2><p>We now switch gears and compute the stability of the trivial solution <span>$u=0$</span>. We will then branch from the detected bifurcation points. However, we wish to show an example of computation of eigenvalues based on a custom preconditioned Shift-Invert strategy.</p><p>We thus define our eigensolver based on the previously defined pre-conditioned linear solver <code>ls</code>:</p><pre><code class="language-julia hljs"># structure to hold eigensolver
struct SH3dEig{Ts, TÏƒ} &lt;: BK.AbstractEigenSolver
	# linear solver used for Shift-Invert strategy
	ls::Ts
	# shift of the linear operator
	Ïƒ::TÏƒ
end

# function to extract eigenvectors, used for automatic branch switching
BifurcationKit.geteigenvector(eigsolve::SH3dEig, vecs, n::Union{Int, Array{Int64,1}}) = vecs[n]

# implementation of Shift-invert strategy
function (sheig::SH3dEig)(J, nev::Int; verbosity = 0, kwargs...)
	Ïƒ = sheig.Ïƒ
	nv = 30
	Jshift = du -&gt; J(du) .- Ïƒ .* du
	A = du -&gt; sheig.ls(Jshift, du)[1]
	# we adapt the krylov dimension as function of the requested eigenvalue number
	vals, vec, info = KrylovKit.eigsolve(A, AF(rand(Nx*Ny*Nz)), nev, :LM;
		 tol = 1e-12, maxiter = 20, verbosity = verbosity, ishermitian = true,
		 krylovdim = max(nv, nev + nv))
	vals2 = 1 ./vals .+ Ïƒ
	Ind = sortperm(vals2, by = real, rev = true)
	return vals2[Ind], vec[Ind], true, info.numops
end</code></pre><p>We can then declare our eigensolver and pass it to the newton parameters</p><pre><code class="language-julia hljs">eigSH3d = SH3dEig((@set ls.rtol = 1e-9), 0.1)
@reset optnew.eigsolver = eigSH3d</code></pre><p>We are now ready to perform continuation and detection of bifurcation points:</p><pre><code class="language-julia hljs">optcont = ContinuationPar(dsmin = 0.0001, dsmax = 0.005, ds= -0.001, p_max = 0.15,
	p_min = -.1, newton_options = setproperties(optnew; tol = 1e-9, max_iterations = 15),
	max_steps = 146, detect_bifurcation = 3, nev = 15, n_inversion = 4, plot_every_step = 1)

br = continuation( re_make(prob, u0 = zeros(N)),
  # we use a particular bordered linear solver to
  # take advantage of our specific linear solver
  PALC(bls = BorderingBLS(solver = optnew.linsolver, check_precision = false)),
  optcont;
  normC = x -&gt; norm(x, Inf),
  plot = true, verbosity = 3)</code></pre><p>The following result shows the detected bifurcation points (its takes ~300s)</p><pre><code class="language-julia hljs">julia&gt; br
Branch number of points: 34
Branch of Equilibrium
Parameters l from 0.1 to -0.1
Bifurcation points:
 (ind_ev = index of the bifurcating eigenvalue e.g. `br.eig[idx].eigenvals[ind_ev]`)
- #  1,    bp at l â‰ˆ +0.06243495 âˆˆ (+0.06243495, +0.06287689), |Î´p|=4e-04, [converged], Î´ = (-1,  0), step =   8, eigenelements in eig[  9], ind_ev =  10
- #  2,    nd at l â‰ˆ +0.06069653 âˆˆ (+0.06069653, +0.06069826), |Î´p|=2e-06, [converged], Î´ = (-6,  0), step =   9, eigenelements in eig[ 10], ind_ev =   9
- #  3,    nd at l â‰ˆ -0.00007046 âˆˆ (-0.00007046, +0.00015051), |Î´p|=2e-04, [converged], Î´ = (-3,  0), step =  18, eigenelements in eig[ 19], ind_ev =   3</code></pre><p>We get the following plot during computation:</p><p><img src="../sh3dfrontleft.png" alt/></p><div class="admonition is-success" id="Tip-95e24f263737f877"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-95e24f263737f877" title="Permalink"></a></header><div class="admonition-body"><p>We don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><h2 id="Automatic-branch-switching"><a class="docs-heading-anchor" href="#Automatic-branch-switching">Automatic branch switching</a><a id="Automatic-branch-switching-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-branch-switching" title="Permalink"></a></h2><div class="admonition is-warning" id="Computation-time-cf35614e9f2765f9"><header class="admonition-header">Computation time<a class="admonition-anchor" href="#Computation-time-cf35614e9f2765f9" title="Permalink"></a></header><div class="admonition-body"><p>The following computation takes ~1.5h</p></div></div><p>We can use <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/branchswitching/">Branch switching</a> to compute the different branches emanating from the bifurcation points. For example, the following code will perform automatic branch switching from the last bifurcation point of <code>br</code>. Note that this bifurcation point is 3d.</p><pre><code class="language-julia hljs">br1 = @time continuation(br, 3, setproperties(optcont; save_sol_every_step = 10,
	detect_bifurcation = 0, p_max = 0.1, plot_every_step = 5, dsmax = 0.02);
	plot = true, verbosity = 3,
	# to set initial point on the branch
	Î´p = 0.01,
	# remove display of deflated newton iterations
	verbosedeflation = false,
	alg = PALC(tangent = Bordered(), bls = BorderingBLS(solver = optnew.linsolver, check_precision = false)),
	normC = norminf)</code></pre><p>We can then plot the branches using <code>BK.plot(br, br1...)</code> where green (resp. red) means stable (resp. unstable) solution.</p><p><img src="../sh3dbranches.png" alt/></p><p>There are 19 banches that were discovered. You can plot the solutions on the branches using</p><pre><code class="language-julia hljs">fig = Figure(resolution = (1200, 900))
	for i=1:length(br1)
		ix = div(i,5)+1; iy = i%5+1
		@show i, ix, iy
		ax = Axis3(fig[ix, iy], title = &quot;$i&quot;, aspect = (1, 1, 1))
		hidedecorations!(ax, grid=false)
		contour3dMakie!(ax, br1[i].sol[2].x)
		ax.protrusions = (0, 0, 0, 10)
	end
	display(fig)</code></pre><p><img src="../sh3dallSols.png" alt/></p><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 23 November 2025 10:24">Sunday 23 November 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
