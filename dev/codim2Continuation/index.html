<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fold / Hopf Continuation (codim 2) · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Nonlinear Equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose Continuation</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li></ul></li><li><a class="tocitem" href="../EventCallback/">Event Handling and Callback</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox" checked/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Bifurcations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li class="is-active"><a class="tocitem" href>Fold / Hopf Continuation (codim 2)</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Fold-continuation"><span>Fold continuation</span></a></li><li><a class="tocitem" href="#Hopf-continuation"><span>Hopf continuation</span></a></li><li><a class="tocitem" href="#Newton-refinement"><span>Newton refinement</span></a></li><li><a class="tocitem" href="#Codim-2-continuation"><span>Codim 2 continuation</span></a></li><li><a class="tocitem" href="#Advanced-use"><span>Advanced use</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaceLS/">Linear/Eigen Solvers</a></li><li><a class="tocitem" href="../interfacePred/">Predictor/Corrector</a></li><li><a class="tocitem" href="../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functionalities</a></li><li><a class="is-disabled">Bifurcations</a></li><li class="is-active"><a href>Fold / Hopf Continuation (codim 2)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fold / Hopf Continuation (codim 2)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/master/docs/src/codim2Continuation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fold-/-Hopf-Continuation"><a class="docs-heading-anchor" href="#Fold-/-Hopf-Continuation">Fold / Hopf Continuation</a><a id="Fold-/-Hopf-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Fold-/-Hopf-Continuation" title="Permalink"></a></h1><p>For this to work best, it is necessary to have an analytical expression for the jacobian. See the tutorial <a href="../tutorials/tutorials1/#Temperature-model-(Simplest-example)">Temperature model (Simplest example)</a> for more details.</p><p>A quite complete example for detection of codim 2 bifurcations of equilibria is <a href="../tutorials/ode/tutorialCO/#CO-oxydation-(codim-2)">CO-oxydation (codim 2)</a> although it is for ODEs.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>In this page, we explain how to perform continuation of Fold / Hopf points and detect the associated bifurcations.</p><h3 id="List-of-detected-codim-2-bifurcation-points"><a class="docs-heading-anchor" href="#List-of-detected-codim-2-bifurcation-points">List of detected codim 2 bifurcation points</a><a id="List-of-detected-codim-2-bifurcation-points-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-detected-codim-2-bifurcation-points" title="Permalink"></a></h3><table><tr><th style="text-align: right">Bifurcation</th><th style="text-align: right">index used</th></tr><tr><td style="text-align: right">Bogdanov-Takens</td><td style="text-align: right">bt</td></tr><tr><td style="text-align: right">Bautin</td><td style="text-align: right">gh</td></tr><tr><td style="text-align: right">Cusp</td><td style="text-align: right">cusp</td></tr></table><p>In a nutshell, all you have to do (see below) is to call <code>continuation(F, J, br, ind_bif)</code> to continue the bifurcation point stored in <code>br.specialpoint[ind_bif]</code> and set proper options. </p><h2 id="Fold-continuation"><a class="docs-heading-anchor" href="#Fold-continuation">Fold continuation</a><a id="Fold-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Fold-continuation" title="Permalink"></a></h2><p>The continuation of Fold bifurcation points is based on a <strong>Minimally Augmented</strong><sup class="footnote-reference"><a id="citeref-Govaerts" href="#footnote-Govaerts">[Govaerts]</a></sup> formulation which is an efficient way to detect singularities. The continuation of Fold points is based on the formulation <span>$G(u,p) = (F(u,p), g(u,p))\in\mathbb R^{n+1}$</span> where the test function <span>$g$</span> is solution of</p><p class="math-container">\[\left[\begin{array}{cc}
dF(u,p) &amp; w \\
v^{\top} &amp; 0
\end{array}\right]\left[\begin{array}{c}
r \\
g(u,p)
\end{array}\right]=\left[\begin{array}{c}0_{n} \\1\end{array}\right]\quad\quad (M_f)\]</p><p>where <span>$w,v$</span> are chosen in order to have a non-singular matrix <span>$(M_f)$</span>. More precisely, <span>$v$</span> (resp. <span>$w$</span>) should be close to a null vector of <code>dF(u,p)</code> (resp. <code>dF(u,p)&#39;</code>). During continuation, the vectors <span>$w,v$</span> are updated so that the matrix <span>$(M_f)$</span> remains non-singular ; this is controlled with the argument <code>updateMinAugEveryStep</code> (see below).</p><blockquote><p>note that there are very simplified calls for this, see <strong>Newton refinement</strong> below. In particular, you don&#39;t need to set up the Fold Minimally Augmented problem yourself. This is done in the background.</p></blockquote><div class="admonition is-warning"><header class="admonition-header">Linear Method</header><div class="admonition-body"><p>You can pass the bordered linear solver to solve <span>$(M_f)$</span> using the option <code>bdlinsolver</code> (see below). Note that the choice <code>bdlinsolver = BorderingBLS()</code> can lead to singular systems. Indeed, in this case, <span>$(M_f)$</span> is solved by inverting <code>dF(u,p)</code> which is singular at Fold points.</p></div></div><h2 id="Hopf-continuation"><a class="docs-heading-anchor" href="#Hopf-continuation">Hopf continuation</a><a id="Hopf-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Hopf-continuation" title="Permalink"></a></h2><p>The continuation of Fold bifurcation points is based on a <strong>Minimally Augmented</strong> (see <sup class="footnote-reference"><a id="citeref-Govaerts" href="#footnote-Govaerts">[Govaerts]</a></sup> p. 87) formulation which is an efficient way to detect singularities. The continuation of Hopf points is based on the formulation <span>$G(u,\omega,p) = (F(u,\omega,p), g(u,\omega,p))\in\mathbb R^{n+2}$</span> where the test function <span>$g$</span> is solution of</p><p class="math-container">\[\left[\begin{array}{cc}
dF(u,p)-i\omega I_n &amp; w \\
v^{\top} &amp; 0
\end{array}\right]\left[\begin{array}{c}
r \\
g(u,\omega,p)
\end{array}\right]=\left[\begin{array}{c}
0_{n} \\
1
\end{array}\right]\quad\quad (M_h)\]</p><p>where <span>$w,v$</span> are chosen in order to have a non-singular matrix <span>$(M_h)$</span>. More precisely, <span>$w$</span> (resp. <span>$v$</span>) should be a left (resp. right) approximate null vector of <span>$dF(u,p)-i\omega I_n$</span>. During continuation, the vectors <span>$w,v$</span> are updated so that the matrix <span>$(M_h)$</span> remains non-singular ; this is controlled with the argument <code>updateMinAugEveryStep</code> (see below).</p><blockquote><p>note that there are very simplified calls to this, see <strong>Newton refinement</strong> below. In particular, you don&#39;t need to set up the Hopf Minimally Augmented problem yourself. This is done in the background.</p></blockquote><div class="admonition is-warning"><header class="admonition-header">Linear Method</header><div class="admonition-body"><p>You can pass the bordered linear solver to solve <span>$(M_h)$</span> using the option <code>bdlinsolver</code> (see below). Note that the choice <code>bdlinsolver = BorderingBLS()</code> can lead to singular systems. Indeed, in this case, <span>$(M_h)$</span> is solved by inverting <code>dF(u,p)-iω I_n</code> which is singular at Hopf points.</p></div></div><h2 id="Newton-refinement"><a class="docs-heading-anchor" href="#Newton-refinement">Newton refinement</a><a id="Newton-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-refinement" title="Permalink"></a></h2><p>Once a Fold/Hopf point has been detected after a call to <code>br, = continuation(...)</code>, it can be refined using <code>newton</code> iterations. Let us say that <code>ind_bif</code> is the index in <code>br.specialpoint</code> of a Fold/Hopf point. This guess can be refined as follows:</p><pre><code class="language-julia hljs">outfold, hist, flag =  newton(F, J, br::AbstractBranchResult, ind_bif::Int; 
	issymmetric = false, Jᵗ = nothing, d2F = nothing, 
	normN = norm, options = br.contparams.newtonOptions, 
	bdlinsolver = BorderingBLS(options.linsolver),
	startWithEigen = false, kwargs...)</code></pre><p>where <code>par</code> is the set of parameters used in the call to <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> to compute <code>br</code>. For the options parameters, we refer to <a href="../library/#Newton">Newton</a>.</p><p>It is important to note that for improved performances, a function implementing the expression of the <strong>hessian</strong> should be provided. This is by far the fastest. Reader interested in this advanced usage should look at the code <code>example/chan.jl</code> of the tutorial <a href="../tutorials/tutorials1/#Temperature-model-(Simplest-example)">Temperature model (Simplest example)</a>. </p><h2 id="Codim-2-continuation"><a class="docs-heading-anchor" href="#Codim-2-continuation">Codim 2 continuation</a><a id="Codim-2-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Codim-2-continuation" title="Permalink"></a></h2><p>To compute the codim 2 curve of Fold/Hopf points, one can call <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> with the following options</p><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation" href="#BifurcationKit.continuation"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuation(F, J, br, ind_bif, lens2)
continuation(F, J, br, ind_bif, lens2, options_cont; startWithEigen, issymmetric, Jᵗ, d2F, d3F, detectCodim2Bifurcation, kwargs...)
</code></pre><p>codim 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold/Hopf point into a curve of Fold/Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p) -&gt;	F(x, p)</code> where <code>p</code> is a set of parameters</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>br</code> results returned after a call to <a href="../library/#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li><li><code>lens2</code> parameters used for the vector field</li><li><code>options_cont = br.contparams</code> arguments to be passed to the regular <a href="../library/#Library-Continuation">continuation</a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>issymmetric</code> whether the Jacobian is Symmetric (for Fold)</li><li><code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose</li><li><code>d2F = (x, p, v1, v2) -&gt; d2F(x, p, v1, v2)</code> this is the hessian of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2)</code>. This helps solving the linear problem associated to the minimally augmented formulation.</li><li><code>d3F = (x, p, v1, v2, v3) -&gt; d3F(x, p, v1, v2, v3)</code> this is the third derivative of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2, v3)</code>. This is used to detect <strong>Bautin</strong> bifurcation.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>updateMinAugEveryStep</code> update vectors <code>a,b</code> in Minimally Formulation every <code>updateMinAugEveryStep</code> steps</li><li><code>startWithEigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements</li><li><code>detectCodim2Bifurcation ∈ {0,1,2}</code> whether to detect Bogdanov-Takens, Bautin and Cusp. If equals <code>1</code> non precise detection is used. If equals <code>2</code>, a bisection method is used to locate the bifurcations.</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="../library/#Library-Continuation">continuation</a></li></ul><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Hopf point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">Jacobian transpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the Bordered Linear Solver using the option <code>bdlinsolver = MatrixBLS()</code></p></div></div></div></section></article><p>where the options are as above except with have an additional parameter axis <code>lens2</code> which is used to locate the bifurcation points. </p><p>See <a href="../tutorials/tutorials1/#Temperature-model-(Simplest-example)">Temperature model (Simplest example)</a> for an example of use. </p><h2 id="Advanced-use"><a class="docs-heading-anchor" href="#Advanced-use">Advanced use</a><a id="Advanced-use-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-use" title="Permalink"></a></h2><p>Here, we expose the solvers that are used to perform newton refinement or codim 2 continuation in case the above methods fails. This is useful in case it is too involved to expose the linear solver options. An example of advanced use is the continuation of Folds of periodic orbits, see <a href="../tutorials/tutorialsCGL/#Continuation-of-Fold-of-periodic-orbits">Continuation of Fold of periodic orbits</a>.</p><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newtonFold" href="#BifurcationKit.newtonFold"><code>BifurcationKit.newtonFold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newtonFold(F, J, foldpointguess, par, lens, eigenvec, eigenvec_ad, options; normN, issymmetric, Jᵗ, d2F, bdlinsolver, kwargs...)
</code></pre><p>This function turns an initial guess for a Fold point into a solution to the Fold problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is a set of parameters.</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p</em>0) for the Fold point. It should be a <code>BorderedArray</code> as returned by the function <code>FoldPoint</code></li><li><code>par</code> parameters used for the vector field</li><li><code>lens</code> parameter axis used to locate the Fold point.</li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>eigenvec_ad</code> guess for the 0 adjoint eigenvector</li><li><code>options::NewtonPar</code> options for the Newton-Krylov algorithm, see <a href="../library/#BifurcationKit.NewtonPar"><code>NewtonPar</code></a>.</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>issymmetric</code> whether the Jacobian is Symmetric</li><li><code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x, p)[v1, v2]</code>.</li><li><code>normN = norm</code></li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><p><strong>Simplified call</strong></p><p>Simplified call to refine an initial guess for a Fold point. More precisely, the call is as follows</p><pre><code class="nohighlight hljs">newtonFold(F, J, br::AbstractBranchResult, ind_fold::Int, lens::Lens; options = br.contparams.newtonOptions, kwargs...)</code></pre><p>where the optional argument <code>Jᵗ</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine. You can pass newton parameters different from the ones stored in <code>br</code> by using the argument <code>options</code>.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the Bordered Linear Solver using the option <code>bdlinsolver = MatrixBLS()</code></p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newtonHopf" href="#BifurcationKit.newtonHopf"><code>BifurcationKit.newtonHopf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newtonHopf(F, J, hopfpointguess, par, lens, eigenvec, eigenvec_ad, options; Jᵗ, d2F, normN, bdlinsolver, kwargs...)
</code></pre><p>This function turns an initial guess for a Hopf point into a solution to the Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F   = (x, p) -&gt; F(x, p)</code> where <code>p</code> is a set of parameters.</li><li><code>dF  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p</em>0) for the Hopf point. It should a <code>BorderedArray</code> as returned by the function <code>HopfPoint</code>.</li><li><code>par</code> parameters used for the vector field</li><li><code>lens</code> parameter axis used to locate the Hopf point.</li><li><code>eigenvec</code> guess for the  iω eigenvector</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector</li><li><code>options::NewtonPar</code> options for the Newton-Krylov algorithm, see <a href="../library/#BifurcationKit.NewtonPar"><code>NewtonPar</code></a>.</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x, p)[v1, v2]</code>.</li><li><code>normN = norm</code></li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><p><strong>Simplified call:</strong></p><p>Simplified call to refine an initial guess for a Hopf point. More precisely, the call is as follows</p><pre><code class="nohighlight hljs">newtonHopf(F, J, br::AbstractBranchResult, ind_hopf::Int, lens::Lens; Jᵗ = nothing, d2F = nothing, normN = norm, options = br.contparams.newtonOptions, kwargs...)</code></pre><p>where the optional argument <code>Jᵗ</code> is the jacobian transpose and the Hessian is <code>d2F</code>. The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine. You can pass newton parameters different from the ones stored in <code>br</code> by using the argument <code>options</code>.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the Bordered Linear Solver using the option <code>bdlinsolver = MatrixBLS()</code></p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuationFold" href="#BifurcationKit.continuationFold"><code>BifurcationKit.continuationFold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuationFold(F, J, foldpointguess, par, lens1, lens2, eigenvec, eigenvec_ad, options_cont; normC, updateMinAugEveryStep, issymmetric, Jᵗ, d2F, bdlinsolver, kwargs...)
</code></pre><p>Codim 2 continuation of Fold points. This function turns an initial guess for a Fold point into a curve of Fold points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p) -&gt;	F(x, p)</code> where <code>p</code> is a set of parameters</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>foldpointguess</code> initial guess (x<em>0, p1</em>0) for the Fold point. It should be a <code>BorderedArray</code> as returned by the function <code>FoldPoint</code></li><li><code>par</code> set of parameters</li><li><code>lens1</code> parameter axis for parameter 1</li><li><code>lens2</code> parameter axis for parameter 2</li><li><code>eigenvec</code> guess for the 0 eigenvector at p1_0</li><li><code>eigenvec_ad</code> guess for the 0 adjoint eigenvector</li><li><code>options_cont</code> arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>issymmetric</code> whether the Jacobian is Symmetric</li><li><code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose</li><li><code>d2F = (x, p, v1, v2) -&gt; d2F(x, p, v1, v2)</code> this is the hessian of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2)</code>.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>updateMinAugEveryStep</code> update vectors <code>a, b</code> in Minimally Formulation every <code>updateMinAugEveryStep</code> steps</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Simplified call</strong></p><p>The call is as follows</p><pre><code class="nohighlight hljs">continuationFold(F, J, br::AbstractBranchResult, ind_fold::Int64, lens2::Lens, options_cont::ContinuationPar ; kwargs...)</code></pre><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Fold point in <code>br</code> you want to continue.</p><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the Bordered Linear Solver using the option <code>bdlinsolver = MatrixBLS()</code></p></div></div><div class="admonition is-success"><header class="admonition-header">Detection of Bogdanov-Takens and Cusp bifurcations</header><div class="admonition-body"><p>In order to trigger the detection, pass <code>detectEvent = 1,2</code> in <code>options_cont</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuationHopf" href="#BifurcationKit.continuationHopf"><code>BifurcationKit.continuationHopf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>codim 2 continuation of Hopf points. This function turns an initial guess for a Hopf point into a curve of Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p) -&gt;	F(x, p)</code> where <code>p</code> is a set of parameters</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>hopfpointguess</code> initial guess (x<em>0, p1</em>0) for the Hopf point. It should be a <code>Vector</code> or a <code>BorderedArray</code></li><li><code>par</code> set of parameters</li><li><code>lens1</code> parameter axis for parameter 1</li><li><code>lens2</code> parameter axis for parameter 2</li><li><code>eigenvec</code> guess for the iω eigenvector at p1_0</li><li><code>eigenvec_ad</code> guess for the -iω eigenvector at p1_0</li><li><code>options_cont</code> keywords arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>Jᵗ = (x, p) -&gt; adjoint(d_xF(x, p))</code> associated jacobian adjoint</li><li><code>d2F = (x, p, v1, v2) -&gt; d2F(x, p, v1, v2)</code> this is the hessian of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2)</code>. This helps solving the linear problem associated to the Hopf minimally augmented formulation.</li><li><code>d3F = (x, p, v1, v2, v3) -&gt; d3F(x, p, v1, v2, v3)</code> this is the third derivative of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2, v3)</code>. This is used to detect <strong>Bautin</strong> bifurcation.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>updateMinAugEveryStep</code> update vectors <code>a,b</code> in Minimally Formulation every <code>updateMinAugEveryStep</code> steps</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Simplified call:</strong></p><p>The call is as follows</p><pre><code class="nohighlight hljs">continuationHopf(F, J, br::AbstractBranchResult, ind_hopf::Int, lens2::Lens, options_cont::ContinuationPar ;  kwargs...)</code></pre><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Hopf point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the Bordered Linear Solver using the option <code>bdlinsolver = MatrixBLS()</code></p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian tranpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-success"><header class="admonition-header">Detection of Bogdanov-Takens and Bautin bifurcations</header><div class="admonition-body"><p>In order to trigger the detection, pass <code>detectEvent = 1,2</code> in <code>options_cont</code>. Note that you need to provide <code>d3F</code>.</p></div></div></div></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Govaerts"><a class="tag is-link" href="#citeref-Govaerts">Govaerts</a><blockquote><p>Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../detectionBifurcation/">« Bifurcation detection (codim 1)</a><a class="docs-footer-nextpage" href="../simplebp/">Simple branch point »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 13 December 2021 16:21">Monday 13 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
