<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Collocation · Bifurcation Analysis in Julia</title><meta name="title" content="Collocation · Bifurcation Analysis in Julia"/><meta property="og:title" content="Collocation · Bifurcation Analysis in Julia"/><meta property="twitter:title" content="Collocation · Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../educational/">Educational introduction</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox" checked/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Trapezoid</a></li><li class="is-active"><a class="tocitem" href>Collocation</a><ul class="internal"><li><a class="tocitem" href="#Number-of-unknowns"><span>Number of unknowns</span></a></li><li><a class="tocitem" href="#Phase-condition"><span>Phase condition</span></a></li><li><a class="tocitem" href="#Discretization-of-the-BVP-and-jacobian"><span>Discretization of the BVP and jacobian</span></a></li><li><a class="tocitem" href="#Interpolation"><span>Interpolation</span></a></li><li><a class="tocitem" href="#Mesh-adaptation"><span>Mesh adaptation</span></a></li><li><a class="tocitem" href="#Encoding-of-the-functional"><span>Encoding of the functional</span></a></li><li><a class="tocitem" href="#Jacobians"><span>Jacobians</span></a></li><li><a class="tocitem" href="#Linear-solvers"><span>Linear solvers</span></a></li><li><a class="tocitem" href="#Floquet-multipliers-computation"><span>Floquet multipliers computation</span></a></li><li><a class="tocitem" href="#Computation-with-newton"><span>Computation with <code>newton</code></span></a></li><li><a class="tocitem" href="#Continuation"><span>Continuation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../waveEigen/">Eigen Solvers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../hybrid/">AutoSwitch</a></li><li><a class="tocitem" href="../ANM/">ANM</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../cusp/">Cusp</a></li><li><a class="tocitem" href="../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../bautin/">Bautin</a></li><li><a class="tocitem" href="../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../pd/">Period-doubling</a></li><li><a class="tocitem" href="../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../BifurcationDiagram/">Automatic Bifurcation diagram</a></li><li><a class="tocitem" href="../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../debug/">Debugging</a></li><li><a class="tocitem" href="../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problems</a></li><li><a class="is-disabled">Periodic Orbits</a></li><li class="is-active"><a href>Collocation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Collocation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/periodicOrbitCollocation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Periodic-orbits-based-on-orthogonal-collocation"><a class="docs-heading-anchor" href="#Periodic-orbits-based-on-orthogonal-collocation">Periodic orbits based on orthogonal collocation</a><a id="Periodic-orbits-based-on-orthogonal-collocation-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-orbits-based-on-orthogonal-collocation" title="Permalink"></a></h1><ul><li><a href="#Periodic-orbits-based-on-orthogonal-collocation">Periodic orbits based on orthogonal collocation</a></li><li class="no-marker"><ul><li><a href="#Number-of-unknowns">Number of unknowns</a></li><li><a href="#Phase-condition">Phase condition</a></li><li><a href="#Discretization-of-the-BVP-and-jacobian">Discretization of the BVP and jacobian</a></li><li><a href="#Interpolation">Interpolation</a></li><li><a href="#Mesh-adaptation">Mesh adaptation</a></li><li><a href="#Encoding-of-the-functional">Encoding of the functional</a></li><li><a href="#Jacobians">Jacobians</a></li><li><a href="#Linear-solvers">Linear solvers</a></li><li><a href="#Floquet-multipliers-computation">Floquet multipliers computation</a></li><li><a href="#Computation-with-newton">Computation with <code>newton</code></a></li><li><a href="#Continuation">Continuation</a></li><li><a href="#References">References</a></li></ul></li></ul><p>We compute <code>Ntst</code> time slices of a periodic orbit using orthogonal collocation. This is implemented in the structure <code>PeriodicOrbitOCollProblem</code>.</p><div class="admonition is-success" id="Large-scale-fa19c6a1c44d0453"><header class="admonition-header">Large scale<a class="admonition-anchor" href="#Large-scale-fa19c6a1c44d0453" title="Permalink"></a></header><div class="admonition-body"><p>The current implementation is optimized for ODE and for large scale problems for which the jacobian is sparse.</p></div></div><div class="admonition is-success" id="small-scale-86bbeeb475622cad"><header class="admonition-header">small scale<a class="admonition-anchor" href="#small-scale-86bbeeb475622cad" title="Permalink"></a></header><div class="admonition-body"><p>The current implementation is very optimized for ODE, see inplace <code>BifurcationProblem</code> and <code>COPBLS()</code>.</p></div></div><p>The general method is very well exposed in <sup class="footnote-reference"><a id="citeref-Dankowicz" href="#footnote-Dankowicz">[Dankowicz]</a></sup>,<sup class="footnote-reference"><a id="citeref-Doedel" href="#footnote-Doedel">[Doedel]</a></sup> and we adopt the notations of <sup class="footnote-reference"><a id="citeref-Dankowicz" href="#footnote-Dankowicz">[Dankowicz]</a></sup>. However our implementation is based on <sup class="footnote-reference"><a id="citeref-Doedel" href="#footnote-Doedel">[Doedel]</a></sup> because it is more economical (less equations) when it enforces the continuity of the solution.</p><p>We look for periodic orbits as solutions <span>$(x(0), T)$</span> of</p><p class="math-container">\[\dot x = T\cdot F(x),\ x(0)=x(1)\in\mathbb R^n.\]</p><p>We focus on the differential equality and consider a partition of the time domain</p><p class="math-container">\[0=\tau_{1}&lt;\cdots&lt;\tau_{j}&lt;\cdots&lt;\tau_{N_{tst}+1}=1\]</p><p>where the points are referred to as <strong>mesh points</strong>. On each mesh interval <span>$[\tau_j,\tau_{j+1}]$</span> for <span>$j=1,\cdots,N_{tst}$</span>, we define the affine transformation</p><p class="math-container">\[\tau=\tau^{(j)}(\sigma):=\tau_{j}+\frac{(1+\sigma)}{2}\left(\tau_{j+1}-\tau_{j}\right), \sigma \in[-1,1].\]</p><p>The functions <span>$x^{(j)}$</span> defined on <span>$[-1,1]$</span> by <span>$x^{(j)}(\sigma) \equiv x(\tau_j(\sigma))$</span> satisfies the following equation on <span>$[-1,1]$</span>:</p><p class="math-container">\[\dot x^{(j)} = T\frac{\tau_{j+1}-\tau_j}{2}\cdot F(x^{(j)})\tag{$E_j$}\]</p><p>with the continuity equation <span>$x^{(j+1)}(-1) = x^{(j)}(1)$</span>.</p><p>We now aim at  solving <span>$(E_j)$</span> by using an approximation with a polynomial of degree <span>$m$</span>. Following <sup class="footnote-reference"><a id="citeref-Dankowicz" href="#footnote-Dankowicz">[Dankowicz]</a></sup>, we define a (uniform) partition:</p><p class="math-container">\[-1=\sigma_{1}&lt;\cdots&lt;\sigma_{i}&lt;\cdots&lt;\sigma_{m+1}=1.\]</p><p>The points <span>$\tau_{i,j} = \tau^{(i)}(\sigma_j)$</span> are called the <strong>base points</strong>: they serve as collocation points.</p><p>The associated <span>$m+1$</span> Lagrange polynomials of degree <span>$m$</span> are:</p><p class="math-container">\[\mathcal{L}_{i}(\sigma):=\prod_{k=1, k \neq i}^{m+1} \frac{\sigma-\sigma_{k}}{\sigma_{i}-\sigma_{k}}, i=1, \ldots, m+1.\]</p><p>We then introduce the approximation <span>$p_j$</span> of <span>$x^{(j)}$</span>:</p><p class="math-container">\[\mathcal p_j(\sigma)\equiv \sum\limits_{k=1}^{m+1}\mathcal L_k(\sigma)x_{j,k}\]</p><p>and the problem to be solved at the <strong>nodes</strong> <span>$z_l$</span>, <span>$l=1,\cdots,m$</span>:</p><p class="math-container">\[\forall 1\leq l\leq m,\quad 1\leq j\leq N_{tst},\quad \dot p_j(z_l) = T\frac{\tau_{j+1}-\tau_j}{2}\cdot F(p_j(z_l))\tag{$E_j^2$}.\]</p><p>The <strong>nodes</strong> <span>$(z_l)$</span> are associated with a Gauss–Legendre quadrature.</p><p>In order to have a unique solution, we need to remove the phase freedom. This is done by imposing a <em>phase</em> condition.</p><h2 id="Number-of-unknowns"><a class="docs-heading-anchor" href="#Number-of-unknowns">Number of unknowns</a><a id="Number-of-unknowns-1"></a><a class="docs-heading-anchor-permalink" href="#Number-of-unknowns" title="Permalink"></a></h2><p>Putting the period unknown aside, we have to find the <span>$x_{j,k}$</span> which gives <span>$n\times N_{tst}\times (m+1)$</span> unknowns. </p><p>The equations <span>$E_j^2$</span> provides <span>$n\times N_{tst}\times m$</span> plus the <span>$(N_{tst}-1)\times n$</span> equations for the continuity equations. This makes a total of <span>$(N_{tst}-1)\times m\times n+n\times N_{tst}\times m = n[N_{tst}(m+1)-1]$</span> equations to which we add the <span>$n$</span> equations for the periodic boundary condition. In total, we have</p><p class="math-container">\[n\times N_{tst}\times (m+1)\]</p><p>equations which matches the number of unknowns.</p><h2 id="Phase-condition"><a class="docs-heading-anchor" href="#Phase-condition">Phase condition</a><a id="Phase-condition-1"></a><a class="docs-heading-anchor-permalink" href="#Phase-condition" title="Permalink"></a></h2><p>To ensure uniqueness of the solution to the functional, we use the following phase condition</p><p class="math-container">\[\frac{1}{T} \int_{0}^{T}\left\langle x(s), \dot x_0(s)\right\rangle d s =0\]</p><blockquote><p>During continuation at step <span>$k$</span>, we use <span>$\frac{1}{T} \int_{0}^{T}\left\langle x(s), \dot x_{k-1}(s)\right\rangle d s$</span></p></blockquote><h2 id="Discretization-of-the-BVP-and-jacobian"><a class="docs-heading-anchor" href="#Discretization-of-the-BVP-and-jacobian">Discretization of the BVP and jacobian</a><a id="Discretization-of-the-BVP-and-jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization-of-the-BVP-and-jacobian" title="Permalink"></a></h2><p>We only focus on the differential part. Summing up, we obtained the following equations for the <span>$x_{j,l}\in\mathbb R^n$</span>:</p><p class="math-container">\[\sum\limits_{k=1}^{m+1}\mathcal L_k&#39;(z_l)x_{j,k} = F\left(\sum\limits_{k=1}^{m+1}\mathcal L_k(z_l)x_{j,k}\right)\]</p><p>The jacobian in the case <span>$m=2$</span> is given by: </p><p class="math-container">\[\begin{array}{llllllll}
x_{0,0} &amp; x_{0,1} &amp; x_{1,0} &amp; x_{1,1} &amp; x_{2,0} &amp; x_{2,1} &amp; x_{3,0} &amp;\quad \mathbf{T}
\end{array}
\\
\left(\begin{array}{llllllll}
H_{0,0}^0 &amp; H_{0,1}^0 &amp; H_{1,0}^0 &amp; &amp; &amp; &amp; &amp; * \\
H_{0,0}^1 &amp; H_{0,1}^1 &amp; H_{1,0}^1 &amp; &amp; &amp; &amp; &amp; * \\
&amp; &amp; H_{1,0}^0 &amp; H_{1,1}^0 &amp; H_{2,0}^0 &amp; &amp; &amp; * \\
&amp; &amp; H_{1,0}^1 &amp; H_{1,1}^1 &amp; H_{2,0}^1 &amp; &amp; &amp; * \\
&amp; &amp; &amp; &amp; H_{2,0}^0 &amp; H_{2,1}^0 &amp; H_{3,0}^0 &amp; * \\
&amp; &amp; &amp; &amp; H_{2,0}^1 &amp; H_{2,1}^1 &amp; H_{3,0}^1 &amp; * \\
&amp; &amp; &amp; &amp; &amp; &amp; &amp; * \\
-I &amp; &amp; &amp; &amp; &amp; &amp; I &amp; * \\
* &amp; * &amp; * &amp; * &amp; * &amp; * &amp; * &amp; *
\end{array}\right)\]</p><p>where</p><p class="math-container">\[H_{k,l}^{l_2} = \mathcal L&#39;_{l_2,l}\cdot I_n - T\frac{\tau_{j+1}-\tau_j}{2}\cdot\mathcal L_{l_2,l}\cdot dF\left(x_{k,l}\right)\in\mathbb R^n.\]</p><h2 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.POSolution" href="#BifurcationKit.POSolution"><code>BifurcationKit.POSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structure to encode the solution associated to a functional like <code>::PeriodicOrbitOCollProblem</code> or <code>::ShootingProblem</code>. In the particular case of <code>::PeriodicOrbitOCollProblem</code>, this allows to use the collocation polynomials to interpolate the solution. Hence, if <code>sol::POSolution</code>, then one can call</p><pre><code class="nohighlight hljs">sol = BifurcationKit.POSolution(prob_coll, x)
sol(t)</code></pre><p>on any time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.16/src/periodicorbit/PeriodicOrbits.jl#L59-L66">source</a></section></article><h2 id="Mesh-adaptation"><a class="docs-heading-anchor" href="#Mesh-adaptation">Mesh adaptation</a><a id="Mesh-adaptation-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-adaptation" title="Permalink"></a></h2><p>The goal of this method<sup class="footnote-reference"><a id="citeref-Russell" href="#footnote-Russell">[Russell]</a></sup> is to adapt the mesh <span>$\tau_i$</span> in order to minimize the error. It is particularly helpful near homoclinic solutions where the period diverges. It can also be useful in order to use a smaller <span>$N_{tst}$</span>.</p><h2 id="Encoding-of-the-functional"><a class="docs-heading-anchor" href="#Encoding-of-the-functional">Encoding of the functional</a><a id="Encoding-of-the-functional-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding-of-the-functional" title="Permalink"></a></h2><p>The functional is encoded in the composite type <a href="../library/#BifurcationKit.PeriodicOrbitOCollProblem"><code>PeriodicOrbitOCollProblem</code></a>. See the link for more information, in particular on how to access the underlying functional, its jacobian...</p><h2 id="Jacobians"><a class="docs-heading-anchor" href="#Jacobians">Jacobians</a><a id="Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobians" title="Permalink"></a></h2><p>We provide many different jacobians to take advantage of the problem or the dimensionality. These jacobians are available through the argument <code>jacobian</code> in the constructor of <code>PeriodicOrbitOCollProblem</code>. For example, you can pass <code>jacobian  = FullSparse()</code>. Note that all the internal linear solvers and jacobians are set up automatically so you don&#39;t need to do anything. However, for the sake of explanation, we detail how this works.	</p><ol><li><code>DenseAnalytical()</code></li></ol><p>The jacobian is computed with an analytical formula, it works for dense matrices. This is the default algorithm.</p><ol><li><code>DenseAnalyticalInplace()</code></li></ol><p>Same as 1. but caches more information to limit allocations. (Meant to become the default jacobian in the future).</p><ol><li><code>AutoDiffDense()</code></li></ol><p>The jacobian is computed with automatic differentiation, it works for dense matrices. Can be used for debugging.</p><ol><li><code>FullSparse()</code></li></ol><p>The jacobian is computed with an analytical formula, it works for sparse matrices.</p><ol><li><code>FullSparseInplace()</code></li></ol><p>The sparse jacobian is computed in place, limiting memory allocations, with an analytical formula when the sparsity of the jacobian of the vector field is constant. This is much faster than <code>FullSparse()</code>.</p><h2 id="Linear-solvers"><a class="docs-heading-anchor" href="#Linear-solvers">Linear solvers</a><a id="Linear-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solvers" title="Permalink"></a></h2><p>When the jacobian is dense and dimension is small ~O(10), you should use condensation of parameters <code>COPBLS</code> for performance.</p><ol><li><code>DefaultLS()</code> can be used for most jacobians</li><li><code>COPLS()</code> or <code>COPBLS()</code> which is the method of <strong>condensation of parameters</strong> (COP) implemented in Auto-07p <sup class="footnote-reference"><a id="citeref-Govaerts" href="#footnote-Govaerts">[Govaerts]</a></sup>. For this to be most efficient, the vector field must be written in non-allocating form. In this case, this is almost 10x faster than using <code>DefaultLS()</code> for low dimensional ODEs (say dim = O(10)). The performances are closing on to that of Auto-07p.</li><li>You can use bordered linear solvers in large dimensions to take advantage of the specific shape of the jacobian. See also Trapezoid method for additional information.</li></ol><h2 id="Floquet-multipliers-computation"><a class="docs-heading-anchor" href="#Floquet-multipliers-computation">Floquet multipliers computation</a><a id="Floquet-multipliers-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Floquet-multipliers-computation" title="Permalink"></a></h2><p>We provide three methods to compute the Floquet coefficients.</p><ol><li>The algorithm (Default) <code>FloquetColl</code> is based on the method of condensation of parameters (COP) described in <sup class="footnote-reference"><a id="citeref-Doedel" href="#footnote-Doedel">[Doedel]</a></sup>. It is the fastest method. It can also be used for sparse jacobians.</li><li>The algorithm <code>FloquetCollGEV</code> is a simplified version of the procedure described in <sup class="footnote-reference"><a id="citeref-Fairgrieve" href="#footnote-Fairgrieve">[Fairgrieve]</a></sup>. It boils down to solving a large generalized eigenvalue problem. There is clearly room for improvements here but this can be used to check the results of the previous method. </li></ol><p>These methods allow to detect bifurcations of periodic orbits. It seems to work reasonably well for the tutorials considered here. However they may be imprecise<sup class="footnote-reference"><a id="citeref-Lust" href="#footnote-Lust">[Lust]</a></sup>.</p><ol><li>The state of the art method is based on a Periodic Schur decomposition. It is available through the package <a href="https://github.com/bifurcationkit/PeriodicSchurBifurcationKit.jl">PeriodicSchurBifurcationKit.jl</a>. For more information, have a look at <code>FloquetPQZ</code>.</li></ol><h2 id="Computation-with-newton"><a class="docs-heading-anchor" href="#Computation-with-newton">Computation with <code>newton</code></a><a id="Computation-with-newton-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-with-newton" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.newton-Tuple{PeriodicOrbitOCollProblem, Any, NewtonPar}" href="#BifurcationKit.newton-Tuple{PeriodicOrbitOCollProblem, Any, NewtonPar}"><code>BifurcationKit.newton</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, options; kwargs...)
</code></pre><p>This is the Newton solver for computing a periodic orbit using orthogonal collocation method. Note that the linear solver has to be apropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="../library/#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is a <a href="../library/#BifurcationKit.PeriodicOrbitOCollProblem"><code>PeriodicOrbitOCollProblem</code></a>.</p><ul><li><code>prob</code> a problem of type <code>&lt;: PeriodicOrbitOCollProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit.</li><li><code>options</code> same as for the regular <a href="../library/#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>(AutoDiffDense(), )</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>AutoDiffDense()</code>. The jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>. The jacobian is formed inplace.</li><li>For <code>DenseAnalytical()</code> Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.16/src/periodicorbit/PeriodicOrbitCollocation.jl#L951-L955">source</a></section></article><p>We provide a simplified call to <code>newton</code> to locate the periodic orbits. <code>newton</code> will look for <code>prob.jacobian</code> in order to select the requested way to compute the jacobian.</p><p>The docs for this specific <code>newton</code> are located at <a href="../library/#BifurcationKit.newton"><code>newton</code></a>.</p><h2 id="Continuation"><a class="docs-heading-anchor" href="#Continuation">Continuation</a><a id="Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation" title="Permalink"></a></h2><p>We refer to <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> for more information regarding the arguments. <code>continuation</code> will look for <code>prob.jacobian</code> in order to select the requested way to compute the jacobian.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Dankowicz"><a class="tag is-link" href="#citeref-Dankowicz">Dankowicz</a><blockquote><p>Dankowicz, Harry, and Frank Schilder. Recipes for Continuation. Computational Science and Engineering Series. Philadelphia: Society for Industrial and Applied Mathematics, 2013.</p></blockquote></li><li class="footnote" id="footnote-Doedel"><a class="tag is-link" href="#citeref-Doedel">Doedel</a><blockquote><p>Doedel, Eusebius, Herbert B. Keller, and Jean Pierre Kernevez. “NUMERICAL ANALYSIS AND CONTROL OF BIFURCATION PROBLEMS (II): BIFURCATION IN INFINITE DIMENSIONS.” International Journal of Bifurcation and Chaos 01, no. 04 (December 1991): 745–72.</p></blockquote></li><li class="footnote" id="footnote-Fairgrieve"><a class="tag is-link" href="#citeref-Fairgrieve">Fairgrieve</a><blockquote><p>Fairgrieve, Thomas F., and Allan D. Jepson. “O. K. Floquet Multipliers.” SIAM Journal on Numerical Analysis 28, no. 5 (October 1991): 1446–62. https://doi.org/10.1137/0728075.</p></blockquote></li><li class="footnote" id="footnote-Russell"><a class="tag is-link" href="#citeref-Russell">Russell</a><blockquote><p>Russell, R. D., and J. Christiansen. “Adaptive Mesh Selection Strategies for Solving Boundary Value Problems.” SIAM Journal on Numerical Analysis 15, no. 1 (February 1978): 59–80. https://doi.org/10.1137/0715004.</p></blockquote></li><li class="footnote" id="footnote-Lust"><a class="tag is-link" href="#citeref-Lust">Lust</a><blockquote><p>Lust, Kurt. “Improved Numerical Floquet Multipliers.” International Journal of Bifurcation and Chaos 11, no. 09 (September 2001): 2389–2410. https://doi.org/10.1142/S0218127401003486.</p></blockquote></li><li class="footnote" id="footnote-Govaerts"><a class="tag is-link" href="#citeref-Govaerts">Govaerts</a><blockquote><p>Govaerts, Willy, Yuri A. Kuznetsov, and Annick Dhooge. “Auto94p.” SIAM Journal on Scientific Computing 27, no. 1 (January 1, 2005): 231–52. https://doi.org/10.1137/030600746.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../periodicOrbitTrapeze/">« Trapezoid</a><a class="docs-footer-nextpage" href="../periodicOrbitShooting/">Shooting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 14 August 2025 07:57">Thursday 14 August 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
