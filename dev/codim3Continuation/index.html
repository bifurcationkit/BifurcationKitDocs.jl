<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bogdanov-Takens refinement (3 params) · Bifurcation Analysis in Julia</title><meta name="title" content="Bogdanov-Takens refinement (3 params) · Bifurcation Analysis in Julia"/><meta property="og:title" content="Bogdanov-Takens refinement (3 params) · Bifurcation Analysis in Julia"/><meta property="twitter:title" content="Bogdanov-Takens refinement (3 params) · Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../educational/">Educational introduction</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../hybrid/">AutoSwitch</a></li><li><a class="tocitem" href="../ANM/">ANM</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox" checked/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li class="is-active"><a class="tocitem" href>Bogdanov-Takens refinement (3 params)</a><ul class="internal"><li><a class="tocitem" href="#Method"><span>Method</span></a></li><li><a class="tocitem" href="#Setting-the-jacobian"><span>Setting the jacobian</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Newton-refinement"><span>Newton refinement</span></a></li><li><a class="tocitem" href="#Advanced-use"><span>Advanced use</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../cusp/">Cusp</a></li><li><a class="tocitem" href="../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../bautin/">Bautin</a></li><li><a class="tocitem" href="../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../pd/">Period-doubling</a></li><li><a class="tocitem" href="../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../migration/">Migration from old versions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functionalities</a></li><li><a class="is-disabled">Bifurcations (equilibria)</a></li><li class="is-active"><a href>Bogdanov-Takens refinement (3 params)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bogdanov-Takens refinement (3 params)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/codim3Continuation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bogdanov-Takens-refinement"><a class="docs-heading-anchor" href="#Bogdanov-Takens-refinement">Bogdanov-Takens refinement</a><a id="Bogdanov-Takens-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Bogdanov-Takens-refinement" title="Permalink"></a></h1><ul><li><a href="#Bogdanov-Takens-refinement">Bogdanov-Takens refinement</a></li><li class="no-marker"><ul><li><a href="#Method">Method</a></li><li><a href="#Setting-the-jacobian">Setting the jacobian</a></li><li><a href="#Example">Example</a></li><li><a href="#Newton-refinement">Newton refinement</a></li><li><a href="#Advanced-use">Advanced use</a></li><li><a href="#References">References</a></li></ul></li></ul><p>In this page, we explain how to perform precise localisation of Bogdanov-Takens (BT) points. This is an unusual feature of numerical continuation libraries. We chose to implement it because the localisation of the BT points on the Hopf bifurcation curves is rather imprecise.</p><h2 id="Method"><a class="docs-heading-anchor" href="#Method">Method</a><a id="Method-1"></a><a class="docs-heading-anchor-permalink" href="#Method" title="Permalink"></a></h2><p>The continuation of BT bifurcation points is based on a <strong>Minimally Augmented</strong><sup class="footnote-reference"><a id="citeref-Govaerts" href="#footnote-Govaerts">[Govaerts]</a></sup>,<sup class="footnote-reference"><a id="citeref-Blank" href="#footnote-Blank">[Blank]</a></sup>,<sup class="footnote-reference"><a id="citeref-Bindel" href="#footnote-Bindel">[Bindel]</a></sup> formulation which is an efficient way to detect singularities. The continuation of BT points is based on the formulation</p><p class="math-container">\[G(u,p) = (F(u,p), g_1(u,p), g_2(u,p))\in\mathbb R^{n+2}\quad\quad (F_{bt})\]</p><p>where the test functions <span>$g_1,g_2$</span> are solutions of</p><p class="math-container">\[\left[\begin{array}{cc}
dF(u,p) &amp; w \\
v^{\top} &amp; 0
\end{array}\right]\left[\begin{array}{c}
v_1 \\
g_1(u,p)
\end{array}\right]=\left[\begin{array}{c}0_{n} \\1\end{array}\right]\quad\quad (M_{bt})\]</p><p>and</p><p class="math-container">\[\left[\begin{array}{cc}
dF(u,p) &amp; w \\
v^{\top} &amp; 0
\end{array}\right]\left[\begin{array}{c}
v_2 \\
g_2(u,p)
\end{array}\right]=\left[\begin{array}{c}v_1 \\0\end{array}\right]\quad\quad (M_{bt})\]</p><p>and where <span>$w,v$</span> are chosen in order to have a non-singular matrix <span>$(M_{bt})$</span>. More precisely, <span>$v$</span> (resp. <span>$w$</span>) should be close to a null vector of <code>dF(u,p)</code> (resp. <code>dF(u,p)&#39;</code>).</p><blockquote><p>note that there are very simplified calls for this, see <strong>Newton refinement</strong> below. In particular, you don&#39;t need to set up the Minimally Augmented problem yourself. This is done in the background.</p></blockquote><div class="admonition is-warning"><header class="admonition-header">Linear Method</header><div class="admonition-body"><p>You can pass the bordered linear solver to solve <span>$(M_{bt})$</span> using the option <code>bdlinsolver</code> (see below). Note that the choice <code>bdlinsolver = BorderingBLS()</code> can lead to singular systems. Indeed, in this case, <span>$(M_{bt})$</span> is solved by inverting <code>dF(u,p)</code> which is singular at Fold points.</p></div></div><h2 id="Setting-the-jacobian"><a class="docs-heading-anchor" href="#Setting-the-jacobian">Setting the jacobian</a><a id="Setting-the-jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-the-jacobian" title="Permalink"></a></h2><p>In order to apply the newton algorithm to <span>$F_{bt}$</span>, one needs to invert the jacobian. This is not completely trivial as one must compute this jacobian and then invert it. You can select the following jacobians for your computations (see below):</p><ul><li><code>jacobian_ma = :autodiff</code>: [Default] automatic differentiation is applied to <span>$F_{bt}$</span> and the matrix is then inverted using the provided linear solver. In particular, the jacobian is formed. This is very well suited for small dimensions  (say &lt; 100)</li><li><code>jacobian_ma = :minaug</code>: a specific procedure for evaluating the jacobian <span>$F_{bt}$</span> and inverting it (without forming the jacobian!) is used. This is well suited for large dimensions.</li></ul><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using Revise, BifurcationKit
Fbt(x, p) = [x[2], p.β1 + p.β2 * x[2] + p.a * x[1]^2 + p.b * x[1] * x[2]]
par = (β1 = 0.01, β2 = -0.3, a = -1., b = 1.)
prob  = BifurcationProblem(Fbt, [0.01, 0.01], par, (@optic _.β1))
opts_br = ContinuationPar(p_max = 0.5, p_min = -0.5, detect_bifurcation = 3, nev = 2)

br = continuation(prob, PALC(), opts_br; bothside = true)

# compute branch of Hopf points
hopf_codim2 = continuation(br, 3, (@optic _.β2), ContinuationPar(opts_br, max_steps = 40) ;
	detect_codim2_bifurcation = 2,
	update_minaug_every_step = 1,
	bothside = true,
	)

# refine BT point
solbt = BifurcationKit.newton_bt(hopf_codim2, 2)
solbt.u</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36"><span class="sgr1">Bogdanov-Takens</span></span> bifurcation point at (:β1, :β2) ≈ (0.0, -3.0292258760486853e-28).
Normal form (B, p1 + p2⋅B + b⋅A⋅B + a⋅A²)
Normal form coefficients:
 a = missing
 b = missing

You can call various predictors:
 - predictor(::BogdanovTakens, ::Val{:HopfCurve}, ds)
 - predictor(::BogdanovTakens, ::Val{:FoldCurve}, ds)
 - predictor(::BogdanovTakens, ::Val{:HomoclinicCurve}, ds)
</code></pre><h2 id="Newton-refinement"><a class="docs-heading-anchor" href="#Newton-refinement">Newton refinement</a><a id="Newton-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-refinement" title="Permalink"></a></h2><p>Once a Bogdanov-Takens point has been detected after a call to <code>br = continuation(...)</code>, it can be refined using <code>newton</code> iterations. Let us say that <code>ind_bif</code> is the index in <code>br.specialpoint</code> of a Bogdanov-Takens point. This guess can be refined as follows:</p><pre><code class="language-julia hljs">outfold = newton(br::AbstractBranchResult, ind_bif::Int;  
	normN = norm,
	options = br.contparams.newton_options,
	bdlinsolver = BorderingBLS(options.linsolver),
	jacobian_ma = :autodiff,
	start_with_eigen = false, kwargs...)</code></pre><p>For the options parameters, we refer to <a href="../library/#Newton">Newton</a>.</p><p>It is important to note that for improved performances, a function implementing the expression of the <strong>hessian</strong> should be provided. This is by far the fastest. <code>BifurcationProblem</code> provides it by default using AD though.</p><h2 id="Advanced-use"><a class="docs-heading-anchor" href="#Advanced-use">Advanced use</a><a id="Advanced-use-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-use" title="Permalink"></a></h2><p>Here, we expose the solvers that are used to perform newton refinement. This is useful in case it is too involved to expose the linear solver options.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.newton_bt" href="#BifurcationKit.newton_bt"><code>BifurcationKit.newton_bt</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">newton_bt(
    prob,
    btpointguess,
    par,
    lens2,
    eigenvec,
    eigenvec_ad,
    options;
    normN,
    jacobian_ma,
    usehessian,
    bdlinsolver,
    bdlinsolver_adjoint,
    bdlinsolver_block,
    kwargs...
)
</code></pre><p>This function turns an initial guess for a BT point into a solution to the BT problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>prob::AbstractBifurcationFunction</code></li><li><code>btpointguess</code> initial guess (x<em>0, p</em>0) for the BT point. It should be a <code>BorderedArray</code> as returned by the function <code>BTPoint</code></li><li><code>par</code> parameters used for the vector field</li><li><code>eigenvec</code> guess for the 0 eigenvector</li><li><code>eigenvec_ad</code> guess for the 0 adjoint eigenvector</li><li><code>options::NewtonPar</code> options for the Newton-Krylov algorithm, see <a href="../library/#BifurcationKit.NewtonPar"><code>NewtonPar</code></a>.</li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>normN = norm</code></li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>jacobian_ma::Symbol = true</code> specify the way the (newton) linear system is solved. Can be (:autodiff, :finitedifferences, :minaug)</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><p><strong>Simplified call</strong></p><p>Simplified call to refine an initial guess for a BT point. More precisely, the call is as follows</p><pre><code class="nohighlight hljs">newton(br::AbstractBranchResult, ind_bt::Int; options = br.contparams.newton_options, kwargs...)</code></pre><p>The parameters / options are as usual except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of bifurcation point in <code>br</code> you want to refine. You can pass newton parameters different from the ones stored in <code>br</code> by using the argument <code>options</code>.</p><div class="admonition is-success"><header class="admonition-header">Jacobian transpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian will be computed twice!</p></div></div><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the option <code>jacobian_ma = :autodiff</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.4/src/codim2/MinAugBT.jl#L252">source</a></section><section><div><pre><code class="language-julia hljs">newton_bt(
    br,
    ind_bt;
    probvf,
    normN,
    options,
    nev,
    start_with_eigen,
    bdlinsolver,
    bdlinsolver_adjoint,
    kwargs...
)
</code></pre><p>This function turns an initial guess for a Bogdanov-Takens point into a solution to the Bogdanov-Takens problem based on a Minimally Augmented formulation.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> results returned after a call to <a href="../library/#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>options::NewtonPar</code>, default value <code>br.contparams.newton_options</code></li><li><code>normN = norm</code></li><li><code>options</code> You can pass newton parameters different from the ones stored in <code>br</code> by using this argument <code>options</code>.</li><li><code>jacobian_ma::Symbol = true</code> specify the way the (newton) linear system is solved. Can be (:autodiff, :finitedifferences, :minaug)</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>start_with_eigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements.</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the option <code>jacobian = :autodiff</code></p></div></div><div class="admonition is-success"><header class="admonition-header">start_with_eigen</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the option <code>start_with_eigen = true</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.4/src/codim2/MinAugBT.jl#L346">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Govaerts"><a class="tag is-link" href="#citeref-Govaerts">Govaerts</a><blockquote><p>Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.</p></blockquote></li><li class="footnote" id="footnote-Blank"><a class="tag is-link" href="#citeref-Blank">Blank</a><blockquote><p>Blank, H. J. de, Yu. A. Kuznetsov, M. J. Pekkér, and D. W. M. Veldman. “Degenerate Bogdanov–Takens Bifurcations in a One-Dimensional Transport Model of a Fusion Plasma.” Physica D: Nonlinear Phenomena 331 (September 15, 2016): 13–26. https://doi.org/10.1016/j.physd.2016.05.008.</p></blockquote></li><li class="footnote" id="footnote-Bindel"><a class="tag is-link" href="#citeref-Bindel">Bindel</a><blockquote><p>Bindel, D., M. Friedman, W. Govaerts, J. Hughes, and Yu.A. Kuznetsov. “Numerical Computation of Bifurcations in Large Equilibrium Systems in Matlab.” Journal of Computational and Applied Mathematics 261 (May 2014): 232–48. https://doi.org/10.1016/j.cam.2013.10.034.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../codim2Continuation/">« Fold / Hopf Continuation (2 params)</a><a class="docs-footer-nextpage" href="../detectionBifurcationPO/">Bifurcation detection (1 param) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 1 December 2024 10:28">Sunday 1 December 2024</span>. Using Julia version 1.10.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
