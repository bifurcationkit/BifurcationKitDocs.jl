<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../educational/">Educational introduction</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../ANM/">ANM</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox"/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-4" type="checkbox"/><label class="tocitem" for="menuitem-7-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../cusp/">Cusp</a></li><li><a class="tocitem" href="../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../bautin/">Bautin</a></li><li><a class="tocitem" href="../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../hh/">Hopf-Hopf</a></li></ul></li><li><span class="tocitem">Normal form (periodic orbits)</span></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../migration/">Migration to v0.2.x</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li><li><a class="tocitem" href="#Problems"><span>Problems</span></a></li><li><a class="tocitem" href="#Newton"><span>Newton</span></a></li><li><a class="tocitem" href="#Library-Continuation"><span>Continuation</span></a></li><li><a class="tocitem" href="#Continuation-algorithms"><span>Continuation algorithms</span></a></li><li><a class="tocitem" href="#Events"><span>Events</span></a></li><li><a class="tocitem" href="#Branch-switching-(branch-point)"><span>Branch switching (branch point)</span></a></li><li><a class="tocitem" href="#Branch-switching-(Hopf-point)"><span>Branch switching (Hopf point)</span></a></li><li><a class="tocitem" href="#Bifurcation-diagram"><span>Bifurcation diagram</span></a></li><li><a class="tocitem" href="#Utils-for-periodic-orbits"><span>Utils for periodic orbits</span></a></li><li><a class="tocitem" href="#Misc."><span>Misc.</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul><li><a href="#Library">Library</a></li><li class="no-marker"><ul><li><a href="#Parameters">Parameters</a></li><li><a href="#Results">Results</a></li><li><a href="#Problems">Problems</a></li><li class="no-marker"><ul><li><a href="#Periodic-orbits">Periodic orbits</a></li><li><a href="#Waves">Waves</a></li></ul></li><li><a href="#Newton">Newton</a></li><li><a href="#Library-Continuation">Continuation</a></li><li><a href="#Continuation-algorithms">Continuation algorithms</a></li><li><a href="#Events">Events</a></li><li><a href="#Branch-switching-(branch-point)">Branch switching (branch point)</a></li><li><a href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a></li><li><a href="#Bifurcation-diagram">Bifurcation diagram</a></li><li><a href="#Utils-for-periodic-orbits">Utils for periodic orbits</a></li><li><a href="#Misc.">Misc.</a></li></ul></li></ul><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.NewtonPar" href="#BifurcationKit.NewtonPar"><code>BifurcationKit.NewtonPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NewtonPar{T, L&lt;:BifurcationKit.AbstractLinearSolver, E&lt;:AbstractEigenSolver}</code></pre><p>Returns a variable containing parameters to affect the <code>newton</code> algorithm when solving <code>F(x) = 0</code>.</p><p><strong>Arguments (with default values):</strong></p><ul><li><p><code>tol::Any</code></p><p>absolute tolerance for <code>F(x)</code> Default: 1.0e-12</p></li><li><p><code>maxIter::Int64</code></p><p>number of Newton iterations Default: 25</p></li><li><p><code>verbose::Bool</code></p><p>display Newton iterations? Default: false</p></li><li><p><code>linsolver::BifurcationKit.AbstractLinearSolver</code></p><p>linear solver, must be <code>&lt;: AbstractLinearSolver</code> Default: DefaultLS()</p></li><li><p><code>eigsolver::AbstractEigenSolver</code></p><p>eigen solver, must be <code>&lt;: AbstractEigenSolver</code> Default: DefaultEig()</p></li><li><p><code>linesearch::Bool</code></p><p>Default: false</p></li><li><p><code>α::Any</code></p><p>Default: convert(typeof(tol), 1.0)</p></li><li><p><code>αmin::Any</code></p><p>Default: convert(typeof(tol), 0.001)</p></li></ul><p><strong>Arguments for line search (Armijo)</strong></p><ul><li><code>linesearch = false</code>: use line search algorithm (i.e. Newton with Armijo&#39;s rule)</li><li><code>α = 1.0</code>: initial value of α (damping) parameter for line search algorithm</li><li><code>αmin  = 0.001</code>: minimal value of the damping <code>alpha</code></li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See the tutorials for examples.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContinuationPar" href="#BifurcationKit.ContinuationPar"><code>BifurcationKit.ContinuationPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">options = ContinuationPar(dsmin = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>continuation</code> algorithm used to solve <code>F(x,p) = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dsmin, dsmax</code> are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.</li><li><code>ds = 0.01</code> is the initial arclength.</li><li><code>pMin, pMax</code> allowed parameter range for <code>p</code></li><li><code>maxSteps = 100</code> maximum number of continuation steps</li><li><code>newtonOptions::NewtonPar</code>: options for the Newton algorithm</li><li><code>saveToFile = false</code>: save to file. A name is automatically generated or can be defined in <a href="#BifurcationKit.continuation"><code>continuation</code></a>. This requires <code>using JLD2</code>.</li><li><code>saveSolEveryStep::Int64 = 0</code> at which continuation steps do we save the current solution</li><li><code>plotEveryStep = 10</code> at which continuation steps do we plot the current solution</li></ul><p><strong>Handling eigen elements, their computation is triggered by the argument <code>detectBifurcation</code> (see below)</strong></p><ul><li><code>nev = 3</code> number of eigenvalues to be computed. It is automatically increased to have at least <code>nev</code> unstable eigenvalues. To be set for proper  bifurcation detection. See <a href="@ref">Detection of bifurcation points</a> for more informations.</li><li><code>saveEigEveryStep = 1</code>	record eigen vectors every specified steps. <strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li><li><code>saveEigenvectors	= true</code>	<strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li></ul><p><strong>Handling bifurcation detection</strong></p><ul><li><code>tolStability = 1e-10</code> lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits</li><li><code>detectFold = true</code> detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)</li><li><code>detectBifurcation::Int</code> ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)</li><li><code>dsminBisection = 1e-16</code> dsmin for the bisection algorithm for locating bifurcation points</li><li><code>nInversion = 2</code> number of sign inversions in bisection algorithm</li><li><code>maxBisectionSteps = 15</code> maximum number of bisection steps</li><li><code>tolBisectionEigenvalue = 1e-16</code> tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps</li></ul><p><strong>Handling <code>ds</code> adaptation (see <a href="#BifurcationKit.continuation"><code>continuation</code></a> for more information)</strong></p><ul><li><code>a  = 0.5</code> aggressiveness factor. It is used to adapt <code>ds</code> in order to have a number of newton iterations per continuation step roughly constant. The higher <code>a</code> is, the larger the step size <code>ds</code> is changed at each continuation step.</li></ul><p><strong>Handling event detection</strong></p><ul><li><code>detectEvent::Int</code> ∈ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are sought during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).</li><li><code>tolParamBisectionEvent = 1e-16</code> tolerance on parameter to locate event</li></ul><p><strong>Misc</strong></p><ul><li><code>η = 150.</code> parameter to estimate tangent at first point with parameter  p₀ + ds / η</li><li><code>detectLoop</code> [WORK IN PROGRESS] detect loops in the branch and stop the continuation</li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See tutorials for more examples.</p></div></div></div></section></article><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.NonLinearSolution" href="#BifurcationKit.NonLinearSolution"><code>BifurcationKit.NonLinearSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Structure to hold the solution from application of Newton-Krylov algorithm to a nonlinear problem.</p><ul><li><p><code>u::Any</code></p><p>solution</p></li><li><p><code>prob::Any</code></p><p>nonlinear problem</p></li><li><p><code>residuals::Any</code></p><p>sequence of residuals</p></li><li><p><code>converged::Bool</code></p><p>has algorithm converged?</p></li><li><p><code>itnewton::Int64</code></p><p>number of newton steps</p></li><li><p><code>itlineartot::Any</code></p><p>total number of linear iterations</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContResult" href="#BifurcationKit.ContResult"><code>BifurcationKit.ContResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ContResult{Tkind&lt;:BifurcationKit.AbstractContinuationKind, Tbr, Teigvals, Teigvec, Biftype, Tsol, Tparc, Tprob, Talg} &lt;: BifurcationKit.AbstractResult{Tkind&lt;:BifurcationKit.AbstractContinuationKind, Tprob}</code></pre><p>Structure which holds the results after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a>.</p><p>You can see the propertynames of a result <code>br</code> by using <code>propertynames(br)</code> or <code>propertynames(br.branch)</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>branch::StructArrays.StructArray</code></p><p>holds the low-dimensional information about the branch. More precisely, <code>branch[i+1]</code> contains the following information <code>(recordFromSolution(u, param), param, itnewton, itlinear, ds, θ, n_unstable, n_imag, stable, step)</code> for each continuation step <code>i</code>.</p><ul><li><code>itnewton</code> number of Newton iterations</li><li><code>itlinear</code> total number of linear iterations during corrector</li><li><code>n_unstable</code> number of eigenvalues with positive real part for each continuation step (to detect stationary bifurcation)</li><li><code>n_imag</code> number of eigenvalues with positive real part and non zero imaginary part for each continuation step (to detect Hopf bifurcation).</li><li><code>stable</code>  stability of the computed solution for each continuation step. Hence, <code>stable</code> should match <code>eig[step]</code> which corresponds to <code>branch[k]</code> for a given <code>k</code>.</li><li><code>step</code> continuation step (here equal <code>i</code>)</li></ul></li><li><p><code>eig::Array{NamedTuple{(:eigenvals, :eigenvecs, :converged, :step), Tuple{Teigvals, Teigvec, Bool, Int64}}, 1} where {Teigvals, Teigvec}</code></p><p>A vector with eigen-elements at each continuation step.</p></li><li><p><code>sol::Any</code></p><p>Vector of solutions sampled along the branch. This is set by the argument <code>saveSolEveryStep::Int64</code> (default 0) in <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a>.</p></li><li><p><code>contparams::Any</code></p><p>The parameters used for the call to <code>continuation</code> which produced this branch. Must be a ContinationPar</p></li><li><p><code>kind::BifurcationKit.AbstractContinuationKind</code></p><p>Type of solutions computed in this branch. Default: EquilibriumCont()</p></li><li><p><code>prob::Any</code></p><p>Structure associated to the functional, useful for branch switching. For example, when computing periodic orbits, the functional <code>PeriodicOrbitTrapProblem</code>, <code>ShootingProblem</code>... will be saved here. Default: nothing</p></li><li><p><code>specialpoint::Vector</code></p><p>A vector holding the set of detected bifurcation points. See <a href="#BifurcationKit.SpecialPoint"><code>SpecialPoint</code></a> for a description of the fields.</p></li><li><p><code>alg::Any</code></p><p>Continuation algorithm used for the computation of the branch</p></li></ul><p><strong>Associated methods</strong></p><ul><li><code>length(br)</code> number of the continuation steps</li><li><code>eigenvals(br, ind)</code> returns the eigenvalues for the ind-th continuation step</li><li><code>eigenvec(br, ind, indev)</code> returns the indev-th eigenvector for the ind-th continuation step</li><li><code>br[k+1]</code> gives information about the k-th step. A typical run yields the following</li><li><code>getNormalForm(br, ind)</code> compute the normal form of the ind-th points in <code>br.specialpoint</code></li><li><code>getLens(br)</code> return the parameter axis used for the branch</li><li><code>getLenses(br)</code> return the parameter two axis used for the branch when 2 parameters continuation is used (Fold, Hopf, NS, PD)</li></ul><pre><code class="nohighlight hljs">julia&gt; br[1]
(x = 0.0, param = 0.1, itnewton = 0, itlinear = 0, ds = -0.01, θ = 0.5, n_unstable = 2, n_imag = 2, stable = false, step = 0, eigenvals = ComplexF64[0.1 - 1.0im, 0.1 + 1.0im], eigenvecs = ComplexF64[0.7071067811865475 - 0.0im 0.7071067811865475 + 0.0im; 0.0 + 0.7071067811865475im 0.0 - 0.7071067811865475im])</code></pre><p>which provides the value <code>param</code> of the parameter of the current point, its stability, information on the newton iterations, etc. The fields can be retrieved using <code>propertynames(br.branch)</code>. This information is stored in <code>br.branch</code> which is a <code>StructArray</code>. You can thus extract the vector of parameters along the branch as</p><pre><code class="nohighlight hljs">julia&gt; br.param
10-element Vector{Float64}:
 0.1
 0.08585786437626905
 0.06464466094067263
 0.03282485578727799
-1.2623798512809007e-5
-0.07160718539365075
-0.17899902778635765
-0.3204203840236672
-0.4618417402609767
-0.5</code></pre><ul><li><code>getSolx(br, k)</code> returns the k-th solution on the branch</li><li><code>getSolp(br, k)</code> returns the parameter  value associated with k-th solution on the branch</li><li><code>getParams(br)</code> Parameters passed to continuation and used in the equation <code>F(x, par) = 0</code>.</li><li><code>setParam(br, p0)</code> set the parameter value <code>p0</code> according to <code>::Lens</code> for the parameters of the problem <code>br.prob</code></li><li><code>getLens(br)</code> get the lens used for the computation of the branch</li></ul></div></section></article><h2 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.BifFunction" href="#BifurcationKit.BifFunction"><code>BifurcationKit.BifFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BifFunction{Tf, Tdf, Tdfad, Tj, Tjad, Td2f, Td2fc, Td3f, Td3fc, Tsym, Tδ} &lt;: BifurcationKit.AbstractBifurcationFunction</code></pre><p>Structure to hold the vector field and its derivatives. It should rarely be called directly. Also, in essence, it is very close to <code>SciMLBase.ODEFunction</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>F::Any</code></p><p>Vector field. Function of type out-of-place <code>result = f(x, p)</code> or inplace <code>f(result, x, p)</code>. For type stability, the types of <code>x</code> and <code>result</code> should match</p></li><li><p><code>dF::Any</code></p><p>Differential of <code>F</code> with respect to <code>x</code>, signature <code>dF(x,p,dx)</code></p></li><li><p><code>dFad::Any</code></p><p>Adjoint of the Differential of <code>F</code> with respect to <code>x</code>, signature <code>dFad(x,p,dx)</code></p></li><li><p><code>J::Any</code></p><p>Jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.         1. Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.         2. Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,         3. Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</p></li><li><p><code>Jᵗ::Any</code></p><p>jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code>.</p></li><li><p><code>d2F::Any</code></p><p>Second Differential of <code>F</code> with respect to <code>x</code>, signature <code>d2F(x,p,dx1,dx2)</code></p></li><li><p><code>d3F::Any</code></p><p>Third Differential of <code>F</code> with respect to <code>x</code>, signature <code>d3F(x,p,dx1,dx2,dx3)</code></p></li><li><p><code>d2Fc::Any</code></p><p>[internal] Second Differential of <code>F</code> with respect to <code>x</code> which accept complex vectors dxi</p></li><li><p><code>d3Fc::Any</code></p><p>[internal] Third Differential of <code>F</code> with respect to <code>x</code> which accept complex vectors dxi</p></li><li><p><code>isSymmetric::Any</code></p><p>Whether the jacobian is auto-adjoint.</p></li><li><p><code>δ::Any</code></p><p>used internally to compute derivatives (with finite differences), for example for normal form computation and codim 2 continuation.</p></li><li><p><code>inplace::Bool</code></p><p>optionally sets whether the function is inplace or not</p></li></ul><p><strong>Methods</strong></p><ul><li><code>residual(pb::BifFunction, x, p)</code> calls <code>pb.F(x,p)</code></li><li><code>jacobian(pb::BifFunction, x, p)</code> calls  <code>pb.J(x, p)</code></li><li><code>dF(pb::BifFunction, x, p, dx)</code> calls <code>pb.dF(x,p,dx)</code></li><li>etc</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.BifurcationProblem" href="#BifurcationKit.BifurcationProblem"><code>BifurcationKit.BifurcationProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BifurcationProblem{Tvf, Tu, Tp, Tl&lt;:Lens, Tplot, Trec} &lt;: BifurcationKit.AbstractAllJetBifProblem</code></pre><p>Structure to hold the bifurcation problem.</p><p><strong>Fields</strong></p><ul><li><p><code>VF::Any</code></p><p>Vector field, typically a <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a></p></li><li><p><code>u0::Any</code></p><p>Initial guess</p></li><li><p><code>params::Any</code></p><p>parameters</p></li><li><p><code>lens::Lens</code></p><p>Typically a <code>Setfield.Lens</code>. It specifies which parameter axis among <code>params</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@lens _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@lens _[1])</code>. For more information, we refer to <code>SetField.jl</code>.</p></li><li><p><code>plotSolution::Any</code></p><p>user function to plot solutions during continuation. Signature: <code>plotSolution(x, p; kwargs...)</code></p></li><li><p><code>recordFromSolution::Any</code></p><p><code>recordFromSolution = (x, p) -&gt; norm(x)</code> function used record a few indicators about the solution. It could be <code>norm</code> or <code>(x, p) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU). This function can return pretty much everything but you should keep it small. For example, you can do <code>(x, p) -&gt; (x1 = x[1], x2 = x[2], nrm = norm(x))</code> or simply <code>(x, p) -&gt; (sum(x), 1)</code>. This will be stored in <code>contres.branch</code> where <code>contres::ContResult</code> is the continuation curve of the bifurcation problem. Finally, the first component is used for plotting in the continuation curve.</p></li></ul><p><strong>Methods</strong></p><ul><li><code>getu0(pb)</code> calls <code>pb.u0</code></li><li><code>getParams(pb)</code> calls <code>pb.params</code></li><li><code>getLens(pb)</code> calls <code>pb.lens</code></li><li><code>getParam(pb)</code> calls <code>get(pb.params, pb.lens)</code></li><li><code>setParam(pb, p0)</code> calls <code>set(pb.params, pb.lens, p0)</code></li><li><code>recordFromSolution(pb)</code> calls <code>pb.recordFromSolution</code></li><li><code>plotSolution(pb)</code> calls <code>pb.plotSolution</code></li><li><code>isSymmetric(pb)</code> calls <code>isSymmetric(pb.prob)</code></li></ul><p><strong>Constructors</strong></p><ul><li><code>BifurcationProblem(F, u0, params, lens; J, Jᵗ, d2F, d3F, kwargs...)</code> and <code>kwargs</code> are the fields above. You can pass your own jacobian with <code>J</code> (see <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a> for description of the jacobian function) and jacobian adjoint with <code>Jᵗ</code>. For example, this can be used to provide finite differences based jacobian.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DeflationOperator" href="#BifurcationKit.DeflationOperator"><code>BifurcationKit.DeflationOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DeflationOperator{Tp&lt;:Real, Tdot, T&lt;:Real, vectype} &lt;: BifurcationKit.abstractDeflationFactor</code></pre><p>Structure for defining a custom distance.</p><p>This operator allows to handle the following situation. Assume you want to solve <code>F(x)=0</code> with a Newton algorithm but you want to avoid the process to return some already known solutions <span>$roots_i$</span>. The deflation operator penalizes these roots. You can create a <code>DeflationOperator</code> to define a scalar function <code>M(u)</code> used to find, with Newton iterations, the zeros of the following function <span>$F(u) \cdot Π_i(\|u - root_i\|^{-2p} + \alpha) := F(u) \cdot M(u)$</span> where <span>$\|u\|^2 = dot(u, u)$</span>. The fields of the struct <code>DeflationOperator</code> are as follows:</p><ul><li><p><code>power::Real</code></p><p>power <code>p</code>. You can use an <code>Int</code> for example</p></li><li><p><code>dot::Any</code></p><p>function, this function has to be bilinear and symmetric for the linear solver to work well</p></li><li><p><code>α::Real</code></p><p>shift</p></li><li><p><code>roots::Vector</code></p><p>roots</p></li><li><p><code>tmp::Any</code></p></li><li><p><code>autodiff::Bool</code></p></li><li><p><code>δ::Real</code></p></li></ul><p>Given <code>defOp::DeflationOperator</code>, one can access its roots via <code>defOp[n]</code> as a shortcut for <code>defOp.roots[n]</code>. Note that you can also use <code>defOp[end]</code>.</p><p>Also, one can add (resp. remove) a new root by using <code>push!(defOp, newroot)</code> (resp. <code>pop!(defOp)</code>). Finally <code>length(defOp)</code> is a shortcut for <code>length(defOp.roots)</code></p><p><strong>Constructors</strong></p><ul><li><code>DeflationOperator(p::Real, α::Real, roots::Vector{vectype}; autodiff = false)</code></li><li><code>DeflationOperator(p::Real, dt, α::Real, roots::Vector{vectype}; autodiff = false)</code></li><li><code>DeflationOperator(p::Real, α::Real, roots::Vector{vectype}, v::vectype; autodiff = false)</code></li></ul><p>The option <code>autodiff</code> triggers the use of automatic differentiation for the computation of the gradient of the scalar function <code>M</code>. This works only on <code>AbstractVector</code> for now.</p><p><strong>Custom distance</strong></p><p>You are asked to pass a scalar product like <code>dot</code> to build a <code>DeflationOperator</code>. However, in some cases, you may want to pass a custom distance <code>dist(u, v)</code>. You can do this using</p><pre><code class="nohighlight hljs">`DeflationOperator(p, CustomDist(dist), α, roots)`</code></pre><p>Note that passing <code>CustomDist(dist, true)</code> will trigger the use of automatic differentiation for the gradient of <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DeflatedProblem" href="#BifurcationKit.DeflatedProblem"><code>BifurcationKit.DeflatedProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = DeflatedProblem(prob, M::DeflationOperator, jactype)</code></pre><p>Create a <code>DeflatedProblem</code>.</p><p>This creates a deflated functional (problem) <span>$M(u) \cdot F(u) = 0$</span> where <code>M</code> is a <code>DeflationOperator</code> which encodes the penalization term. <code>prob</code> is an <code>AbstractBifurcationProblem</code> which encodes the functional. It is not meant not be used directly albeit by advanced users.</p></div></section></article><h3 id="Periodic-orbits"><a class="docs-heading-anchor" href="#Periodic-orbits">Periodic orbits</a><a id="Periodic-orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-orbits" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PeriodicOrbitTrapProblem" href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>BifurcationKit.PeriodicOrbitTrapProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This composite type implements Finite Differences based on a Trapezoidal rule (Order 2 in time) to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitTrapeze/">here</a>.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code> a bifurcation problem</li><li><code>M::Int</code> number of time slices</li><li><code>ϕ</code> used to set a section for the phase constraint equation, of size N*M</li><li><code>xπ</code> used in the section for the phase constraint equation, of size N*M</li><li><code>linsolver: = DefaultLS()</code> linear solver for each time slice, i.e. to solve <code>J⋅sol = rhs</code>. This is only needed for the computation of the Floquet multipliers in a full matrix-free setting.</li><li><code>ongpu::Bool</code> whether the computation takes place on the gpu (Experimental)</li><li><code>massmatrix</code> a mass matrix. You can pass for example a sparse matrix. Default: identity matrix.</li><li><code>updateSectionEveryStep</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li><li><code>jacobian::Symbol</code> symbol which describes the type of jacobian used in Newton iterations (see below).</li></ul><p>The scheme is as follows. We first consider a partition of <span>$[0,1]$</span> given by <span>$0&lt;s_0&lt;\cdots&lt;s_m=1$</span> and one looks for <code>T = x[end]</code> such that</p><p><span>$M_a\cdot\left(x_{i} - x_{i-1}\right) - \frac{T\cdot h_i}{2} \left(F(x_{i}) + F(x_{i-1})\right) = 0,\ i=1,\cdots,m-1$</span></p><p>with <span>$u_{0} := u_{m-1}$</span> and the periodicity condition <span>$u_{m} - u_{1} = 0$</span> and</p><p>where <span>$h_1 = s_i-s_{i-1}$</span>. <span>$M_a$</span> is a mass matrix. Finally, the phase of the periodic orbit is constrained by using a section (but you could use your own)</p><p><span>$\sum_i\langle x_{i} - x_{\pi,i}, \phi_{i}\rangle=0.$</span></p><p><strong>Orbit guess</strong></p><p>You will see below that you can evaluate the residual of the functional (and other things) by calling <code>pb(orbitguess, p)</code> on an orbit guess <code>orbitguess</code>. Note that <code>orbitguess</code> must be a vector of size M * N + 1 where N is the number of unknowns in the state space and <code>orbitguess[M*N+1]</code> is an estimate of the period <span>$T$</span> of the limit cycle. More precisely, using the above notations, <code>orbitguess</code> must be <span>$orbitguess = [x_{1},x_{2},\cdots,x_{M}, T]$</span>.</p><p>Note that you can generate this guess from a function solution using <code>generateSolution</code>.</p><p><strong>Functional</strong></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>pb(orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, p, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb(Val(:JacFullSparse), orbitguess, p)</code> return the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code> without the constraints. It is called <code>A_γ</code> in the docs.</li><li><code>pb(Val(:JacFullSparseInplace), J, orbitguess, p)</code>. Same as <code>pb(Val(:JacFullSparse), orbitguess, p)</code> but overwrites <code>J</code> inplace. Note that the sparsity pattern must be the same independently of the values of the parameters or of <code>orbitguess</code>. In this case, this is significantly faster than <code>pb(Val(:JacFullSparse), orbitguess, p)</code>.</li><li><code>pb(Val(:JacCyclicSparse), orbitguess, p)</code> return the sparse cyclic matrix Jc (see the docs) of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code></li><li><code>pb(Val(:BlockDiagSparse), orbitguess, p)</code> return the diagonal of the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code>. This allows to design Jacobi preconditioner. Use <code>blockdiag</code>.</li></ul><p><strong>Jacobian</strong></p><p>Specify the choice of the jacobian (and linear algorithm), <code>jacobian</code> must belong to <code>[:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.</p><ul><li>For <code>jacobian = :FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>jacobian = :FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>jacobian = :DenseAD</code>, evaluate the jacobian using ForwardDiff</li><li>For <code>jacobian = :BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver.</li><li>For <code>jacobian = :BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:BorderedLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>jacobian = :BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li><li>For <code>jacobian = :FullMatrixFreeAD</code>, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.</li></ul><div class="admonition is-info"><header class="admonition-header">GPU call</header><div class="admonition-body"><p>For these methods to work on the GPU, for example with <code>CuArrays</code> in mode <code>allowscalar(false)</code>, we face the issue that the function <code>extractPeriodFDTrap</code> won&#39;t be well defined because it is a scalar operation. Note that you must pass the option <code>ongpu = true</code> for the functional to be evaluated efficiently on the gpu.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PeriodicOrbitOCollProblem" href="#BifurcationKit.PeriodicOrbitOCollProblem"><code>BifurcationKit.PeriodicOrbitOCollProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = PeriodicOrbitOCollProblem(kwargs...)</code></pre><p>This composite type implements an orthogonal collocation (at Gauss points) method of piecewise polynomials to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitCollocation/">here</a>.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code> a bifurcation problem</li><li><code>ϕ::AbstractVector</code> used to set a section for the phase constraint equation</li><li><code>xπ::AbstractVector</code> used in the section for the phase constraint equation</li><li><code>N::Int</code> dimension of the state space</li><li><code>mesh_cache::MeshCollocationCache</code> cache for collocation. See docs of <code>MeshCollocationCache</code></li><li><code>updateSectionEveryStep</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li><li><code>jacobian::Symbol</code> symbol which describes the type of jacobian used in Newton iterations. Can only be <code>:autodiffDense</code>.</li><li><code>meshadapt::Bool = false</code> whether to use mesh adaptation</li><li><code>verboseMeshAdapt::Bool = true</code> verbose mesh adaptation information</li><li><code>K::Float64 = 500</code> parameter for mesh adaptation, control new mesh step size</li></ul><p><strong>Methods</strong></p><p>Here are some useful methods you can apply to <code>pb</code></p><ul><li><code>length(pb)</code> gives the total number of unknowns</li><li><code>size(pb)</code> returns the triplet <code>(N, m, Ntst)</code></li><li><code>getMesh(pb)</code> returns the mesh <code>0 = τ0 &lt; ... &lt; τNtst+1 = 1</code>. This is useful because this mesh is born to vary by automatic mesh adaptation</li><li><code>getMeshColl(pb)</code> returns the (static) mesh <code>0 = σ0 &lt; ... &lt; σm+1 = 1</code></li><li><code>getTimes(pb)</code> returns the vector of times (length <code>1 + m * Ntst</code>) at the which the collocation is applied.</li><li><code>generateSolution(pb, orbit, period)</code> generate a guess from a function <code>t -&gt; orbit(t)</code> which approximates the periodic orbit.</li><li><code>POSolution(pb, x)</code> return a function interpolating the solution <code>x</code> using a piecewise polynomials function</li></ul><p><strong>Orbit guess</strong></p><p>You will see below that you can evaluate the residual of the functional (and other things) by calling <code>pb(orbitguess, p)</code> on an orbit guess <code>orbitguess</code>. Note that <code>orbitguess</code> must be of size 1 + N * (1 + m * Ntst) where N is the number of unknowns in the state space and <code>orbitguess[end]</code> is an estimate of the period <span>$T$</span> of the limit cycle.</p><p><strong>Constructors</strong></p><ul><li><code>PeriodicOrbitOCollProblem(Ntst::Int, m::Int; kwargs)</code> creates an empty functional with <code>Ntst</code>and <code>m</code>.</li></ul><p>Note that you can generate this guess from a function using <code>generateSolution</code>.</p><p><strong>Functional</strong></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>pb(orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ShootingProblem" href="#BifurcationKit.ShootingProblem"><code>BifurcationKit.ShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = ShootingProblem(flow::Flow, ds, section; parallel = false)</code></pre><p>Create a problem to implement the Standard Simple / Parallel Multiple Standard Shooting method to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>ds</code>: vector of time differences for each shooting. Its length is written <code>M</code>. If <code>M == 1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>section</code>: implements a phase condition. The evaluation <code>section(x, T)</code> must return a scalar number where <code>x</code> is a guess for <strong>one point</strong> on the periodic orbit and <code>T</code> is the period of the guess. Also, the method <code>section(x, T, dx, dT)</code> must be available and which returns the differential of <code>section</code>. The type of <code>x</code> depends on what is passed to the newton solver. See <a href="#BifurcationKit.SectionSS"><code>SectionSS</code></a> for a type of section defined as a hyperplane.</li><li><code>parallel</code> whether the shooting is computed in parallel (threading). Available through the use of Flows defined by <code>EnsembleProblem</code> (this is automatically set up for you).</li><li><code>par</code> parameters of the model</li><li><code>lens</code> parameter axis</li><li><code>updateSectionEveryStep</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li><li><code>jacobian::Symbol</code> symbol which describes the type of jacobian used in Newton iterations (see below).</li></ul><p>A functional, hereby called <code>G</code>, encodes the shooting problem. For example, the following methods are available:</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du; δ = 1e-9)</code> evaluates the jacobian <code>dG(orbitguess)⋅du</code> functional at <code>orbitguess</code> on <code>du</code>. The optional argument <code>δ</code> is used to compute a finite difference approximation of the derivative of the section.</li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><p>You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size <code>M * N + 1</code> where N is the number of unknowns of the state space and <code>orbitguess[M * N + 1]</code> is an estimate of the period <code>T</code> of the limit cycle. This form of guess is convenient for the use of the linear solvers in <code>IterativeSolvers.jl</code> (for example) which only accept <code>AbstractVector</code>s. Another accepted guess is of the form <code>BorderedArray(guess, T)</code> where <code>guess[i]</code> is the state of the orbit at the <code>i</code>th time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example, use <code>GMRESKrylovKit</code> for the linear solver in this case.</p><p>Note that you can generate this guess from a function solution using <code>generateSolution</code>.</p><p><strong>Jacobian</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Simplified constructors</strong></p><ul><li>The first important constructor is the following which is used for branching to periodic orbits from Hopf bifurcation points</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(M::Int, prob::Union{ODEProblem, EnsembleProblem}, alg; kwargs...)</code></pre><ul><li>A convenient way to build the functional is to use</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, centers::AbstractVector; kwargs...)</code></pre><p>where <code>prob</code> is an <code>ODEProblem</code> (resp. <code>EnsembleProblem</code>) which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). <code>centers</code> is list of <code>M</code> points close to the periodic orbit, they will be used to build a constraint for the phase. <code>parallel = false</code> is an option to use Parallel simulations (Threading) to simulate the multiple trajectories in the case of multiple shooting. This is efficient when the trajectories are relatively long to compute. Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. Look at <code>DifferentialEquations.jl</code> for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.</p><ul><li>Another way to create a Shooting problem with more options is the following where in particular, one can provide its own scalar constraint <code>section(x)::Number</code> for the phase</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, ds, section; parallel = false, kwargs...)</code></pre><ul><li>The next way is an elaboration of the previous one</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="nohighlight hljs">pb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, ds, section; parallel = false, kwargs...)</code></pre><p>where we supply now two <code>ODEProblem</code>s. The first one <code>prob1</code>, is used to define the flow associated to <code>F</code> while the second one is a problem associated to the derivative of the flow. Hence, <code>prob2</code> must implement the following vector field <span>$\tilde F(x,y,p) = (F(x,p), dF(x,p)\cdot y)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PoincareShootingProblem" href="#BifurcationKit.PoincareShootingProblem"><code>BifurcationKit.PoincareShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>pb = PoincareShootingProblem(flow::Flow, M, sections; δ = 1e-8, interp_points = 50, parallel = false)</code></p><p>This composite type implements the Poincaré Shooting method to locate periodic orbits by relying on Poincaré return maps. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>M</code>: the number of Poincaré sections. If <code>M == 1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>sections</code>: function or callable struct which implements a Poincaré section condition. The evaluation <code>sections(x)</code> must return a scalar number when <code>M == 1</code>. Otherwise, one must implement a function <code>section(out, x)</code> which populates <code>out</code> with the <code>M</code> sections. See <a href="#BifurcationKit.SectionPS"><code>SectionPS</code></a> for type of section defined as a hyperplane.</li><li><code>δ = 1e-8</code> used to compute the jacobian of the functional by finite differences. If set to <code>0</code>, an analytical expression of the jacobian is used instead.</li><li><code>interp_points = 50</code> number of interpolation point used to define the callback (to compute the hitting of the hyperplane section)</li><li><code>parallel = false</code> whether the shooting are computed in parallel (threading). Only available through the use of Flows defined by <code>EnsembleProblem</code>.</li><li><code>par</code> parameters of the model</li><li><code>lens</code> parameter axis</li><li><code>updateSectionEveryStep</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li><li><code>jacobian::Symbol</code> symbol which describes the type of jacobian used in Newton iterations (see below).</li></ul><p><strong>Jacobian</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Simplified constructors</strong></p><ul><li>The first important constructor is the following which is used for branching to periodic orbits from Hopf bifurcation points</li></ul><pre><code class="nohighlight hljs">pb = PoincareShootingProblem(M::Int, prob::Union{ODEProblem, EnsembleProblem}, alg; kwargs...)</code></pre><ul><li>A convenient way is to create a functional is</li></ul><p><code>pb = PoincareShootingProblem(prob::ODEProblem, alg, section; kwargs...)</code></p><p>for simple shooting or</p><p><code>pb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; kwargs...)</code></p><p>for multiple shooting . Here <code>prob</code> is an <code>Union{ODEProblem, EnsembleProblem}</code> which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. We refer to <code>DifferentialEquations.jl</code> for more information.</p><ul><li>Another convenient call is</li></ul><p><code>pb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)</code></p><p>where <code>normals</code> (resp. <code>centers</code>) is a list of normals (resp. centers) which defines a list of hyperplanes <span>$\Sigma_i$</span>. These hyperplanes are used to define partial Poincaré return maps.</p><p><strong>Computing the functionals</strong></p><p>A functional, hereby called <code>G</code> encodes this shooting problem. You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size M * N where N is the number of unknowns in the state space and <code>M</code> is the number of Poincaré maps. Another accepted <code>guess</code> is such that <code>guess[i]</code> is the state of the orbit on the <code>i</code>th section. This last form allows for non-vector state space which can be convenient for 2d problems for example.</p><p>Note that you can generate this guess from a function solution using <code>generateSolution</code>.</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can use the function <code>getPeriod(pb, sol, par)</code> to get the period of the solution <code>sol</code> for the problem with parameters <code>par</code>.</p></div></div></div></section></article><h3 id="Waves"><a class="docs-heading-anchor" href="#Waves">Waves</a><a id="Waves-1"></a><a class="docs-heading-anchor-permalink" href="#Waves" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.TWProblem" href="#BifurcationKit.TWProblem"><code>BifurcationKit.TWProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TWProblem(prob, ∂::Tuple, u₀; DAE = 0, jacobian::Symbol = :AutoDiff)</p><p>This composite type implements a functional for freezing symmetries in order, for example, to compute travelling waves (TW). Note that you can freeze many symmetries, not just one, by passing many Lie generators. When you call <code>pb(x, par)</code>, it computes:</p><pre><code class="nohighlight hljs">				┌                   ┐
				│ f(x, par) - s⋅∂⋅x │
				│   &lt;x - u₀, ∂⋅u₀&gt;  │
				└                   ┘</code></pre><p><strong>Arguments</strong></p><ul><li><code>prob</code> bifurcation problem with continuous symmetries</li><li><code>∂::Tuple = (T1, T2, ⋯)</code> tuple of Lie generators. In effect, each of these is an (differential) operator which can be specified as a (sparse) matrix or as an operator implementing <code>LinearAlgebra.mul!</code>.</li><li><code>u₀</code> reference solution</li></ul><p><strong>Additional Constructor(s)</strong></p><pre><code class="nohighlight hljs">pb = TWProblem(prob, ∂, u₀; kw...)</code></pre><p>This simplified call handles the case where a single symmetry needs to be frozen.</p><p><strong>Useful function</strong></p><ul><li><code>updateSection!(pb::TWProblem, u0)</code> updates the reference solution of the problem using <code>u0</code>.</li><li><code>nbConstraints(::TWProblem)</code> number of constraints (or Lie generators)</li></ul></div></section></article><h2 id="Newton"><a class="docs-heading-anchor" href="#Newton">Newton</a><a id="Newton-1"></a><a class="docs-heading-anchor-permalink" href="#Newton" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newton" href="#BifurcationKit.newton"><code>BifurcationKit.newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">	newton(prob::AbstractBifurcationProblem, options::NewtonPar; normN = norm, callback = (;x, fx, J, residual, step, itlinear, options, x0, residuals; kwargs...) -&gt; true, kwargs...)</code></pre><p>This is the Newton-Krylov Solver for <code>F(x, p0) = 0</code> with Jacobian w.r.t. <code>x</code> written <code>J(x, p0)</code> and initial guess <code>x0</code>. The function <code>normN</code> allows to specify a norm for the convergence criteria. It is important to set the linear solver <code>options.linsolver</code> properly depending on your problem. This linear solver is used to solve <span>$J(x, p_0)u = -F(x, p_0)$</span> in the Newton step. You can for example use <code>linsolver = DefaultLS()</code> which is the operator backslash: it works well for Sparse / Dense matrices. See <a href="../linearsolver/#Linear-solvers-(LS)">Linear solvers (LS)</a> for more informations.</p><p><strong>Arguments:</strong></p><ul><li><code>prob</code> a <code>::AbstractBifurcationProblem</code>, typically a  <a href="#BifurcationKit.BifurcationProblem"><code>BifurcationProblem</code></a> which holds the vector field and its jacobian. We also refer to  <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a> for more details.</li><li><code>options::NewtonPar</code> variable holding the internal parameters used by the <code>newton</code> method</li><li><code>callback</code> function passed by the user which is called at the end of each iteration. The default one is the following <code>cbDefault((x, fx, J, residual, step, itlinear, options, x0, residuals); k...) = true</code>. Can be used to update a preconditionner for example. You can use for example <code>cbMaxNorm</code> to limit the residuals norms. If yo  want to specify your own, the arguments passed to the callback are as follows<ul><li><code>x</code> current solution</li><li><code>fx</code> current residual</li><li><code>J</code> current jacobian</li><li><code>residual</code> current norm of the residual</li><li><code>step</code> current newton step</li><li><code>itlinear</code> number of iterations to solve the linear system</li><li><code>options</code> a copy of the argument <code>options</code> passed to <code>newton</code></li></ul></li></ul><pre><code class="nohighlight hljs">- `residuals` the history of residuals
- `kwargs` kwargs arguments, contain your initial guess `x0`</code></pre><ul><li><code>kwargs</code> arguments passed to the callback. Useful when <code>newton</code> is called from <code>continuation</code></li></ul><p><strong>Output:</strong></p><ul><li><code>solution::NonLinearSolution</code>, we refer to <a href="#BifurcationKit.NonLinearSolution"><code>NonLinearSolution</code></a> for more information.</li></ul><div class="admonition is-warning"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>Make sure that the linear solver (Matrix-Free...) corresponds to your jacobian (Matrix-Free vs. Matrix based).</p></div></div></div></section><section><div><pre><code class="language-julia hljs">newton(prob, defOp, options)
newton(prob, defOp, options, _linsolver)
</code></pre><p>This is the deflated version of the Krylov-Newton Solver for <code>F(x, p0) = 0</code>.</p><p>We refer to the regular <a href="#BifurcationKit.newton"><code>newton</code></a> for more information. It penalises the roots saved in <code>defOp.roots</code>. The other arguments are as for <code>newton</code>. See <a href="#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a> for more information on <code>defOp</code>.</p><p><strong>Arguments</strong></p><p>Compared to <a href="#BifurcationKit.newton"><code>newton</code></a>, the only different arguments are</p><ul><li><code>defOp::DeflationOperator</code> deflation operator</li><li><code>linsolver</code> linear solver used to invert the Jacobian of the deflated functional.<ul><li>custom solver <code>DeflatedProblemCustomLS()</code> which requires solving two linear systems <code>J⋅x = rhs</code>.</li><li>For other linear solvers <code>&lt;: AbstractLinearSolver</code>, a matrix free method is used for the deflated functional.</li><li>if passed <code>Val(:autodiff)</code>, then <code>ForwardDiff.jl</code> is used to compute the jacobian Matrix of the deflated problem</li><li>if passed <code>Val(:fullIterative)</code>, then a full matrix free method is used for the deflated problem.</li></ul></li></ul></div></section><section><div><p>This specific Newton-Krylov method first tries to converge to a solution <code>sol0</code> close the guess <code>x0</code>. It then attempts to converge from the guess <code>x1</code> while avoiding the previous converged solution close to <code>sol0</code>. This is very handy for branch switching. The method is based on a deflated Newton-Krylov solver.</p></div></section><section><div><pre><code class="language-julia hljs">newton(br, ind_bif)
</code></pre><p>This function turns an initial guess for a Fold/Hopf point into a solution to the Fold/Hopf problem based on a Minimally Augmented formulation.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> results returned after a call to <a href="#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>options::NewtonPar</code>, default value <code>br.contparams.newtonOptions</code></li><li><code>normN = norm</code></li><li><code>options</code> You can pass newton parameters different from the ones stored in <code>br</code> by using this argument <code>options</code>.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>startWithEigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements.</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option <code>bdlinsolver = MatrixBLS()</code></p></div></div><div class="admonition is-success"><header class="admonition-header">startWithEigen</header><div class="admonition-body"><p>It is recommended that you use the option <code>startWithEigen=true</code></p></div></div></div></section><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, options)
</code></pre><p>This is the Newton-Krylov Solver for computing a periodic orbit using the (Standard / Poincaré) Shooting method. Note that the linear solver has to be appropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="../library/#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.</p><ul><li><code>prob</code> a problem of type <code>&lt;: AbstractShootingProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit. See <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> and See <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> for information regarding the shape of <code>orbitguess</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <a href="../library/#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div></section><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, defOp, options)
</code></pre><p>This is the deflated Newton-Krylov Solver for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>.</p><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Output:</strong></p><ul><li>solution::NonLinearSolution, see <a href="#BifurcationKit.NonLinearSolution"><code>NonLinearSolution</code></a></li></ul></div></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, options)
</code></pre><p>This is the Krylov-Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments:</strong></p><ul><li><code>prob</code> a problem of type <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a> encoding the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It should be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <code>newton</code> method</li></ul><p>Specify the choice of the jacobian (and linear algorithm), <code>jacobian</code> must belong to <code>[:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.</p><ul><li>For <code>jacobian = :FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>jacobian = :FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>jacobian = :DenseAD</code>, evaluate the jacobian using ForwardDiff</li><li>For <code>jacobian = :BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver.</li><li>For <code>jacobian = :BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:BorderedLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>jacobian = :BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li><li>For <code>jacobian = :FullMatrixFreeAD</code>, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.</li></ul></div></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, defOp, options)
</code></pre><p>This function is similar to <code>newton(probPO, orbitguess, options, jacobianPO; kwargs...)</code> except that it uses deflation in order to find periodic orbits different from the ones stored in <code>defOp</code>. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.</p></div></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, options)
</code></pre><p>This is the Newton Solver for computing a periodic orbit using orthogonal collocation method. Note that the linear solver has to be apropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="../library/#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is a <a href="../library/#BifurcationKit.PeriodicOrbitOCollProblem"><code>PeriodicOrbitOCollProblem</code></a>.</p><ul><li><code>prob</code> a problem of type <code>&lt;: PeriodicOrbitOCollProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit.</li><li><code>options</code> same as for the regular <a href="../library/#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>(:autodiffDense, )</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>:autodiffDense</code>. The jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>. The jacobian is formed inplace.</li></ul></li></ul></div></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, defOp, options)
</code></pre><p>This function is similar to <code>newton(probPO, orbitguess, options, jacobianPO; kwargs...)</code> except that it uses deflation in order to find periodic orbits different from the ones stored in <code>defOp</code>. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.</p></div></section></article><h2 id="Library-Continuation"><a class="docs-heading-anchor" href="#Library-Continuation">Continuation</a><a id="Library-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Continuation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DotTheta" href="#BifurcationKit.DotTheta"><code>BifurcationKit.DotTheta</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DotTheta{Tdot, Ta}</code></pre><ul><li><p><code>dot::Any</code></p><p>dot product used in pseudo-arclength constraint</p></li><li><p><code>apply!::Any</code></p><p>Linear operator associated with dot product, i.e. dot(x, y) = &lt;x, Ay&gt;, where &lt;,&gt; is the standard dot product on R^N. You must provide an inplace function which evaluates A. For example <code>x -&gt; rmul!(x, 1/length(x))</code>.</p></li></ul><p>This parametric type allows to define a new dot product from the one saved in <code>dt::dot</code>. More precisely:</p><pre><code class="nohighlight hljs">dt(u1, u2, p1::T, p2::T, theta::T) where {T &lt;: Real}</code></pre><p>computes, the weighted dot product <span>$\langle (u_1,p_1), (u_2,p_2)\rangle_\theta = \theta \Re \langle u_1,u_2\rangle  +(1-\theta)p_1p_2$</span> where <span>$u_i\in\mathbb R^N$</span>. The <span>$\Re$</span> factor is put to ensure a real valued result despite possible complex valued arguments.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This is used in the pseudo-arclength constraint with the dot product <span>$\frac{1}{N} \langle u_1, u_2\rangle,\quad u_i\in\mathbb R^N$</span></p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation" href="#BifurcationKit.continuation"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuation(prob, alg, contParams)
</code></pre><p>Compute the continuation curve associated to the functional <code>F</code> which is stored in the bifurcation problem <code>prob</code>. General information is available in <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/IntroContinuation/">Continuation methods: introduction</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>prob::AbstractBifurcationFunction</code> a <code>::AbstractBifurcationProblem</code>, typically a  <a href="#BifurcationKit.BifurcationProblem"><code>BifurcationProblem</code></a> which holds the vector field and its jacobian. We also refer to  <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a> for more details.</li><li><code>alg</code> continuation algorithm, for example <code>Natural(), PALC(), Multiple(),...</code>. See <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/Predictors/">algos</a></li><li><code>contParams</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a></li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plot = false</code> whether to plot the solution/branch/spectrum while computing the branch</li><li><code>bothside = true</code> compute the branches on the two sides of <code>p0</code>, merge them and return it.</li><li><code>finaliseSolution = (z, tau, step, contResult; kwargs...) -&gt; true</code> Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning <code>false</code>), saving personal data, plotting... The notations are <span>$z=(x, p)$</span> where <code>x</code> (resp. <code>p</code>) is the current solution (resp. parameter value), <code>tau</code> is the tangent at <code>z</code>, <code>step</code> is the index of the current continuation step and <code>ContResult</code> is the current branch. For advanced use, the current <code>state::ContState</code> of the continuation is passed in <code>kwargs</code>. Note that you can have a better control over the continuation procedure by using an iterator, see <a href="../iterator/#Iterator-Interface">Iterator Interface</a>.</li><li><code>verbosity::Int = 0</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,1,2,3}</code>. In case <code>contParams.newtonOptions.verbose = false</code>, the following is valid (Otherwise the newton iterations are shown). Each case prints more information than the previous one:<ul><li>case 0: print nothing</li><li>case 1: print basic information about the continuation: used predictor, step size and parameter values</li><li>case 2: print newton iterations number, stability of solution, detected bifurcations / events</li><li>case 3: print information during bisection to locate bifurcations / events</li></ul></li><li><code>normC = norm</code> norm used in the Newton solves</li><li><code>filename</code> to save the computed branch during continuation. The identifier .jld2 will be appended to this filename. This requires <code>using JLD2</code>.</li><li><code>callbackN</code> callback for newton iterations. See docs for <a href="#BifurcationKit.newton"><code>newton</code></a>. For example, it can be used to change preconditioners.</li><li><code>kind::AbstractContinuationKind</code> [Internal] flag to describe continuation kind (equilibrium, codim 2, ...). Default = <code>EquilibriumCont()</code></li></ul><p><strong>Output:</strong></p><ul><li><code>contres::ContResult</code> composite type which contains the computed branch. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information.</li></ul><div class="admonition is-success"><header class="admonition-header">Continuing the branch in the opposite direction</header><div class="admonition-body"><p>Just change the sign of <code>ds</code> in <code>ContinuationPar</code>.</p></div></div></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, algdc, contParams)
</code></pre><p>This function computes the set of curves of solutions <code>γ(s) = (x(s), p(s))</code> to the equation <code>F(x,p) = 0</code> based on the algorithm of <strong>deflated continuation</strong> as described in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. “The Computation of Disconnected Bifurcation Diagrams.” ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.</p><p>Depending on the options in <code>contParams</code>, it can locate the bifurcation points on each branch. Note that you can specify different predictors using <code>alg</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>prob::AbstractBifurcationProblem</code> bifurcation problem</li><li><code>alg::DefCont</code>, deflated continuation algorithm, see <a href="#BifurcationKit.DefCont"><code>DefCont</code></a></li><li><code>contParams</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a> for more information about the options</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plot = false</code> whether to plot the solution while computing,</li><li><code>callbackN</code> callback for newton iterations. see docs for <code>newton</code>. Can be used to change preconditioners or affect the newton iterations. In the deflation part of the algorithm, when seeking for new branches, the callback is passed the keyword argument <code>fromDeflatedNewton = true</code> to tell the user can it is not in the continuation part (regular newton) of the algorithm,</li><li><code>verbosity::Int</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,⋯,5}</code>,</li><li><code>normN = norm</code> norm used in the Newton solves,</li><li><code>dotPALC = (x, y) -&gt; dot(x, y) / length(x)</code>, dot product used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see online docs on <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/PALC/">PALC</a>). This argument can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...),</li></ul><p><strong>Outputs:</strong></p><ul><li><code>contres::DCResult</code> composite type which contains the computed branches. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information,</li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif, lens2)
continuation(br, ind_bif, lens2, options_cont)
</code></pre><p>Codimension 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold/Hopf point into a curve of Fold/Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>br</code> results returned after a call to <a href="#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li><li><code>lens2</code> second parameter used for the continuation, the first one is the one used to compute <code>br</code>, e.g. <code>getLens(br)</code></li><li><code>options_cont = br.contparams</code> arguments to be passed to the regular <a href="#Library-Continuation">continuation</a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>updateMinAugEveryStep</code> update vectors <code>a,b</code> in Minimally Formulation every <code>updateMinAugEveryStep</code> steps</li><li><code>startWithEigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements</li><li><code>detectCodim2Bifurcation ∈ {0,1,2}</code> whether to detect Bogdanov-Takens, Bautin and Cusp. If equals <code>1</code> non precise detection is used. If equals <code>2</code>, a bisection method is used to locate the bifurcations.</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="#Library-Continuation">continuation</a></li></ul><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Hopf point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option <code>bdlinsolver = MatrixBLS()</code></p></div></div><div class="admonition is-success"><header class="admonition-header">startWithEigen</header><div class="admonition-body"><p>It is recommended that you use the option <code>startWithEigen = true</code></p></div></div></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, x0, par0, x1, p1, alg, lens, contParams)
</code></pre><p>[Internal] This function is not meant to be called directly.</p><p>This function is the analog of <a href="#BifurcationKit.continuation"><code>continuation</code></a> when the first two points on the branch are passed (instead of a single one). Hence <code>x0</code> is the first point on the branch (with palc <code>s=0</code>) with parameter <code>par0</code> and <code>x1</code> is the second point with parameter <code>set(par0, lens, p1)</code>.</p></div></section><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif)
continuation(br, ind_bif, optionsCont)
</code></pre><p>Automatic branch switching at branch points based on a computation of the normal form. More information is provided in <a href="../branchswitching/#Branch-switching-page">Branch switching</a>. An example of use is provided in <a href="../tutorials/mittelmann/#d-generalized-Bratu–Gelfand-problem">2d generalized Bratu–Gelfand problem</a>.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br</code> from which you want to branch from</li><li><code>optionsCont</code> options for the call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm to be used, default value: <code>br.alg</code></li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>optionsCont.ds</code>. This allows to use a step larger than <code>optionsCont.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alters the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated</li><li><code>plotSolution</code> change plot solution method in the problem <code>br.prob</code></li><li><code>kwargs</code> optional arguments to be passed to <a href="#BifurcationKit.continuation"><code>continuation</code></a>, the regular <code>continuation</code> one.</li></ul><div class="admonition is-success"><header class="admonition-header">Advanced use</header><div class="admonition-body"><p>In the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at <code>methods(BifurcationKit.multicontinuation)</code> to see how to call these versions. These methods has been tested on GPU with very high memory pressure.</p></div></div></div></section><section><div><pre><code class="language-julia hljs">continuation(probPO, orbitguess, alg, contParams, linearAlgo)
</code></pre><p>This is the continuation method for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> except that <code>probPO</code> is either a <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Optional arguments</strong></p><ul><li><code>eigsolver</code> specify an eigen solver for the computation of the Floquet exponents, defaults to <code>FloquetQaD</code></li><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, orbitguess, alg, _contParams)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Optional argument</strong></p><ul><li><code>linearAlgo::AbstractBorderedLinearSolver</code></li><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences, :FiniteDifferencesDense]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif, _contParams, probPO)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points of a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>probPO</code> problem used to specify the way the periodic orbit is computed. It can be <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>, <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li>all <code>kwargs</code> from <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plotSolution</code> and <code>finaliseSolution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be careful about the options <code>contParams.newtonOptions.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div></div></section><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif, _contParams)
</code></pre><p>Branch switching at a bifurcation point on a branch of periodic orbits (PO) specified by a <code>br::AbstractBranchResult</code>. The functional used to compute the PO is <code>br.prob</code>. A deflated Newton-Krylov solver can be used to improve the branch switching capabilities.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch of periodic orbits computed with a <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a></li><li><code>ind_bif</code> index of the branch point</li><li><code>_contParams</code> parameters to be used by a regular <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>δp = 0.1</code> used to specify a particular guess for the parameter in the branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>detailed = false</code> fully compute the normal form</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>recordFromSolution = (u, p) -&gt; u[end]</code>, record method used in the bifurcation diagram, by default this records the period of the periodic orbit.</li><li><code>linearAlgo = BorderingBLS()</code>, same as for <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>kwargs</code> keywords arguments used for a call to the regular <a href="#BifurcationKit.continuation"><code>continuation</code></a> and the ones specific to periodic orbits (POs).</li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, orbitguess, alg, _contParams)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PeriodicOrbitTrapProblem</code> encodes the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It could be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</li><li><code>alg</code> continuation algorithm</li><li><code>contParams</code> same as for the regular <a href="#BifurcationKit.continuation"><code>continuation</code></a> method</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>linearAlgo</code> same as in <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>Specify the choice of the jacobian (and linear algorithm), <code>jacobian</code> must belong to <code>[:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.</p><ul><li>For <code>jacobian = :FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>jacobian = :FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>jacobian = :DenseAD</code>, evaluate the jacobian using ForwardDiff</li><li>For <code>jacobian = :BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver.</li><li>For <code>jacobian = :BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:BorderedLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>jacobian = :BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li><li>For <code>jacobian = :FullMatrixFreeAD</code>, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.</li></ul><p>Note that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your <code>recordFromSolution</code> argument.</p></div></section><section><div><pre><code class="language-julia hljs">continuation(probPO, orbitguess, alg, _contParams, linearAlgo)
</code></pre><p>This is the continuation method for computing a periodic orbit using an orthogonal collocation method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is a <a href="#BifurcationKit.PeriodicOrbitOCollProblem"><code>PeriodicOrbitOCollProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Keywords arguments</strong></p><ul><li><code>eigsolver</code> specify an eigen solver for the computation of the Floquet exponents, defaults to <code>FloquetQaD</code></li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, alg, contParams)
</code></pre><p><strong>Arguments</strong></p><ul><li><code>prob::BifurcationProblem</code></li><li><code>alg::</code> ANM continuation algorithm. See <a href="#AsymptoticNumericalMethod.ANM"><code>ANM</code></a>.</li><li><code>contParams</code> see <a href="#BifurcationKit.ContinuationPar"><code>BK.ContinuationPar</code></a></li></ul></div></section></article><h2 id="Continuation-algorithms"><a class="docs-heading-anchor" href="#Continuation-algorithms">Continuation algorithms</a><a id="Continuation-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Natural" href="#BifurcationKit.Natural"><code>BifurcationKit.Natural</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Natural continuation algorithm.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Secant" href="#BifurcationKit.Secant"><code>BifurcationKit.Secant</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Secant Tangent predictor</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Bordered" href="#BifurcationKit.Bordered"><code>BifurcationKit.Bordered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bordered Tangent predictor</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Polynomial" href="#BifurcationKit.Polynomial"><code>BifurcationKit.Polynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Polynomial Tangent predictor</code></pre><ul><li><p><code>n::Int64</code></p><p>Order of the polynomial</p></li><li><p><code>k::Int64</code></p><p>Length of the last solutions vector used for the polynomial fit</p></li><li><p><code>A::Matrix{T} where T&lt;:Real</code></p><p>Matrix for the interpolation</p></li><li><p><code>tangent::BifurcationKit.AbstractTangentComputation</code></p><p>Algo for tangent when polynomial predictor is not possible</p></li><li><p><code>solutions::DataStructures.CircularBuffer</code></p><p>Vector of solutions</p></li><li><p><code>parameters::DataStructures.CircularBuffer{T} where T&lt;:Real</code></p><p>Vector of parameters</p></li><li><p><code>arclengths::DataStructures.CircularBuffer{T} where T&lt;:Real</code></p><p>Vector of arclengths</p></li><li><p><code>coeffsSol::Vector</code></p><p>Coefficients for the polynomials for the solution</p></li><li><p><code>coeffsPar::Vector{T} where T&lt;:Real</code></p><p>Coefficients for the polynomials for the parameter</p></li><li><p><code>update::Bool</code></p><p>Update the predictor by adding the last point (x, p)? This can be disabled in order to just use the polynomial prediction. It is useful when the predictor is called mutiple times during bifurcation detection using bisection.</p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="nohighlight hljs">Polynomial(pred, n, k, v0)

Polynomial(n, k, v0)</code></pre><ul><li><code>n</code> order of the polynomial</li><li><code>k</code> length of the last solutions vector used for the polynomial fit</li><li><code>v0</code> example of solution to be stored. It is only used to get the <code>eltype</code> of the tangent!!</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Multiple" href="#BifurcationKit.Multiple"><code>BifurcationKit.Multiple</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Multiple Tangent continiation algorithm.</code></pre><ul><li><p><code>alg::PALC</code></p><p>Tangent predictor used Default: PALC()</p></li><li><p><code>τ::Any</code></p><p>Save the current tangent</p></li><li><p><code>α::Real</code></p><p>Damping in Newton iterations, 0 &lt; α &lt; 1</p></li><li><p><code>nb::Int64</code></p><p>Number of predictors</p></li><li><p><code>currentind::Int64</code></p><p>Index of the largest converged predictor Default: 0</p></li><li><p><code>pmimax::Int64</code></p><p>Index for lookup in residual history Default: 1</p></li><li><p><code>imax::Int64</code></p><p>Maximum index for lookup in residual history Default: 4</p></li><li><p><code>dsfact::Real</code></p><p>Factor to increase ds upon successful step Default: 1.5</p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="nohighlight hljs">Multiple(alg, x0, α, n)

Multiple(pred, x0, α, n)

Multiple(x0, α, n)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PALC" href="#BifurcationKit.PALC"><code>BifurcationKit.PALC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PALC{Ttang&lt;:BifurcationKit.AbstractTangentComputation, Tbls&lt;:BifurcationKit.AbstractLinearSolver, T, Tdot} &lt;: BifurcationKit.AbstractContinuationAlgorithm</code></pre><p>Pseudo-arclength continuation algorithm.</p><p>Additional information is available on the <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/PALC/">website</a>.</p><p><strong>Fields</strong></p><ul><li><p><code>tangent::BifurcationKit.AbstractTangentComputation</code></p><p>Tangent predictor, must be a subtype of <code>AbstractTangentComputation</code>. For example <code>Secant()</code> or <code>Bordered()</code>,  Default: Secant()</p></li><li><p><code>θ::Any</code></p><p><code>θ</code> is a parameter in the arclength constraint. It is very <strong>important</strong> to tune it. It should be tuned for the continuation to work properly especially in the case of large problems where the &lt; x - x<em>0, dx</em>0 &gt; component in the constraint equation might be favoured too much. Also, large thetas favour p as the corresponding term in N involves the term 1-theta. Default: 0.5</p></li><li><p><code>_bothside::Bool</code></p><p>[internal],  Default: false</p></li><li><p><code>bls::BifurcationKit.AbstractLinearSolver</code></p><p>Bordered linear solver used to invert the jacobian of the newton bordered problem. It is also used to compute the tangent for the predictor <code>Bordered()</code>,  Default: MatrixBLS()</p></li><li><p><code>doArcLengthScaling::Bool</code></p><p>Unused for now,  Default: false</p></li><li><p><code>gGoal::Any</code></p><p>Unused for now,  Default: 0.5</p></li><li><p><code>gMax::Any</code></p><p>Unused for now,  Default: 0.8</p></li><li><p><code>θMin::Any</code></p><p>Unused for now,  Default: 0.001</p></li><li><p><code>dotθ::Any</code></p><p><code>dotθ = DotTheta()</code>, this sets up a dot product <code>(x, y) -&gt; dot(x, y) / length(x)</code> used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see online docs on <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/PALC/">PALC</a>). This argument can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...) Default: DotTheta()</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.MoorePenrose" href="#BifurcationKit.MoorePenrose"><code>BifurcationKit.MoorePenrose</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Moore-Penrose predictor / corrector</code></pre><p>Moore-Penrose continuation algorithm.</p><p>Additional information is available on the <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/MooreSpence/">website</a>.</p><p><strong>Constructors</strong></p><p><code>alg = MoorePenrose()</code></p><p><code>alg = MoorePenrose(tangent = PALC())</code></p><p><strong>Fields</strong></p><ul><li><p><code>tangent::Any</code></p><p>Tangent predictor, example <code>PALC()</code></p></li><li><p><code>method::MoorePenroseLS</code></p><p>Use a direct linear solver. Can be BifurcationKit.direct, BifurcationKit.pInv or BifurcationKit.iterative</p></li><li><p><code>ls::BifurcationKit.AbstractLinearSolver</code></p><p>(Bordered) linear solver</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DefCont" href="#BifurcationKit.DefCont"><code>BifurcationKit.DefCont</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DefCont{Tdo, Talg, Tps, Tas, Tud, Tk} &lt;: BifurcationKit.AbstractContinuationAlgorithm</code></pre><p>Structure which holds the parameters specific to Deflated continuation.</p><p><strong>Fields</strong></p><ul><li><p><code>deflationOperator::Any</code></p><p>Deflation operator, <code>::DeflationOperator</code> Default: nothing</p></li><li><p><code>alg::Any</code></p><p>Used as a predictor, <code>::AbstractContinuationAlgorithm</code>. For example <code>PALC()</code>, <code>Natural()</code>,... Default: PALC()</p></li><li><p><code>maxBranches::Int64</code></p><p>maximum number of (active) branches to be computed Default: 100</p></li><li><p><code>seekEveryStep::Int64</code></p><p>whether to seek new (deflated) solution at every step Default: 1</p></li><li><p><code>maxIterDefOp::Int64</code></p><p>maximum number of deflated Newton iterations Default: 5</p></li><li><p><code>perturbSolution::Any</code></p><p>perturb function Default: _perturbSolution</p></li><li><p><code>acceptSolution::Any</code></p><p>accept (solution) function Default: _acceptSolution</p></li><li><p><code>updateDeflationOp::Any</code></p><p>function to update the deflation operator Default: _updateDeflationOp</p></li><li><p><code>jacobian::Any</code></p><p>jacobian for deflated newton. Can be <code>DeflatedProblemCustomLS()</code>, or <code>Val(:autodiff)</code>, <code>Val(:fullIterative)</code> Default: DeflatedProblemCustomLS()</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AsymptoticNumericalMethod.ANM" href="#AsymptoticNumericalMethod.ANM"><code>AsymptoticNumericalMethod.ANM</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Continuation algorithm based on Asymptotic Numerical Method. It can be used from the package https://github.com/bifurcationkit/AsymptoticNumericalMethod.jl</p><p><strong>Fields</strong></p><ul><li><p><code>order::Int64</code></p><p>order of the polynomial approximation</p></li><li><p><code>tol::Any</code></p><p>tolerance which is used to estimate the neighbourhood on which the polynomial approximation is valid</p></li></ul><p><strong>References</strong></p><ul><li><p>Charpentier, Isabelle, Bruno Cochelin, and Komlanvi Lampoh. “Diamanlab - An Interactive Taylor-Based Continuation Tool in MATLAB,” n.d., 12.</p></li><li><p>Rubbert, Lennart, Isabelle Charpentier, Simon Henein, and Pierre Renaud. “Higher-Order Continuation Method for the Rigid-Body Kinematic Design of Compliant Mechanisms”, n.d., 18.</p></li></ul></div></section></article><h2 id="Events"><a class="docs-heading-anchor" href="#Events">Events</a><a id="Events-1"></a><a class="docs-heading-anchor-permalink" href="#Events" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DiscreteEvent" href="#BifurcationKit.DiscreteEvent"><code>BifurcationKit.DiscreteEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiscreteEvent{Tcb, Tl} &lt;: BifurcationKit.AbstractDiscreteEvent</code></pre><p>Structure to pass a DiscreteEvent function to the continuation algorithm. A discrete call back returns a discrete value and we seek when it changes.</p><ul><li><p><code>nb::Int64</code></p><p>number of events, ie the length of the result returned by the callback function</p></li><li><p><code>condition::Any</code></p><p>= <code>(iter, state) -&gt; NTuple{nb, Int64}</code> callback function which at each continuation state, returns a tuple. For example, to detect a value change.</p></li><li><p><code>computeEigenElements::Bool</code></p><p>whether the event requires to compute eigen elements</p></li><li><p><code>labels::Any</code></p><p>Labels used to display information. For example <code>labels[1]</code> is used to qualify an event occurring in the first component. You can use <code>labels = (&quot;hopf&quot;,)</code> or <code>labels = (&quot;hopf&quot;, &quot;fold&quot;)</code>. You must have <code>labels::Union{Nothing, NTuple{N, String}}</code>.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContinuousEvent" href="#BifurcationKit.ContinuousEvent"><code>BifurcationKit.ContinuousEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ContinuousEvent{Tcb, Tl, T} &lt;: BifurcationKit.AbstractContinuousEvent</code></pre><p>Structure to pass a ContinuousEvent function to the continuation algorithm. A continuous call back returns a <strong>tuple/scalar</strong> value and we seek its zeros.</p><ul><li><p><code>nb::Int64</code></p><p>number of events, ie the length of the result returned by the callback function</p></li><li><p><code>condition::Any</code></p><p>, <code>(iter, state) -&gt; NTuple{nb, T}</code> callback function which, at each continuation state, returns a tuple. For example, to detect crossing 1.0 and -2.0, you can pass <code>(iter, state) -&gt; (getp(state)+2, getx(state)[1]-1)),</code>. Note that the type <code>T</code> should match the one of the parameter specified by the <code>::Lens</code> in <code>continuation</code>.</p></li><li><p><code>computeEigenElements::Bool</code></p><p>whether the event requires to compute eigen elements</p></li><li><p><code>labels::Any</code></p><p>Labels used to display information. For example <code>labels[1]</code> is used to qualify an event of the type <code>(0,1.3213,3.434)</code>. You can use <code>labels = (&quot;hopf&quot;,)</code> or <code>labels = (&quot;hopf&quot;, &quot;fold&quot;)</code>. You must have <code>labels::Union{Nothing, NTuple{N, String}}</code>.</p></li><li><p><code>tol::Any</code></p><p>Tolerance on event value to declare it as true event.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SetOfEvents" href="#BifurcationKit.SetOfEvents"><code>BifurcationKit.SetOfEvents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SetOfEvents{Tc&lt;:Tuple, Td&lt;:Tuple} &lt;: BifurcationKit.AbstractEvent</code></pre><p>Multiple events can be chained together to form a <code>SetOfEvents</code>. A <code>SetOfEvents</code> is constructed by passing to the constructor <code>ContinuousEvent</code>, <code>DiscreteEvent</code> or other <code>SetOfEvents</code> instances:</p><pre><code class="nohighlight hljs">SetOfEvents(cb1, cb2, cb3)</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs"> BifurcationKit.SetOfEvents(BK.FoldDetectCB, BK.BifDetectCB)</code></pre><p>You can pass as many events as you like.</p><ul><li><p><code>eventC::Tuple</code></p><p>Continuous event</p></li><li><p><code>eventD::Tuple</code></p><p>Discrete event</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PairOfEvents" href="#BifurcationKit.PairOfEvents"><code>BifurcationKit.PairOfEvents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PairOfEvents{Tc&lt;:BifurcationKit.AbstractContinuousEvent, Td&lt;:BifurcationKit.AbstractDiscreteEvent} &lt;: BifurcationKit.AbstractEvent</code></pre><p>Structure to pass a PairOfEvents function to the continuation algorithm. It is composed of a pair ContinuousEvent / DiscreteEvent. A <code>PairOfEvents</code> is constructed by passing to the constructor a <code>ContinuousEvent</code> and a <code>DiscreteEvent</code>:</p><pre><code class="nohighlight hljs">PairOfEvents(contEvent, discreteEvent)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>eventC::BifurcationKit.AbstractContinuousEvent</code></p><p>Continuous event</p></li><li><p><code>eventD::BifurcationKit.AbstractDiscreteEvent</code></p><p>Discrete event</p></li></ul></div></section></article><h2 id="Branch-switching-(branch-point)"><a class="docs-heading-anchor" href="#Branch-switching-(branch-point)">Branch switching (branch point)</a><a id="Branch-switching-(branch-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(branch-point)" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>continuation(br::ContResult, ind_bif::Int, optionsCont::ContinuationPar ; kwargs...)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Branch-switching-(Hopf-point)"><a class="docs-heading-anchor" href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a><a id="Branch-switching-(Hopf-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(Hopf-point)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}" href="#BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif, _contParams, probPO)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points of a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>probPO</code> problem used to specify the way the periodic orbit is computed. It can be <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>, <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li>all <code>kwargs</code> from <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plotSolution</code> and <code>finaliseSolution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be careful about the options <code>contParams.newtonOptions.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div></div></section></article><h2 id="Bifurcation-diagram"><a class="docs-heading-anchor" href="#Bifurcation-diagram">Bifurcation diagram</a><a id="Bifurcation-diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Bifurcation-diagram" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram" href="#BifurcationKit.bifurcationdiagram"><code>BifurcationKit.bifurcationdiagram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bifurcationdiagram(prob, alg, level, options)
</code></pre><p>Compute the bifurcation diagram associated with the problem <code>F(x, p) = 0</code> recursively.</p><p><strong>Arguments</strong></p><ul><li><code>prob::AbstractBifurcationProblem</code> bifurcation problem</li><li><code>alg</code> continuation algorithm</li><li><code>level</code> maximum branching (or recursion) level for computing the bifurcation diagram</li><li><code>options = (x, p, level) -&gt; contparams</code> this function allows to change the <a href="#BifurcationKit.continuation"><code>continuation</code></a> options depending on the branching <code>level</code>. The argument <code>x, p</code> denotes the current solution to <code>F(x, p)=0</code>.</li><li><code>kwargs</code> optional arguments. Look at <a href="#BifurcationKit.bifurcationdiagram!"><code>bifurcationdiagram!</code></a> for more details.</li></ul><p><strong>Simplified call:</strong></p><p>We also provide the method</p><p><code>bifurcationdiagram(prob, br::ContResult, level::Int, options; kwargs...)</code></p><p>where <code>br</code> is a branch computed after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a> from which we want to compute the bifurcating branches recursively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram!" href="#BifurcationKit.bifurcationdiagram!"><code>BifurcationKit.bifurcationdiagram!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bifurcationdiagram!(prob, node, maxlevel, options)
</code></pre><p>Similar to <a href="#BifurcationKit.bifurcationdiagram"><code>bifurcationdiagram</code></a> but you pass a previously computed <code>node</code> from which you want to further compute the bifurcated branches. It is usually used with <code>node = getBranch(diagram, code)</code> from a previously computed bifurcation <code>diagram</code>.</p><p><strong>Arguments</strong></p><ul><li><code>node::BifDiagNode</code> a node in the bifurcation diagram</li><li><code>maxlevel = 1</code> required maximal level of recursion.</li><li><code>options = (x, p, level) -&gt; contparams</code> this function allows to change the <a href="#BifurcationKit.continuation"><code>continuation</code></a> options depending on the branching <code>level</code>. The argument <code>x, p</code> denotes the current solution to <code>F(x, p)=0</code>.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>code = &quot;0&quot;</code> code used to display iterations</li><li><code>usedeflation = false</code></li><li><code>halfbranch = false</code> for Pitchfork/Transcritical bifurcations, compute only half of the branch. Can be useful when there are symmetries.</li><li><code>kwargs</code> optional arguments as for <a href="#BifurcationKit.continuation"><code>continuation</code></a> but also for the different versions listed in <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/library/#Continuation-1">Continuation</a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getBranch" href="#BifurcationKit.getBranch"><code>BifurcationKit.getBranch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getBranch(tree, code)
</code></pre><p>Return the part of the tree (bifurcation diagram) by recursively descending down the tree using the <code>Int</code> valued tuple <code>code</code>. For example <code>getBranch(tree, (1,2,3,))</code> returns <code>tree.child[1].child[2].child[3]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getBranchesFromBP" href="#BifurcationKit.getBranchesFromBP"><code>BifurcationKit.getBranchesFromBP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getBranchesFromBP(tree, indbif)
</code></pre><p>Return the part of the tree corresponding to the indbif-th bifurcation point on the root branch.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SpecialPoint" href="#BifurcationKit.SpecialPoint"><code>BifurcationKit.SpecialPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SpecialPoint{T, Tp, Tv, Tvτ} &lt;: BifurcationKit.AbstractBifurcationPoint</code></pre><p>Structure to record specials point on the curve. There are two types of specials point that are recorded in this structure: bifurcation points and events (see https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/EventCallback/).</p><ul><li><p><code>type::Symbol</code></p><p>Description of the special point. In case of Events, this field records the user passed named to the event, or the default <code>:userD</code>, <code>:userC</code>. In case of bifurcation points, it can be the following:</p><pre><code class="nohighlight hljs">- :bp Bifurcation point, simple eigenvalue crossing the imaginary axis
- :fold Fold point
- :hopf Hopf point
- :nd not documented bifurcation point. Detected by multiple eigenvalues crossing. Generally occurs in problems with symmetries or in cases where the continuation step size is too large and merge two different bifurcation points.
- :cusp Cusp point
- :gh Generalized Hopf point
- :bt Bogdanov-Takens point
- :zh Zero-Hopf point
- :hh Hopf-Hopf point
- :ns Neimark-Sacker point
- :pd Period-doubling point
 Default: :none</code></pre></li><li><p><code>idx::Int64</code></p><p>Index in <code>br.branch</code> or <code>br.eig</code> (see <a href="#BifurcationKit.ContResult"><code>ContResult</code></a>) for which the bifurcation occurs. Default: 0</p></li><li><p><code>param::Any</code></p><p>Parameter value at the special point (this is an estimate). Default: 0.0</p></li><li><p><code>norm::Any</code></p><p>Norm of the equilibrium at the special point Default: 0.0</p></li><li><p><code>printsol::Any</code></p><p><code>printsol = recordFromSolution(x, param)</code> where <code>recordFromSolution</code> is one of the arguments to <a href="#BifurcationKit.continuation"><code>continuation</code></a> Default: 0.0</p></li><li><p><code>x::Any</code></p><p>Equilibrium at the special point Default: Vector{T}(undef, 0)</p></li><li><p><code>τ::BorderedArray{Tvτ, T} where {T, Tvτ}</code></p><p>Tangent along the branch at the special point Default: BorderedArray(x, T(0))</p></li><li><p><code>ind_ev::Int64</code></p><p>Eigenvalue index responsible for detecting the special point (if applicable) Default: 0</p></li><li><p><code>step::Int64</code></p><p>Continuation step at which the special occurs Default: 0</p></li><li><p><code>status::Symbol</code></p><p><code>status ∈ {:converged, :guess, :guessL}</code> indicates whether the bisection algorithm was successful in detecting the special (bifurcation) point. If <code>status == :guess</code>, the bissection algorithm failed to meet the requirements given in <code>::ContinuationPar</code>. Same for <code>status == :guessL</code> but the bissection algorithm stopped on the left of the bifurcation point. Default: :guess</p></li><li><p><code>δ::Tuple{Int64, Int64}</code></p><p><code>δ = (δr, δi)</code> where δr indicates the change in the number of unstable eigenvalues and δi indicates the change in the number of unstable eigenvalues with nonzero imaginary part. <code>abs(δr)</code> is thus an estimate of the dimension of the kernel of the Jacobian at the special (bifurcation) point. Default: (0, 0)</p></li><li><p><code>precision::Any</code></p><p>Precision in the location of the special point Default: -1</p></li><li><p><code>interval::Tuple{T, T} where T</code></p><p>Interval containing the special point Default: (0, 0)</p></li></ul></div></section></article><h2 id="Utils-for-periodic-orbits"><a class="docs-heading-anchor" href="#Utils-for-periodic-orbits">Utils for periodic orbits</a><a id="Utils-for-periodic-orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Utils-for-periodic-orbits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getPeriod" href="#BifurcationKit.getPeriod"><code>BifurcationKit.getPeriod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getPeriod(, x)
getPeriod(, x, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getPeriod(prob, x, p)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getPeriod(psh, x_bar, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x_bar</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getAmplitude" href="#BifurcationKit.getAmplitude"><code>BifurcationKit.getAmplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getAmplitude(prob, x, p)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getAmplitude(prob, x, p)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getMaximum" href="#BifurcationKit.getMaximum"><code>BifurcationKit.getMaximum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SectionSS" href="#BifurcationKit.SectionSS"><code>BifurcationKit.SectionSS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SectionSS{Tn, Tc} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for Section Standard Shooting) encodes a type of section implemented by a single hyperplane. It can be used in conjunction with <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a>. The hyperplane is defined by a point <code>center</code> and a <code>normal</code>.</p><ul><li><p><code>normal::Any</code></p><p>Normal to define hyperplane</p></li><li><p><code>center::Any</code></p><p>Representative point on hyperplane</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SectionPS" href="#BifurcationKit.SectionPS"><code>BifurcationKit.SectionPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SectionPS{Tn, Tc, Tnb, Tcb, Tr} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for SectionPoincaréShooting) encodes a type of Poincaré sections implemented by hyperplanes. It can be used in conjunction with <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. Each hyperplane is defined par a point (one example in <code>centers</code>) and a normal (one example in <code>normals</code>).</p><ul><li><p><code>M::Int64</code></p></li><li><p><code>normals::Any</code></p></li><li><p><code>centers::Any</code></p></li><li><p><code>indices::Vector{Int64}</code></p></li><li><p><code>normals_bar::Any</code></p></li><li><p><code>centers_bar::Any</code></p></li><li><p><code>radius::Any</code></p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="nohighlight hljs">SectionPS(normals::Vector{Tv}, centers::Vector{Tv})</code></pre></div></section></article><h2 id="Misc."><a class="docs-heading-anchor" href="#Misc.">Misc.</a><a id="Misc.-1"></a><a class="docs-heading-anchor-permalink" href="#Misc." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurKrylovKit" href="#BifurcationKit.PrecPartialSchurKrylovKit"><code>BifurcationKit.PrecPartialSchurKrylovKit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>KrylovKit.jl</code>, from which a projection is built. The options are similar to the ones of <code>EigKrylovKit()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurArnoldiMethod" href="#BifurcationKit.PrecPartialSchurArnoldiMethod"><code>BifurcationKit.PrecPartialSchurArnoldiMethod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>ArnoldiMethod.jl</code>, from which a projection is built. See the package <code>ArnoldiMethod.jl</code> for how to pass the proper options.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Flow" href="#BifurcationKit.Flow"><code>BifurcationKit.Flow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Flow{TF, Tf, Tts, Tff, Td, Tad, Tse, Tprob, TprobMono, Tfs, Tcb} &lt;: BifurcationKit.AbstractFlow</code></pre><ul><li><p><code>F::Any</code></p><p>The vector field <code>(x, p) -&gt; F(x, p)</code> associated to a Cauchy problem. Used for the differential of the shooting problem. Default: nothing</p></li><li><p><code>flow::Any</code></p><p>The flow (or semigroup) <code>(x, p, t) -&gt; flow(x, p, t)</code> associated to the Cauchy problem. Only the last time point must be returned in the form (u = ...) Default: nothing</p></li><li><p><code>flowTimeSol::Any</code></p><p>Flow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side. Default: nothing</p></li><li><p><code>flowFull::Any</code></p><p>[Optional] The flow (or semigroup) associated to the Cauchy problem <code>(x, p, t) -&gt; flow(x, p, t)</code>. The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, it is mainly used for plotting on the user side. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>jvp::Any</code></p><p>The differential <code>dflow</code> of the flow <em>w.r.t.</em> <code>x</code>, <code>(x, p, dx, t) -&gt; dflow(x, p, dx, t)</code>. One important thing is that we require <code>dflow(x, dx, t)</code> to return a Named Tuple: <code>(t = t, u = flow(x, p, t), du = dflow(x, p, dx, t))</code>, the last component being the value of the derivative of the flow. Default: nothing</p></li><li><p><code>vjp::Any</code></p><p>The adjoint differential <code>vjpflow</code> of the flow <em>w.r.t.</em> <code>x</code>, <code>(x, p, dx, t) -&gt; vjpflow(x, p, dx, t)</code>. One important thing is that we require <code>vjpflow(x, p, dx, t)</code> to return a Named Tuple: <code>(t = t, u = flow(x, p, t), du = vjpflow(x, p, dx, t))</code>, the last component being the value of the derivative of the flow. Default: nothing</p></li><li><p><code>jvpSerial::Any</code></p><p>[Optional] Serial version of dflow. Used internally when using parallel multiple shooting. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>prob::Any</code></p><p>[Internal] store the ODEProblem associated to the flow of the Cauchy problem Default: nothing</p></li><li><p><code>probMono::Any</code></p><p>[Internal] store the ODEProblem associated to the flow of the variational problem Default: nothing</p></li><li><p><code>flowSerial::Any</code></p><p>[Internal] Serial version of the flow Default: nothing</p></li><li><p><code>callback::Any</code></p><p>[Internal] Store possible callback Default: nothing</p></li></ul><p><strong>Simplified constructor(s)</strong></p><p>We provide a simple constructor where you only pass the vector field <code>F</code>, the flow <code>ϕ</code> and its differential <code>dϕ</code>:</p><pre><code class="nohighlight hljs">fl = Flow(F, ϕ, dϕ)</code></pre><p><strong>Simplified constructors for DifferentialEquations.jl</strong></p><p>These are some simple constructors for which you only have to pass a <code>prob::ODEProblem</code> or <code>prob::EnsembleProblem</code> (for parallel computation) from <code>DifferentialEquations.jl</code> and an ODE time stepper like <code>Tsit5()</code>. Hence, you can do for example</p><pre><code class="nohighlight hljs">fl = Flow(prob, Tsit5(); kwargs...)</code></pre><p>where <code>kwargs</code> is passed to <code>SciMLBase::solve</code>. If your vector field depends on parameters <code>p</code>, you can define a <code>Flow</code> using</p><pre><code class="nohighlight hljs">fl = Flow(prob, Tsit5(); kwargs...)</code></pre><p>Finally, you can pass two <code>ODEProblem</code> where the second one is used to compute the variational equation:</p><pre><code class="nohighlight hljs">fl = Flow(prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.FloquetQaD" href="#BifurcationKit.FloquetQaD"><code>BifurcationKit.FloquetQaD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">floquet = FloquetQaD(eigsolver::AbstractEigenSolver)</code></pre><p>This composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems (based on the Shooting method or Finite Differences (Trapeze method)), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents when the number of time sections is large because of many matrix products. It allows, nevertheless, to detect bifurcations. The arguments are as follows:</p><ul><li><code>eigsolver::AbstractEigenSolver</code> solver used to compute the eigenvalues.</li></ul><p>If <code>eigsolver == DefaultEig()</code>, then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.</p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver <code>eigsolver</code> needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of <code>eigsolver</code>. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.guessFromHopf-Tuple{Any, Any, AbstractEigenSolver, Any, Any}" href="#BifurcationKit.guessFromHopf-Tuple{Any, Any, AbstractEigenSolver, Any, Any}"><code>BifurcationKit.guessFromHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">guessFromHopf(br, ind_hopf, eigsolver, M, amplitude)
</code></pre><p>This function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:</p><ul><li>the parameter value at which a Hopf bifurcation occurs</li><li>the period of the bifurcated periodic orbit</li><li>a guess for the bifurcated periodic orbit</li><li>the equilibrium at the Hopf bifurcation point</li><li>the eigenvector at the Hopf bifurcation point.</li></ul><p>The arguments are</p><ul><li><code>br</code>: the continuation branch which lists the Hopf bifurcation points</li><li><code>ind_hopf</code>: index of the bifurcation branch, as in <code>br.specialpoint</code></li><li><code>eigsolver</code>: the eigen solver used to find the eigenvectors</li><li><code>M</code> number of time slices in the periodic orbit guess</li><li><code>amplitude</code>: amplitude of the periodic orbit guess</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getNormalForm" href="#BifurcationKit.getNormalForm"><code>BifurcationKit.getNormalForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNormalForm(prob, br, id_bif)
</code></pre><p>Compute the normal form of the bifurcation point located at <code>br.specialpoint[ind_bif]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob::AbstractBifurcationProblem</code></li><li><code>br</code> result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br.specialpoint</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>nev</code> number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.</li><li><code>verbose</code> whether to display information</li><li><code>ζs</code> list of vectors spanning the kernel of <code>dF</code> at the bifurcation point. Useful to enforce the basis for the normal form.</li><li><code>lens::Lens</code> specify which parameter to take the partial derivative ∂pF</li><li><code>scaleζ</code> function to normalise the kernel basis. Indeed, when used with large vectors and <code>norm</code>, it results in ζs and the normal form coefficient being super small.</li><li><code>autodiff = true</code> whether to use ForwardDiff for the differentiations w.r.t the parameters that are required to compute the normal form. Used for example for Bogdanov-Takens point. You can set to <code>autodiff = false</code> if you wish.</li><li><code>detailed = true</code> whether to compute only a simplified normal form. Used for example for Bogdanov-Takens point.</li><li><code>bls = MatrixBLS()</code> specify Bordered linear solver. Used for example for Bogdanov-Takens point.</li></ul><p><strong>Available method</strong></p><p>You can directly call </p><pre><code class="nohighlight hljs">getNormalForm(br, ind_bif ; kwargs...)</code></pre><p>which is a shortcut for <code>getNormalForm(getProb(br), br, ind_bif ; kwargs...)</code>.</p><p>Once the normal form <code>nf</code> has been computed, you can call <code>predictor(nf, δp)</code> to obtain an estimate of the bifurcating branch.</p></div></section><section><div><pre><code class="language-julia hljs">getNormalForm(prob, br, id_bif)
</code></pre><p>Compute the normal form of periodic orbits. Same arguments as the function <code>getNormalForm</code> for equilibria. We detail the additional keyword arguments specific to periodic orbits</p><p><strong>Optional arguments</strong></p><ul><li><code>prm = true</code> compute the normal form using Poincaré return map. For collocation, there will be another way to compute the normal form in the future.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../migration/">« Migration to v0.2.x</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 15 June 2023 21:02">Thursday 15 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
