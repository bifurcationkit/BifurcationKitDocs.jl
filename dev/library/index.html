<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Nonlinear Equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose Continuation</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li></ul></li><li><a class="tocitem" href="../EventCallback/">Event Handling and Callback</a></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Bifurcations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-8" type="checkbox"/><label class="tocitem" for="menuitem-4-8"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li><li><a class="tocitem" href="#Problems"><span>Problems</span></a></li><li><a class="tocitem" href="#Newton"><span>Newton</span></a></li><li><a class="tocitem" href="#Library-Continuation"><span>Continuation</span></a></li><li><a class="tocitem" href="#Events"><span>Events</span></a></li><li><a class="tocitem" href="#Branch-switching-(branch-point)"><span>Branch switching (branch point)</span></a></li><li><a class="tocitem" href="#Branch-switching-(Hopf-point)"><span>Branch switching (Hopf point)</span></a></li><li><a class="tocitem" href="#Bifurcation-diagram"><span>Bifurcation diagram</span></a></li><li><a class="tocitem" href="#Utils-for-periodic-orbits"><span>Utils for periodic orbits</span></a></li><li><a class="tocitem" href="#Misc."><span>Misc.</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul><li><a href="#Library">Library</a></li><li class="no-marker"><ul><li><a href="#Parameters">Parameters</a></li><li><a href="#Results">Results</a></li><li><a href="#Problems">Problems</a></li><li class="no-marker"><ul><li><a href="#Periodic-orbits">Periodic orbits</a></li><li><a href="#Waves">Waves</a></li></ul></li><li><a href="#Newton">Newton</a></li><li><a href="#Library-Continuation">Continuation</a></li><li><a href="#Events">Events</a></li><li><a href="#Branch-switching-(branch-point)">Branch switching (branch point)</a></li><li><a href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a></li><li><a href="#Bifurcation-diagram">Bifurcation diagram</a></li><li><a href="#Utils-for-periodic-orbits">Utils for periodic orbits</a></li><li><a href="#Misc.">Misc.</a></li></ul></li></ul><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.NewtonPar" href="#BifurcationKit.NewtonPar"><code>BifurcationKit.NewtonPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NewtonPar{T, L&lt;:BifurcationKit.AbstractLinearSolver, E&lt;:AbstractEigenSolver}</code></pre><p>Returns a variable containing parameters to affect the <code>newton</code> algorithm when solving <code>F(x) = 0</code>.</p><p><strong>Arguments (with default values):</strong></p><ul><li><p><code>tol::Any</code></p><p>absolute tolerance for <code>F(x)</code> Default: 1.0e-10</p></li><li><p><code>maxIter::Int64</code></p><p>number of Newton iterations Default: 50</p></li><li><p><code>verbose::Bool</code></p><p>display Newton iterations? Default: false</p></li><li><p><code>linsolver::BifurcationKit.AbstractLinearSolver</code></p><p>linear solver, must be <code>&lt;: AbstractLinearSolver</code> Default: DefaultLS()</p></li><li><p><code>eigsolver::AbstractEigenSolver</code></p><p>eigen solver, must be <code>&lt;: AbstractEigenSolver</code> Default: DefaultEig()</p></li><li><p><code>linesearch::Bool</code></p><p>Default: false</p></li><li><p><code>α::Any</code></p><p>Default: convert(typeof(tol), 1.0)</p></li><li><p><code>αmin::Any</code></p><p>Default: convert(typeof(tol), 0.001)</p></li></ul><p><strong>Arguments for line search (Armijo)</strong></p><ul><li><code>linesearch = false</code>: use line search algorithm (i.e. Newton with Armijo&#39;s rule)</li><li><code>α = 1.0</code>: initial value of α (damping) parameter for line search algorithm</li><li><code>αmin  = 0.001</code>: minimal value of the damping <code>alpha</code></li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See the tutorials for examples.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContinuationPar" href="#BifurcationKit.ContinuationPar"><code>BifurcationKit.ContinuationPar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">options = ContinuationPar(dsmin = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>continuation</code> algorithm used to solve <code>F(x,p) = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dsmin, dsmax</code> are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.</li><li><code>ds</code> is the initial arclength.</li><li><code>theta</code> is a parameter in the arclength constraint. It is very <strong>important</strong> to tune it. See the docs of <a href="#BifurcationKit.continuation"><code>continuation</code></a>. We quote them here &quot;It should be tuned for the continuation to work properly especially in the case of large problems where the &lt; x - x<em>0, dx</em>0 &gt; component in the constraint equation might be favoured too much. Also, large thetas favour p as the corresponding term in N involves the term 1-theta.&quot;</li><li><code>pMin, pMax</code> allowed parameter range for <code>p</code></li><li><code>maxSteps</code> maximum number of continuation steps</li><li><code>newtonOptions::NewtonPar</code>: options for the Newton algorithm</li><li><code>saveToFile = false</code>: save to file. A name is automatically generated.</li><li><code>saveSolEveryStep::Int64 = 0</code> at which continuation steps do we save the current solution`</li><li><code>plotEveryStep = 3</code></li></ul><p><strong>Handling eigen elements, their computation is triggered by the argument <code>detectBifurcation</code> (see below)</strong></p><ul><li><code>nev = 3</code> number of eigenvalues to be computed. It is automatically increased to have at least <code>nev</code> unstable eigenvalues. To be set for proper  bifurcation detection. See <a href="../detectionBifurcation/#Detection-of-bifurcation-points">Detection of bifurcation points</a> for more informations.</li><li><code>saveEigEveryStep = 1</code>	record eigen vectors every specified steps. <strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li><li><code>saveEigenvectors	= true</code>	<strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li></ul><p><strong>Handling bifurcation detection</strong></p><ul><li><code>precisionStability = 1e-10</code> lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits</li><li><code>detectFold = true</code> detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)</li><li><code>detectBifurcation::Int</code> ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)</li><li><code>dsminBisection</code> dsmin for the bisection algorithm for locating bifurcation points</li><li><code>nInversion</code> number of sign inversions in bisection algorithm</li><li><code>maxBisectionSteps</code> maximum number of bisection steps</li><li><code>tolBisectionEigenvalue</code> tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps</li></ul><p><strong>Handling <code>ds</code> adaptation (see <a href="#BifurcationKit.continuation"><code>continuation</code></a> for more information)</strong></p><ul><li><code>a  = 0.5</code> aggressiveness factor. It is used to adapt <code>ds</code> in order to have a number of newton iterations per continuation step roughly constant. The higher <code>a</code> is, the larger the step size <code>ds</code> is changed at each continuation step.</li><li><code>thetaMin = 1.0e-3</code> minimum value of <code>theta</code></li><li><code>doArcLengthScaling</code> trigger further adaptation of <code>theta</code></li></ul><p><strong>Handling event detection</strong></p><ul><li><code>detectEvent::Int</code> ∈ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are seek during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).</li><li><code>tolParamBisectionEvent</code> tolerance on parameter to locate event</li></ul><p><strong>Misc</strong></p><ul><li><code>finDiffEps::T  = 1e-9</code> ε used in finite differences computations</li><li><code>detectLoop</code> [WORK IN PROGRESS] detect loops in the branch and stop the continuation</li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Setfield.jl</code> to drastically simplify the mutation of different fields. See tutorials for more examples.</p></div></div></div></section></article><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContResult" href="#BifurcationKit.ContResult"><code>BifurcationKit.ContResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ContResult{Ta, Teigvals, Teigvec, Biftype, Ts, Tfunc, Tpar, Tl&lt;:Lens} &lt;: BifurcationKit.AbstractBranchResult</code></pre><p>Structure which holds the results after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a>.</p><p>You can see the propertynames of a result by using <code>propertynames(::ContResult)</code> or by typing <code>br.</code> + TAB where <code>br::ContResult</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>branch::StructArrays.StructArray</code></p><p>holds the low-dimensional information about the branch. More precisely, <code>branch[:, i+1]</code> contains the following information <code>(recordFromSolution(u, param), param, itnewton, itlinear, ds, theta, n_unstable, n_imag, stable, step)</code> for each continuation step <code>i</code>.</p><ul><li><code>itnewton</code> number of Newton iterations</li><li><code>itlinear</code> total number of linear iterations during corrector</li><li><code>n_unstable</code> number of eigenvalues with positive real part for each continuation step (to detect stationary bifurcation)</li><li><code>n_imag</code> number of eigenvalues with positive real part and non zero imaginary part for each continuation step (to detect Hopf bifurcation).</li><li><code>stable</code>  stability of the computed solution for each continuation step. Hence, <code>stable</code> should match <code>eig[step]</code> which corresponds to <code>branch[k]</code> for a given <code>k</code>.</li><li><code>step</code> continuation step (here equal <code>i</code>)</li></ul></li><li><p><code>eig::Array{NamedTuple{(:eigenvals, :eigenvec, :step), Tuple{Teigvals, Teigvec, Int64}}, 1} where {Teigvals, Teigvec}</code></p><p>A vector with eigen-elements at each continuation step.</p></li><li><p><code>sol::Any</code></p><p>Vector of solutions sampled along the branch. This is set by the argument <code>saveSolEveryNsteps::Int64</code> (default 0) in <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a>.</p></li><li><p><code>contparams::ContinuationPar</code></p><p>The parameters used for the call to <code>continuation</code> which produced this branch.</p></li><li><p><code>type::Symbol</code></p><p>Type of solutions computed in this branch. Default: :Equilibrium</p></li><li><p><code>functional::Any</code></p><p>Structure associated to the functional, useful for branch switching. For example, when computing periodic orbits, the functional <code>PeriodicOrbitTrapProblem</code>, <code>ShootingProblem</code>... will be saved here. Default: nothing</p></li><li><p><code>params::Any</code></p><p>Parameters passed to continuation and used in the equation <code>F(x, par) = 0</code>. Default: nothing</p></li><li><p><code>lens::Lens</code></p><p>Parameter axis used for computing the branch</p></li><li><p><code>specialpoint::Vector</code></p><p>A vector holding the set of detected bifurcation points. See <a href="#BifurcationKit.SpecialPoint"><code>SpecialPoint</code></a> for a description of the fields.</p></li></ul><p><strong>Associated methods</strong></p><ul><li><code>length(br)</code> number of the continuation steps</li><li><code>eigenvals(br, ind)</code> returns the eigenvalues for the ind-th continuation step</li><li><code>eigenvec(br, ind, indev)</code> returns the indev-th eigenvector for the ind-th continuation step</li><li><code>br[k+1]</code> gives information about the k-th step</li><li><code>getSolx(br, k)</code> returns the k-th solution on the branch</li><li><code>getSolp(br, k)</code> returns the parameter  value associated with k-th solution on the branch</li></ul></div></section></article><h2 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DeflationOperator" href="#BifurcationKit.DeflationOperator"><code>BifurcationKit.DeflationOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DeflationOperator{Tp&lt;:Real, Tdot, T&lt;:Real, vectype}</code></pre><p>It is used to handle the following situation. Assume you want to solve <code>F(x)=0</code> with a Newton algorithm but you want to avoid the process to return some already known solutions <span>$roots_i$</span>. The deflation operator penalizes these roots ; the algorithm works very well despite its simplicity. You can use <code>DeflationOperator</code> to define a function <code>M(u)</code> used to find, with Newton iterations, the zeros of the following function <span>$F(u) \cdot Π_i(\|u - root_i\|^{-2p} + \alpha) := F(u) \cdot M(u)$</span> where <span>$\|u\|^2 = dot(u,u)$</span>. The fields of the struct <code>DeflationOperator</code> are as follows:</p><ul><li><p><code>power::Real</code></p><p>power <code>p</code>. You can use an  <code>Int</code> for example</p></li><li><p><code>dot::Any</code></p><p>function, this function has to be bilinear and symmetric for the linear solver to work well</p></li><li><p><code>α::Real</code></p><p>shift</p></li><li><p><code>roots::Vector</code></p><p>roots</p></li><li><p><code>tmp::Any</code></p></li></ul><p>Given <code>defOp::DeflationOperator</code>, one can access its roots as <code>defOp[n]</code> as a shortcut for <code>defOp.roots[n]</code>. Also, one can add (resp.remove) a new root by using <code>push!(defOp, newroot)</code> (resp. <code>pop!(defOp)</code>). Finally <code>length(defOp)</code> is a shortcut for <code>length(defOp.roots)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DeflatedProblem" href="#BifurcationKit.DeflatedProblem"><code>BifurcationKit.DeflatedProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = DeflatedProblem(F, J, M::DeflationOperator)</code></pre><p>This creates a deflated problem <span>$M(u) \cdot F(u) = 0$</span> where <code>M</code> is a <code>DeflationOperator</code> which encodes the penalization term. <code>J</code> is the jacobian of <code>F</code>. Can be used to call <code>newton</code> and <code>continuation</code>.</p></div></section></article><h3 id="Periodic-orbits"><a class="docs-heading-anchor" href="#Periodic-orbits">Periodic orbits</a><a id="Periodic-orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-orbits" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PeriodicOrbitTrapProblem" href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>BifurcationKit.PeriodicOrbitTrapProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = PeriodicOrbitTrapProblem(F, J, ϕ, xπ, M::Int)</code></pre><p>This composite type implements Finite Differences based on a Trapezoidal rule to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitTrapeze/">here</a>.</p><p><strong>Arguments</strong></p><ul><li><code>F</code> vector field specified as a function of two arguments <code>F(x,p)</code></li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.<ol><li>Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</li></ol></li><li><code>Jᵗ = nothing</code> jacobian transpose of <code>F</code> (optional), useful for continuation of Fold of periodic orbits. it should not be passed in case the jacobian is a (sparse) matrix as it is computed internally, and it would be computed twice in that case.</li><li><code>d2F = nothing</code> second derivative of F (optional), useful for continuation of Fold of periodic orbits. It has the definition <code>d2F(x,p,dx1,dx2)</code>.`</li><li><code>ϕ</code> used to set a section for the phase constraint equation</li><li><code>xπ</code> used in the section for the phase constraint equation</li><li><code>M::Int</code> number of time slices</li><li><code>linsolver: = DefaultLS()</code> linear solver for each time slice, i.e. to solve <code>J⋅sol = rhs</code>. This is only needed for the computation of the Floquet multipliers.</li><li><code>isinplace::Bool</code> whether <code>F</code> and <code>J</code> are inplace functions (Experimental). In this case, the functions <code>F</code> and <code>J</code> must have the following definitions <code>(o, x, p) -&gt;  F(o, x, p)</code> and <code>(o, x, p, dx) -&gt; J(o, x, p, dx)</code>.</li><li><code>ongpu::Bool</code> whether the computation takes place on the gpu (Experimental)</li><li><code>massmatrix</code> a mass matrix. You can pass for example a sparse matrix. Default: identity matrix.</li></ul><p>The scheme is as follows. We first consider a partition of <span>$[0,1]$</span> given by <span>$0&lt;s_0&lt;\cdots&lt;s_m=1$</span> and one looks for <code>T = x[end]</code> such that</p><p><span>$M_a\cdot\left(x_{i} - x_{i-1}\right) - \frac{T\cdot h_i}{2} \left(F(x_{i}) + F(x_{i-1})\right) = 0,\ i=1,\cdots,m-1$</span></p><p>with <span>$u_{0} := u_{m-1}$</span> and the periodicity condition <span>$u_{m} - u_{1} = 0$</span> and</p><p>where <span>$h_1 = s_i-s_{i-1}$</span>. <span>$M_a$</span> is a mass matrix. Finally, the phase of the periodic orbit is constrained by using a section (but you could use your own)</p><p><span>$\sum_i\langle x_{i} - x_{\pi,i}, \phi_{i}\rangle=0.$</span></p><p><strong>Orbit guess</strong></p><p>You will see below that you can evaluate the residual of the functional (and other things) by calling <code>pb(orbitguess, p)</code> on an orbit guess <code>orbitguess</code>. Note that <code>orbitguess</code> must be of size M * N + 1 where N is the number of unknowns in the state space and <code>orbitguess[M*N+1]</code> is an estimate of the period <span>$T$</span> of the limit cycle. More precisely, using the above notations, <code>orbitguess</code> must be <span>$orbitguess = [x_{1},x_{2},\cdots,x_{M}, T]$</span>.</p><p>Note that you can generate this guess from a function solution using <code>generateSolution</code>.</p><p><strong>Functional</strong></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>pb(orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, p, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb(Val(:JacFullSparse), orbitguess, p)</code> return the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code> without the constraints. It is called <code>A_γ</code> in the docs.</li><li><code>pb(Val(:JacFullSparseInplace), J, orbitguess, p)</code>. Same as <code>pb(Val(:JacFullSparse), orbitguess, p)</code> but overwrites <code>J</code> inplace. Note that the sparsity pattern must be the same independantly of the values of the parameters or of <code>orbitguess</code>. In this case, this is significantly faster than <code>pb(Val(:JacFullSparse), orbitguess, p)</code>.</li><li><code>pb(Val(:JacCyclicSparse), orbitguess, p)</code> return the sparse cyclic matrix Jc (see the docs) of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code></li><li><code>pb(Val(:BlockDiagSparse), orbitguess, p)</code> return the diagonal of the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code>. This allows to design Jacobi preconditioner. Use <code>blockdiag</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">GPU call</header><div class="admonition-body"><p>For these methods to work on the GPU, for example with <code>CuArrays</code> in mode <code>allowscalar(false)</code>, we face the issue that the function <code>extractPeriodFDTrap</code> won&#39;t be well defined because it is a scalar operation. One may have to redefine it like <code>extractPeriodFDTrap(x::CuArray) = x[end:end]</code> or something else. Also, note that you must pass the option <code>ongpu = true</code> for the functional to be evaluated efficiently on the gpu.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PeriodicOrbitOCollProblem" href="#BifurcationKit.PeriodicOrbitOCollProblem"><code>BifurcationKit.PeriodicOrbitOCollProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = PeriodicOrbitOCollProblem(kwargs...)</code></pre><p>This composite type implements an orthogonal collocation (at Gauss points) method of piecewise polynomials to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitCollocation/">here</a>.</p><p><strong>Arguments</strong></p><ul><li><code>F</code> vector field specified as a function of two arguments <code>F(x,p)</code></li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.<ol><li>Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</li></ol></li><li><code>ϕ::AbstractVector</code> used to set a section for the phase constraint equation</li><li><code>xπ::AbstractVector</code> used in the section for the phase constraint equation</li><li><code>N::Int</code> dimension of the state space</li><li><code>coll_cache::POOrthogonalCollocationCache</code> cache for collocation. See docs of <code>POOrthogonalCollocationCache</code> .</li></ul><p><strong>Methods</strong></p><p>Here are some useful methods you can apply to <code>pb</code></p><ul><li><code>length(pb)</code> gives the total number of unknowns</li><li><code>size(pb)</code> returns the triplet <code>(N, m, Ntst)</code></li><li><code>getMesh(pb)</code> returns the mesh <code>0 = τ0 &lt; ... &lt; τNtst+1 = 1</code>. This is useful because this mesh is born to vary by automatic mesh adaptation</li><li><code>getMeshColl(pb)</code> returns the (static) mesh <code>0 = σ0 &lt; ... &lt; σm+1 = 1</code></li><li><code>getTimes(pb)</code> returns the vector of times (length <code>1 + m * Ntst</code>) at the which the collocation is applied.</li><li><code>generateSolution(pb, orbit, period)</code> generate a guess from a function <code>t -&gt; orbit(t)</code> which approximates the periodic orbit.</li><li><code>POOcollSolution(pb, x)</code> return a function interpolating the solution <code>x</code> using a piecewise polynomials function</li></ul><p><strong>Orbit guess</strong></p><p>You will see below that you can evaluate the residual of the functional (and other things) by calling <code>pb(orbitguess, p)</code> on an orbit guess <code>orbitguess</code>. Note that <code>orbitguess</code> must be of size 1 + N * (1 + m * Ntst) where N is the number of unknowns in the state space and <code>orbitguess[end]</code> is an estimate of the period <span>$T$</span> of the limit cycle.</p><p>Note that you can generate this guess from a function using <code>generateSolution</code>.</p><p><strong>Functional</strong></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>pb(orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ShootingProblem" href="#BifurcationKit.ShootingProblem"><code>BifurcationKit.ShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = ShootingProblem(flow::Flow, ds, section; parallel = false)</code></pre><p>Create a problem to implement the Standard Simple / Parallel Multiple Standard Shooting method to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>ds</code>: vector of time differences for each shooting. Its length is written <code>M</code>. If <code>M==1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>section</code>: implements a phase condition. The evaluation <code>section(x, T)</code> must return a scalar number where <code>x</code> is a guess for <strong>one point</strong> the periodic orbit and <code>T</code> is the period of the guess. The type of <code>x</code> depends on what is passed to the newton solver. See <a href="#BifurcationKit.SectionSS"><code>SectionSS</code></a> for a type of section defined as a hyperplane.</li><li><code>parallel</code> whether the shooting is computed in parallel (threading). Available through the use of Flows defined by <code>EnsembleProblem</code> (this is automatically  set up for you).</li></ul><p>A functional, hereby called <code>G</code>, encodes the shooting problem. For example, the following methods are available:</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du; δ = 1e-9)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code>. The optional argument <code>δ</code> is used to compute a finite difference approximation of the derivative of the section.</li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><p>You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size <code>M * N + 1</code> where N is the number of unknowns of the state space and <code>orbitguess[M * N + 1]</code> is an estimate of the period <code>T</code> of the limit cycle. This form of guess is convenient for the use of the linear solvers in <code>IterativeSolvers.jl</code> (for example) which only accept <code>AbstractVector</code>s. Another accepted guess is of the form <code>BorderedArray(guess, T)</code> where <code>guess[i]</code> is the state of the orbit at the <code>i</code>th time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example, use <code>GMRESKrylovKit</code> for the linear solver in this case.</p><p>Note that you can generate this guess from a function solution using <code>generateSolution</code>.</p><p><strong>Simplified constructors</strong></p><ul><li>A simpler way to build the functional is to use</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, centers::AbstractVector; kwargs...)</code></pre><p>where <code>prob</code> is an <code>ODEProblem</code> (resp. <code>EnsembleProblem</code>) which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). <code>centers</code> is list of <code>M</code> points close to the periodic orbit, they will be used to build a constraint for the phase. <code>parallel = false</code> is an option to use Parallel simulations (Threading) to simulate the multiple trajectories in the case of multiple shooting. This is efficient when the trajectories are relatively long to compute. Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. Look at <code>DifferentialEquations.jl</code> for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.</p><ul><li>Another way to create a Shooting problem with more options is the following where in particular, one can provide its own scalar constraint <code>section(x)::Number</code> for the phase</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(F, p, prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, ds, section; parallel = false, kwargs...)</code></pre><ul><li>The next way is an elaboration of the previous one</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="nohighlight hljs">pb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, ds, section; parallel = false, kwargs...)</code></pre><p>where we supply now two <code>ODEProblem</code>s. The first one <code>prob1</code>, is used to define the flow associated to <code>F</code> while the second one is a problem associated to the derivative of the flow. Hence, <code>prob2</code> must implement the following vector field <span>$\tilde F(x,y,p) = (F(x,p),dF(x,p)\cdot y)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PoincareShootingProblem" href="#BifurcationKit.PoincareShootingProblem"><code>BifurcationKit.PoincareShootingProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>pb = PoincareShootingProblem(flow::Flow, M, sections; δ = 1e-8, interp_points = 50, parallel = false)</code></p><p>This composite type implements the Poincaré Shooting method to locate periodic orbits by relying on Poincaré return maps. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>M</code>: the number of Poincaré sections. If <code>M==1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>sections</code>: function or callable struct which implements a Poincaré section condition. The evaluation <code>sections(x)</code> must return a scalar number when <code>M==1</code>. Otherwise, one must implement a function <code>section(out, x)</code> which populates <code>out</code> with the <code>M</code> sections. See <a href="#BifurcationKit.SectionPS"><code>SectionPS</code></a> for type of section defined as a hyperplane.</li><li><code>δ = 1e-8</code> used to compute the jacobian of the functional by finite differences. If set to <code>0</code>, an analytical expression of the jacobian is used instead.</li><li><code>interp_points = 50</code> number of interpolation point used to define the callback (to compute the hitting of the hyperplane section)</li><li><code>parallel = false</code> whether the shooting are computed in parallel (threading). Only available through the use of Flows defined by <code>EnsembleProblem</code>.</li></ul><p><strong>Simplified constructors</strong></p><ul><li>A simpler way is to create a functional is</li></ul><p><code>pb = PoincareShootingProblem(prob::ODEProblem, alg, section; kwargs...)</code></p><p>for simple shooting or</p><p><code>pb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; kwargs...)</code></p><p>for multiple shooting . Here <code>prob</code> is an <code>Union{ODEProblem, EnsembleProblem}</code> which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. We refer to <code>DifferentialEquations.jl</code> for more information.</p><ul><li>Another convenient call is</li></ul><p><code>pb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)</code></p><p>where <code>normals</code> (resp. <code>centers</code>) is a list of normals (resp. centers) which defines a list of hyperplanes <span>$\Sigma_i$</span>. These hyperplanes are used to define partial Poincaré return maps.</p><p><strong>Computing the functionals</strong></p><p>A functional, hereby called <code>G</code> encodes this shooting problem. You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size M * N where N is the number of unknowns in the state space and <code>M</code> is the number of Poincaré maps. Another accepted <code>guess</code> is such that <code>guess[i]</code> is the state of the orbit on the <code>i</code>th section. This last form allows for non-vector state space which can be convenient for 2d problems for example.</p><p>Note that you can generate this guess from a function solution using <code>generateSolution</code>.</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can use the function <code>getPeriod(pb, sol, par)</code> to get the period of the solution <code>sol</code> for the problem with parameters <code>par</code>.</p></div></div></div></section></article><h3 id="Waves"><a class="docs-heading-anchor" href="#Waves">Waves</a><a id="Waves-1"></a><a class="docs-heading-anchor-permalink" href="#Waves" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.TWProblem" href="#BifurcationKit.TWProblem"><code>BifurcationKit.TWProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">pb = TWProblem(F, J, ∂::Tuple, u₀; DAE = 0)</code></pre><p>This composite type implements a functional for freezing symmetries in order, for example, to compute travelling waves (TW). Note that you can freeze many symmetries, not just one, by passing many Lie generators.</p><p><strong>Arguments</strong></p><ul><li><code>(x, p) -&gt; F(x, p)</code> function with continuous symmetries</li><li><code>J</code> jacobian of <code>F</code>. Can be matrix based or matrix-free. The requirements are same as for <a href="#BifurcationKit.newton"><code>newton</code></a></li><li><code>∂::Tuple = (T1, T2, ⋯)</code> tuple of Lie generators. In effect, each of these is an (differential) operator which can be specified as a (sparse) matrix or as an operator implementing <code>LinearAlgebra.mul!</code>.</li><li><code>u₀</code> reference solution</li></ul><p><strong>Additional Constructor(s)</strong></p><pre><code class="nohighlight hljs">pb = TWProblem(F, J, ∂, u₀; kw...)</code></pre><p>This simplified call handles the case where a single symmetry needs to be frozen.</p><p><strong>Useful function</strong></p><ul><li><code>updateSection!(pb::TWProblem, u0)</code> updates the reference solution of the problem using <code>u0</code>.</li><li><code>nbConstraints(::TWProblem)</code> number of constraints (or Lie generators)</li></ul></div></section></article><h2 id="Newton"><a class="docs-heading-anchor" href="#Newton">Newton</a><a id="Newton-1"></a><a class="docs-heading-anchor-permalink" href="#Newton" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.newton" href="#BifurcationKit.newton"><code>BifurcationKit.newton</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">	newton(F, J, x0, p0, options::NewtonPar; normN = norm, callback = (x, f, J, res, iteration, itlinear, optionsN; kwargs...) -&gt; true, kwargs...)</code></pre><p>This is the Newton-Krylov Solver for <code>F(x, p0) = 0</code> with Jacobian w.r.t. <code>x</code> written <code>J(x, p0)</code> and initial guess <code>x0</code>. The function <code>normN</code> allows to specify a norm for the convergence criteria. It is important to set the linear solver <code>options.linsolver</code> properly depending on your problem. This linear solver is used to solve <span>$J(x, p_0)u = -F(x, p_0)$</span> in the Newton step. You can for example use <code>linsolver = DefaultLS()</code> which is the operator backslash: it works well for Sparse / Dense matrices. See <a href="../linearsolver/#Linear-solvers-(LS)">Linear solvers (LS)</a> for more informations.</p><p><strong>Arguments:</strong></p><ul><li><code>F</code> is a function with input arguments <code>(x, p)</code> returning a vector <code>r</code> that represents the functional and for type stability, the types of <code>x</code> and <code>r</code> should match. In particular, it is not <strong>inplace</strong>.</li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume two forms. Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>NewtonPar</code> will make <code>newton</code> work. Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returns <code>dr</code> of the same type of <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>NewtonPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>.</li><li><code>x0</code> initial guess</li><li><code>p0</code> set of parameters to be passed to <code>F</code> and <code>J</code></li><li><code>options::NewtonPar</code> variable holding the internal parameters used by the <code>newton</code> method</li><li><code>callback</code> function passed by the user which is called at the end of each iteration. The default one is the following <code>cbDefault(x, f, J, res, it, itlinear, options; k...) = true</code>. Can be used to update a preconditionner for example. You can use for example <code>cbMaxNorm</code> to limit the residuals norms. If yo  want to specify your own, the arguments passed to the callback are as follows<ul><li><code>x</code> current solution</li><li><code>f</code> current residual</li><li><code>J</code> current jacobian</li><li><code>res</code> current norm of the residual</li><li><code>iteration</code> current newton iteration</li><li><code>itlinear</code> number of iterations to solve the linear system</li><li><code>optionsN</code> a copy of the argument <code>options</code> passed to <code>newton</code></li><li><code>kwargs</code> kwargs arguments, contain your initial guess <code>x0</code></li></ul></li><li><code>kwargs</code> arguments passed to the callback. Useful when <code>newton</code> is called from <code>continuation</code></li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of newton iterations</li><li>total number of linear iterations</li></ul><p><strong>Simplified calls</strong></p><p>When <code>J</code> is not passed, the jacobian <strong>matrix</strong> is then computed with finite differences (beware of large systems of equations!). The call is as follows:</p><pre><code class="nohighlight hljs">newton(F, x0, p0, options::NewtonPar; kwargs...)</code></pre><p>You can also pass functions which do not have parameters <code>x -&gt; F(x)</code>, <code>x -&gt; J(x)</code> as follows</p><pre><code class="nohighlight hljs">newton(F, J, x0, options::NewtonPar;  kwargs...)</code></pre><p>or</p><pre><code class="nohighlight hljs">newton(F, x0, options::NewtonPar;  kwargs...)</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; F(x, p) = x.^3 .- 1
julia&gt; Jac(x, p) = spdiagm(0 =&gt; 3 .* x.^2) # sparse jacobian
julia&gt; x0 = rand(1_000)
julia&gt; opts = NewtonPar()
julia&gt; sol, hist, flag, _ = newton(F, Jac, x0, nothing, opts, normN = x -&gt; norm(x, Inf))</code></pre><div class="admonition is-success"><header class="admonition-header">Other formulation</header><div class="admonition-body"><p>If you don&#39;t have parameters, you can still use <code>newton</code> as follows <code>newton((x,p) -&gt; F(x), (x,p)-&gt; J(x), x0, nothing, options)</code></p></div></div><div class="admonition is-warning"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>Make sure that the linear solver (Matrix-Free...) corresponds to your jacobian (Matrix-Free vs. Matrix based).</p></div></div></div></section><section><div><pre><code class="language-julia hljs">newton(F, J, x0, p0, options, defOp)
newton(F, J, x0, p0, options, defOp, linsolver; kwargs...)
</code></pre><p>This is the deflated version of the Krylov-Newton Solver for <code>F(x, p0) = 0</code> with Jacobian <code>J(x, p0)</code>. We refer to <a href="#BifurcationKit.newton"><code>newton</code></a> for more information. It penalises the roots saved in <code>defOp.roots</code>. The other arguments are as for <code>newton</code>. See <a href="#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a> for more information.</p><p><strong>Arguments</strong></p><p>Compared to <a href="#BifurcationKit.newton"><code>newton</code></a>, the only different arguments are</p><ul><li><code>defOp::DeflationOperator</code> deflation operator</li><li><code>linsolver</code> linear solver used to invert the Jacobian of the deflated functional.<ul><li>We have a custom solver <code>DeflatedLinearSolver()</code> with requires solving two linear systems <code>J⋅x = rhs</code>.</li><li>For other linear solvers <code>&lt;: AbstractLinearSolver</code>, a matrix free method is used for the deflated functional.</li><li>if passed <code>Val(:autodiff)</code>, then <code>ForwardDiff.jl</code> is used to compute the jacobian of the deflated problem</li></ul></li></ul><p><strong>Output:</strong></p><ul><li>solution:</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul><p><strong>Simplified call</strong></p><p>When <code>J</code> is not passed. It then computed with finite differences. The call is as follows:</p><pre><code class="nohighlight hljs">newton(F, x0, p0, options, defOp; kwargs...)</code></pre></div></section><section><div><p>This specific Newton-Krylov method first tries to converge to a solution <code>sol0</code> close the guess <code>x0</code>. It then attempts to converge from the guess <code>x1</code> while avoiding the previous coonverged solution close to <code>sol0</code>. This is very handy for branch switching. The method is based on a deflated Newton-Krylov solver.</p></div></section><section><div><pre><code class="language-julia hljs">newton(F, J, br, ind_bif; Jᵗ, d2F, normN, options, startWithEigen, issymmetric, kwargs...)
</code></pre><p>This function turns an initial guess for a Fold/Hopf point into a solution to the Fold/Hopf problem based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F  = (x, p) -&gt; F(x, p)</code> where <code>p</code> is a set of parameters.</li><li><code>J  = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>br</code> results returned after a call to <a href="#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li><li><code>lens</code> parameter axis used to locate the Fold/Hopf point.</li><li><code>options::NewtonPar</code></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>issymmetric</code> whether the Jacobian is Symmetric (for Fold)</li><li><code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>d2F = (x, p, v1, v2) -&gt;  d2F(x, p, v1, v2)</code> a bilinear operator representing the hessian of <code>F</code>. It has to provide an expression for <code>d2F(x,p)[v1,v2]</code>.</li><li><code>normN = norm</code></li><li><code>options</code> You can pass newton parameters different from the ones stored in <code>br</code> by using this argument <code>options</code>.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>startWithEigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the Bordered Linear Solver using the option <code>bdlinsolver = MatrixBLS()</code></p></div></div></div></section><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, par, options; jacobianPO, δ, kwargs...)
</code></pre><p>This is the Newton-Krylov Solver for computing a periodic orbit using (Standard / Poincaré) Shooting method. Note that the linear solver has to be apropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.</p><ul><li><code>prob</code> a problem of type <code>&lt;: AbstractShootingProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit. See <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> and See <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> for information regarding the shape of <code>orbitguess</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <a href="#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobianPO</code> Specify the choice of the linear algorithm, which must belong to <code>(:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences)</code>. This is used to select a way of inverting the jacobian dG</li></ul><pre><code class="nohighlight hljs">- For `:MatrixFree`, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in `prob`.
- For `:autodiffMF`, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of `x -&gt; prob(x, p)`.
- For `:autodiffDense`. Same as for `:autodiffMF` but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using `options`.
- For `:autodiffDenseAnalytical`. Same as for `:autodiffDense` but the jacobian is using a mix of AD and analytical formula.
- For `:FiniteDifferencesDense`, same as for `:autodiffDense` but we use Finite Differences to compute the jacobian of `x -&gt; prob(x, p)` using the `δ = 1e-8` which can be passed as an argument.</code></pre><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div></section><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, par, options, defOp; jacobianPO, kwargs...)
</code></pre><p>This is the deflated Newton-Krylov Solver for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>.</p><p><strong>Optional argument</strong></p><ul><li><code>jacobianPO</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences]</code>. This is used to select a way of inverting the jacobian dG</li></ul><p><strong>Choices for <code>jacobianPO</code></strong></p><ul><li>For <code>:MatrixFree</code>, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in <code>prob</code>.</li><li>For <code>:autodiffMF</code>, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code>.</li><li>For <code>:autodiffDense</code>. Same as for <code>:autodiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>.</li><li>For <code>:autodiffDenseAnalytical</code>. Same as for <code>:autodiffDense</code> but the jacobian is using a mix of AD and analytical formula.</li><li>For <code>:FiniteDifferencesDense</code>, same as for <code>:autodiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, par, options; jacobianPO, kwargs...)
</code></pre><p>This is the Krylov-Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments:</strong></p><ul><li><code>prob</code> a problem of type <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a> encoding the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It should be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <code>newton</code> method</li><li><code>jacobianPO = :BorderedLU</code>. Specify the choice of the linear algorithm, which must belong to <code>[:FullLU, :FullSparseInplace, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree, :FullSparseInplace]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.<ul><li>For <code>:FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>:FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>:Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>:BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver. This is the default algorithm.</li><li>For <code>:BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>:FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>:BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li></ul></li></ul><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div></section><section><div><pre><code class="nohighlight hljs">newton(probPO::PeriodicOrbitTrapProblem, orbitguess, options::NewtonPar, defOp::DeflationOperator{T, Tf, vectype}, jacobianPO = :BorderedLU; kwargs...) where {T, Tf, vectype}</code></pre><p>This function is similar to <code>newton(probPO, orbitguess, options, jacobianPO; kwargs...)</code> except that it uses deflation in order to find periodic orbits different from the ones stored in <code>defOp</code>. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.</p></div></section><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, par, options; jacobianPO, δ, kwargs...)
</code></pre><p>This is the Newton Solver for computing a periodic orbit using (Standard / Poincaré) Shooting method. Note that the linear solver has to be apropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.</p><ul><li><code>prob</code> a problem of type <code>&lt;: AbstractShootingProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit. See <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> and See <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> for information regarding the shape of <code>orbitguess</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <a href="#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobianPO</code> Specify the choice of the linear algorithm, which must belong to <code>(:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences)</code>. This is used to select a way of inverting the jacobian dG</li></ul><pre><code class="nohighlight hljs">- For `:MatrixFree`, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in `prob`.
- For `:autodiffMF`, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of `x -&gt; prob(x, p)`.
- For `:autodiffDense`. Same as for `:autodiffMF` but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using `options`.
- For `:autodiffDenseAnalytical`. Same as for `:autodiffDense` but the jacobian is using a mix of AD and analytical formula.
- For `:FiniteDifferencesDense`, same as for `:autodiffDense` but we use Finite Differences to compute the jacobian of `x -&gt; prob(x, p)` using the `δ = 1e-8` which can be passed as an argument.</code></pre><p><strong>Output:</strong></p><ul><li>solution</li><li>history of residuals</li><li>flag of convergence</li><li>number of iterations</li></ul></div></section></article><h2 id="Library-Continuation"><a class="docs-heading-anchor" href="#Library-Continuation">Continuation</a><a id="Library-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Continuation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation" href="#BifurcationKit.continuation"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuation(F, J, x0, par, lens::Lens, contParams::ContinuationPar; plot = false, normC = norm, dotPALC = (x,y) -&gt; dot(x,y) / length(x), recordFromSolution = norm, plotSolution = (x, p; kwargs...)-&gt;nothing, finaliseSolution = (z, tau, step, contResult; kwargs...) -&gt; true, callbackN = (x, f, J, res, iteration, itlinear, options; kwargs...) -&gt; true, linearAlgo = BorderingBLS(), tangentAlgo = SecantPred(), verbosity = 0)</code></pre><p>Compute the continuation curve associated to the functional <code>F</code> and its jacobian <code>J</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>F</code> is a function with input arguments <code>(x, p)</code>, where <code>p</code> is the set of parameters passed to <code>F</code>, and returning a vector <code>r</code> which represents the functional. For type stability, the types of <code>x</code> and <code>r</code> should match. In particular, it is not <strong>inplace</strong>,</li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.<ol><li>Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself is passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</li></ol></li><li><code>x0</code> initial guess,</li><li><code>par</code> initial set of parameters,</li><li><code>lens::Lens</code> specifies which parameter axis among <code>par</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@lens _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@lens _[1])</code>. For more information, we refer to <code>SetField.jl</code>.</li><li><code>contParams</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a> for more information about the options</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plot = false</code> whether to plot the solution while computing</li><li><code>recordFromSolution = (x, p) -&gt; norm(x)</code> function used record a few indicators about the solution. It could be <code>norm</code> or <code>(x, p) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...). This function can return pretty much everything but you should keep it small. For example, you can do <code>(x, p) -&gt; (x1 = x[1], x2 = x[2], nrm = norm(x))</code> or simply <code>(x, p) -&gt; (sum(x), 1)</code>. This will be stored in <code>contres.branch</code> (see below). Finally, the first component is used to plot in the continuation curve.</li><li><code>plotSolution = (x, p; kwargs...) -&gt; nothing</code> function implementing the plot of the solution. For example, you can pass something like <code>(x, p; kwargs...) -&gt; plot(x; kwargs...)</code>.</li><li><code>finaliseSolution = (z, tau, step, contResult; kwargs...) -&gt; true</code> Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning <code>false</code>), saving personal data, plotting... The notations are <span>$z=(x, p)$</span>, <code>tau</code> is the tangent at <code>z</code> (see below), <code>step</code> is the index of the current continuation step and <code>ContResult</code> is the current branch. For advanced use, the current <code>state::ContState</code> of the continuation is passed in <code>kwargs</code>. Note that you can have a better control over the continuation procedure by using an iterator, see <a href="../iterator/#Iterator-Interface">Iterator Interface</a>.</li><li><code>callbackN</code> callback for newton iterations. See docs for <a href="#BifurcationKit.newton"><code>newton</code></a>. Can be used to change preconditioners</li><li><code>tangentAlgo = SecantPred()</code> controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be <code>NaturalPred</code>, <code>SecantPred</code> or <code>BorderedPred</code>. See below for more information.</li><li><code>linearAlgo = BorderingBLS()</code>. Used to control the way the extended linear system associated to the continuation problem is solved. Can be <code>MatrixBLS</code>, <code>BorderingBLS</code> or <code>MatrixFreeBLS</code>.</li><li><code>verbosity::Int = 0</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,1,2,3}</code>. In case <code>contParams.newtonOptions.verbose = false</code>, the following is valid (Otherwise the newton iterations are shown). Each case prints more information then the previous one:<ul><li>case 0: print nothing</li><li>case 1: print basic information about the continuation: used predictor, step size and parameter values</li><li>case 2: print newton iterations number, stability of solution, detected bifurcations / events</li><li>case 3: print information during bisection to detect bifurcation / events</li></ul></li><li><code>normC = norm</code> norm used in the different Newton solves</li><li><code>dotPALC = (x, y) -&gt; dot(x, y) / length(x)</code>, dot product used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see below). This argument can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...)</li><li><code>filename</code> name of a file to save the computed branch during continuation. The identifier .jld2 will be appended to this filename</li><li><code>bothside=true</code> compute the branches on the two sides of <code>p0</code>, merge them and return it.</li></ul><p><strong>Outputs:</strong></p><ul><li><code>contres::ContResult</code> composite type which contains the computed branch. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information.</li><li><code>u::BorderedArray</code> the last solution computed on the branch</li></ul><div class="admonition is-success"><header class="admonition-header">Controlling the argument `linearAlgo`</header><div class="admonition-body"><p>In this simplified interface to <code>continuation</code>, the argument <code>linearAlgo</code> is internally overwritten to provide a valid argument to the algorithm. If you do not want this to happen, call directly <code>continuation(F, J, x0, par, lens, contParams, linearAlgo; kwargs...)</code>.</p></div></div><div class="admonition is-success"><header class="admonition-header">Continuing the branch in the opposite direction</header><div class="admonition-body"><p>Just change the sign of <code>ds</code> in <code>ContinuationPar</code>.</p></div></div><p><strong>Simplified call:</strong></p><p>You can also use the following call for which the jacobian <strong>matrix</strong> (beware of large systems of equations!) is computed internally using Finite Differences</p><pre><code class="nohighlight hljs">continuation(Fhandle, x0, par, lens, contParams::ContinuationPar; kwargs...)</code></pre></div></section><section><div><pre><code class="language-julia hljs">continuation(F, J, br, ind_bif, lens2)
continuation(F, J, br, ind_bif, lens2, options_cont; startWithEigen, issymmetric, Jᵗ, d2F, d3F, detectCodim2Bifurcation, kwargs...)
</code></pre><p>codim 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold/Hopf point into a curve of Fold/Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>F = (x, p) -&gt;	F(x, p)</code> where <code>p</code> is a set of parameters</li><li><code>J = (x, p) -&gt; d_xF(x, p)</code> associated jacobian</li><li><code>br</code> results returned after a call to <a href="../library/#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li><li><code>lens2</code> parameters used for the vector field</li><li><code>options_cont = br.contparams</code> arguments to be passed to the regular <a href="../library/#Library-Continuation">continuation</a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>issymmetric</code> whether the Jacobian is Symmetric (for Fold)</li><li><code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> associated jacobian transpose</li><li><code>d2F = (x, p, v1, v2) -&gt; d2F(x, p, v1, v2)</code> this is the hessian of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2)</code>. This helps solving the linear problem associated to the minimally augmented formulation.</li><li><code>d3F = (x, p, v1, v2, v3) -&gt; d3F(x, p, v1, v2, v3)</code> this is the third derivative of <code>F</code> computed at <code>(x, p)</code> and evaluated at <code>(v1, v2, v3)</code>. This is used to detect <strong>Bautin</strong> bifurcation.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>updateMinAugEveryStep</code> update vectors <code>a,b</code> in Minimally Formulation every <code>updateMinAugEveryStep</code> steps</li><li><code>startWithEigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements</li><li><code>detectCodim2Bifurcation ∈ {0,1,2}</code> whether to detect Bogdanov-Takens, Bautin and Cusp. If equals <code>1</code> non precise detection is used. If equals <code>2</code>, a bisection method is used to locate the bifurcations.</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="../library/#Library-Continuation">continuation</a></li></ul><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Hopf point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">Jacobian transpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to pass the Bordered Linear Solver using the option <code>bdlinsolver = MatrixBLS()</code></p></div></div></div></section><section><div><pre><code class="language-julia hljs">continuation(F, J, x0, par0, x1, p1, lens, contParams; linearAlgo, kwargs...)
</code></pre><p>This function is the analog of <a href="#BifurcationKit.continuation"><code>continuation</code></a> when the two first points on the branch are passed (instead of a single one). Hence <code>x0</code> is the first point on the branch (with palc <code>s=0</code>) with parameter <code>par0</code> and <code>x1</code> is the second point with parameter <code>set(par0, lens, p1)</code>.</p></div></section><section><div><pre><code class="language-julia hljs">continuation(F, dF, d2F, d3F, br, ind_bif)
continuation(F, dF, d2F, d3F, br, ind_bif, optionsCont; Jᵗ, δ, δp, ampfactor, nev, issymmetric, usedeflation, Teigvec, scaleζ, verbosedeflation, maxIterDeflation, perturb, kwargs...)
</code></pre><p>Automatic branch switching at branch points based on a computation of the normal form. More information is provided in <a href="../branchswitching/#Branch-switching-page">Branch switching</a>. An example of use is provided in <a href="../tutorials/mittelmann/#d-generalized-Bratu–Gelfand-problem">2d generalized Bratu–Gelfand problem</a>.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code>: function <code>(x, p) -&gt; F(x, p)</code> and its differentials <code>(x, p, dx) -&gt; d1F(x, p, dx)</code>, <code>(x, p, dx1, dx2) -&gt; d2F(x, p, dx1, dx2)</code>...</li><li><code>br</code> branch result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br</code> from which you want to branch from</li><li><code>optionsCont</code> options for the call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>Jᵗ</code> associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code>.</li><li><code>δ</code> used internally to compute derivatives w.r.t the parameter <code>p</code>.</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>optionsCont.ds</code>. This allows to use a step larger than <code>optionsCont.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alters the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>issymmetric</code> whether the Jacobian is Symmetric, avoid computing the left eigenvectors in the computation of the reduced equation.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>kwargs</code> optional arguments to be passed to <a href="#BifurcationKit.continuation"><code>continuation</code></a>, the regular <code>continuation</code> one.</li></ul><div class="admonition is-success"><header class="admonition-header">Advanced use</header><div class="admonition-body"><p>In the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at <code>methods(BifurcationKit.multicontinuation)</code> to see how to call these versions. These methods has been tested on GPU with very high memory pressure.</p></div></div></div></section><section><div><pre><code class="language-julia hljs">continuation(F, J, par, lens, contParams, defOp; verbosity, maxBranches, seekEveryStep, maxIterDefOp, plot, tangentAlgo, linearAlgo, dotPALC, 465, recordFromSolution, plotSolution, 468, perturbSolution, callbackN, acceptSolution, updateDeflationOp, normN)
</code></pre><p>This function computes the set of curves of solutions <code>γ(s) = (x(s), p(s))</code> to the equation <code>F(x,p)=0</code> based on the algorithm of <strong>deflated continuation</strong> as described in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. “The Computation of Disconnected Bifurcation Diagrams.” ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.</p><p>Depending on the options in <code>contParams</code>, it can locate the bifurcation points on each branch. Note that you can specify different predictors using <code>tangentAlgo</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>F</code> is a function with input arguments <code>(x, p)</code>, where <code>p</code> is the set of parameters passed to <code>F</code>, and returning a vector <code>r</code> that represents the functional. For type stability, the types of <code>x</code> and <code>r</code> should match. In particular, it is not <strong>inplace</strong>,</li><li><code>J</code> is the jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.<ol><li>Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contParams::ContinuationPar</code> will make <code>continuation</code> work.</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contParams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,</li><li>Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</li></ol></li><li><code>par</code> initial set of parameters,</li><li><code>lens::Lens</code> specifies which parameter axis among <code>par</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@lens _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@lens _[1])</code>. For more information, we refer to <code>SetField.jl</code>,</li><li><code>contParams</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a> for more information about the options,</li><li><code>defOp::DeflationOperator</code> a Deflation Operator (see <a href="#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a>) which contains the set of solution guesses for the parameter <code>par</code>.</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>seekEveryStep::Int = 1</code> we look for additional solution, using deflated newton, every <code>seekEveryStep</code> step,</li><li><code>maxBranches::Int = 100</code> maximum number of branches considered,</li><li><code>maxIterDefOp::Int</code> maximum number of deflated Newton iterations</li><li><code>plot = false</code> whether to plot the solution while computing,</li><li><code>recordFromSolution = (x, p) -&gt; norm(x)</code> function used to plot in the continuation curve. It is also used in the way results are saved. It could be <code>norm</code> or <code>(x, p) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU...),</li><li><code>plotSolution = (x, p; kwargs...) -&gt; nothing</code> function implementing the plot of the solution,</li><li><code>callbackN</code> callback for newton iterations. see docs for <code>newton</code>. Can be used to change preconditioners or affect the newton iterations. In the deflation part of the algorithm, when seeking for new branches, the callback is passed the keyword argument <code>fromDeflatedNewton = true</code> to tell the user can it is not in the continuation part (regular newton) of the algorithm,</li><li><code>tangentAlgo = NaturalPred()</code> controls the algorithm used to predict the tangents along the curve of solutions or the corrector. Can be <code>NaturalPred</code>, <code>SecantPred</code> or <code>BorderedPred</code>,</li><li><code>verbosity::Int</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,⋯,5}</code>,</li><li><code>normN = norm</code> norm used in the different Newton solves,</li><li><code>dotPALC = (x, y) -&gt; dot(x, y) / length(x)</code>, dot product used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see below). This argument can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...),</li><li><code>perturbSolution = (x, p, id) -&gt; x</code> perturbation applied to the solution when trying to find new solutions using Deflated Newton. You can use for example <code>(x, p, id) -&gt; x .+ (1 .+ 0.001 * rand(size(x)...))</code></li></ul><p><strong>Outputs:</strong></p><ul><li><code>contres::Vector{ContResult}</code> composite type which contains the computed branches. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information,</li><li>the iterator associated with the computation</li><li>the solutions at the last parameter value,</li><li>current parameter value.</li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, orbitguess, par, lens, contParams, linearAlgo; jacobianPO, updateSectionEveryStep, δ, kwargs...)
</code></pre><p>This is the continuation method for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Optional argument</strong></p><ul><li><code>δ = 1e-8</code> used for finite differences</li><li><code>jacobianPO</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences]</code>. This is used to select a way of inverting the jacobian dG</li><li><code>updateSectionEveryStep = 0</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li></ul><p><strong>Choices for <code>jacobianPO</code></strong></p><ul><li>For <code>:MatrixFree</code>, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in <code>prob</code>.</li><li>For <code>:autodiffMF</code>, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code>.</li><li>For <code>:autodiffDense</code>. Same as for <code>:autodiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>.</li><li>For <code>:FiniteDifferencesDense</code>, same as for <code>:autodiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>:autodiffDenseAnalytical</code>. Same as for <code>:autodiffDense</code> but the jacobian is using a mix of AD and analytical formula.</li><li>For <code>:FiniteDifferences</code>, use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, orbitguess, par, lens, _contParams; linearAlgo, kwargs...)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>.</p><ul><li><code>printPeriod</code> boolean to print the period of the solution. This is useful for <code>prob::PoincareShootingProblem</code> as this information is not easily available.</li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(F, dF, d2F, d3F, br, ind_bif, _contParams, prob; Jᵗ, δ, δp, ampfactor, usedeflation, nev, updateSectionEveryStep, kwargs...)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points of a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code>: function <code>(x, p) -&gt; F(x, p)</code> and its differentials <code>(x, p, dx) -&gt; d1F(x, p, dx)</code>, <code>(x, p, dx1, dx2) -&gt; d2F(x, p, dx1, dx2)</code>... These are used to compute the Hopf normal form.</li><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>prob</code> problem used to specify the way the periodic orbit is computed. It can be <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>, <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>jacobianPO</code> linear algorithm used for the computation of periodic orbits when <code>prob</code> is <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>)</li><li><code>Jᵗ</code> is the jacobian adjoint, used for computation of the eigen-elements of the jacobian adjoint, needed to compute the spectral projector for the Hopf normal form. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>δ = 1e-8</code> used for finite differences</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>updateSectionEveryStep = 0</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li><li><code>jacobianPO</code> specify the way the jacobian is computed.</li><li>all <code>kwargs</code> from <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plotSolution</code> and <code>finaliseSolution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be careful about the options <code>contParams.newtonOptions.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian transpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not <code>nothing</code>, is computed with Finite differences.</p></div></div></div></section><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif, _contParams; δp, ampfactor, usedeflation, linearAlgo, kwargs...)
</code></pre><p>Branch switching at a Bifurcation point of a branch of periodic orbits (PO) specified by a <code>br::AbstractBranchResult</code>. The functional used to compute the PO is <code>br.functional</code>. A deflated Newton-Krylov solver can be used to improve the branch switching capabilities.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch of periodic orbits computed with a <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a></li><li><code>ind_bif</code> index of the branch point</li><li><code>_contParams</code> parameters to be used by a regular <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>δp = 0.1</code> used to specify a particular guess for the parameter in the branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>jacobianPO = :BorderedLU</code> linear solver used for the Newton-Krylov solver when applied to <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>.</li><li><code>recordFromSolution = (u, p) -&gt; u[end]</code>, print method used in the bifurcation diagram, by default this prints the period of the periodic orbit.</li><li><code>linearAlgo = BorderingBLS()</code>, same as for <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>kwargs</code> keywords arguments used for a call to the regular <a href="#BifurcationKit.continuation"><code>continuation</code></a> and the ones specific to POs.</li></ul></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, orbitguess, par, lens, _contParams; jacobianPO, recordFromSolution, linearAlgo, updateSectionEveryStep, kwargs...)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><p><code>prob::PeriodicOrbitTrapProblem</code> encodes the functional G</p></li><li><p><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It could be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</p></li><li><p><code>p0</code> set of parameters passed to the vector field</p></li><li><p><code>contParams</code> same as for the regular <a href="#BifurcationKit.continuation"><code>continuation</code></a> method</p></li><li><p><code>linearAlgo</code> same as in <a href="#BifurcationKit.continuation"><code>continuation</code></a></p></li><li><p><code>jacobianPO = :BorderedLU</code>. Specify the choice of the linear algorithm, which must belong to <code>[:FullLU, :FullSparseInplace, :BorderedLU, :FullMatrixFree, :BorderedMatrixFree, :FullSparseInplace]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.</p><ul><li>For <code>:FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>:FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>:Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>:BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver. This is the default algorithm.</li><li>For <code>:BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>:FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>:BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li></ul></li><li><p><code>updateSectionEveryStep = 1</code> updates the section every when <code>mod(step, updateSectionEveryStep) == 1</code> during continuation</p></li></ul><p>Note that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your <code>recordFromSolution</code> argument.</p></div></section><section><div><pre><code class="language-julia hljs">continuation(prob, orbitguess, par, lens, _contParams, _linearAlgo; jacobianPO, updateSectionEveryStep, kwargs...)
</code></pre><p>This is the continuation method for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Optional argument</strong></p><ul><li><code>δ = 1e-8</code> used for finite differences</li><li><code>jacobianPO</code> Specify the choice of the linear algorithm, which must belong to <code>[:autodiffMF, :MatrixFree, :autodiffDense, :autodiffDenseAnalytical, :FiniteDifferences]</code>. This is used to select a way of inverting the jacobian dG</li><li><code>updateSectionEveryStep = 0</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li></ul><p><strong>Choices for <code>jacobianPO</code></strong></p><ul><li>For <code>:MatrixFree</code>, we use an iterative solver (e.g. GMRES) to solve the linear system. The jacobian was specified by the user in <code>prob</code>.</li><li>For <code>:autodiffMF</code>, we use iterative solver (e.g. GMRES) to solve the linear system. We use Automatic Differentiation to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code>.</li><li>For <code>:autodiffDense</code>. Same as for <code>:autodiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>.</li><li>For <code>:FiniteDifferencesDense</code>, same as for <code>:autodiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>:autodiffDenseAnalytical</code>. Same as for <code>:autodiffDense</code> but the jacobian is using a mix of AD and analytical formula.</li><li>For <code>:FiniteDifferences</code>, use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></div></section></article><h2 id="Events"><a class="docs-heading-anchor" href="#Events">Events</a><a id="Events-1"></a><a class="docs-heading-anchor-permalink" href="#Events" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.DiscreteEvent" href="#BifurcationKit.DiscreteEvent"><code>BifurcationKit.DiscreteEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DiscreteEvent{Tcb, Tl} &lt;: BifurcationKit.AbstractDiscreteEvent</code></pre><p>Structure to pass a DiscreteEvent function to the continuation algorithm. A continuous call back returns a discrete value and we seek when it changes.</p><ul><li><p><code>nb::Int64</code></p><p>number of events, ie the length of the result returned by the callback function</p></li><li><p><code>condition::Any</code></p><p>, <code>(iter, state) -&gt; NTuple{nb, Int64}</code> callback function which at each continuation state, returns a tuple. For example, to detect a value change.</p></li><li><p><code>computeEigenElements::Bool</code></p><p>whether the event requires to compute eigen elements</p></li><li><p><code>labels::Any</code></p><p>Labels used to display information. For example <code>labels[1]</code> is used top qualify an event occuring in the first component. For example, you can use <code>labels = (&quot;hopf&quot;,)</code> or <code>labels = (&quot;hopf&quot;, &quot;fold&quot;)</code>. You must have <code>labels::Union{Nothing, NTuple{N, String}}</code>.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.ContinuousEvent" href="#BifurcationKit.ContinuousEvent"><code>BifurcationKit.ContinuousEvent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ContinuousEvent{Tcb, Tl} &lt;: BifurcationKit.AbstractContinuousEvent</code></pre><p>Structure to pass a ContinuousEvent function to the continuation algorithm. A continuous call back returns a <strong>tuple/scalar</strong> value and we seek its zeros.</p><ul><li><p><code>nb::Int64</code></p><p>number of events, ie the length of the result returned by the callback function</p></li><li><p><code>condition::Any</code></p><p>, <code>(iter, state) -&gt; NTuple{nb, T}</code> callback function which, at each continuation state, returns a tuple. For example, to detect crossing 1.0 and -2.0, you can pass <code>(iter, state) -&gt; (getp(state)+2, getx(state)[1]-1)),</code>. Note that the type <code>T</code> should match the one of the parameter specified by the <code>::Lens</code> in <code>continuation</code>.</p></li><li><p><code>computeEigenElements::Bool</code></p><p>whether the event requires to compute eigen elements</p></li><li><p><code>labels::Any</code></p><p>Labels used to display information. For example <code>labels[1]</code> is used top qualify an event of the type <code>(0,1.3213,3.434)</code>. For example, you can use <code>labels = (&quot;hopf&quot;,)</code> or <code>labels = (&quot;hopf&quot;, &quot;fold&quot;)</code>. You must have <code>labels::Union{Nothing, NTuple{N, String}}</code>.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SetOfEvents" href="#BifurcationKit.SetOfEvents"><code>BifurcationKit.SetOfEvents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SetOfEvents{Tc&lt;:Tuple, Td&lt;:Tuple} &lt;: BifurcationKit.AbstractEvent</code></pre><p>Multiple events can be chained together to form a <code>SetOfEvents</code>. A <code>SetOfEvents</code> is constructed by passing the constructor <code>ContinuousEvent</code>, <code>DiscreteEvent</code> or other <code>SetOfEvents</code> instances:</p><pre><code class="nohighlight hljs">SetOfEvents(cb1, cb2, cb3)</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs"> BK.SetOfEvents(BK.FoldDetectCB, BK.BifDetectCB)</code></pre><p>You can pass as many events as you like.</p><ul><li><p><code>eventC::Tuple</code></p><p>Continuous event</p></li><li><p><code>eventD::Tuple</code></p><p>Discrete event</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PairOfEvents" href="#BifurcationKit.PairOfEvents"><code>BifurcationKit.PairOfEvents</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct PairOfEvents{Tc&lt;:BifurcationKit.AbstractContinuousEvent, Td&lt;:BifurcationKit.AbstractDiscreteEvent} &lt;: BifurcationKit.AbstractEvent</code></pre><p>Structure to pass a PairOfEvents function to the continuation algorithm. It is composed of a pair ContinuousEvent / DiscreteEvent.</p><ul><li><p><code>eventC::BifurcationKit.AbstractContinuousEvent</code></p><p>Continuous event</p></li><li><p><code>eventD::BifurcationKit.AbstractDiscreteEvent</code></p><p>Discrete event</p></li></ul></div></section></article><h2 id="Branch-switching-(branch-point)"><a class="docs-heading-anchor" href="#Branch-switching-(branch-point)">Branch switching (branch point)</a><a id="Branch-switching-(branch-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(branch-point)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation-Tuple{Any, Any, Any, Any, ContResult, Int64, ContinuationPar}" href="#BifurcationKit.continuation-Tuple{Any, Any, Any, Any, ContResult, Int64, ContinuationPar}"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">continuation(F, dF, d2F, d3F, br, ind_bif)
continuation(F, dF, d2F, d3F, br, ind_bif, optionsCont; Jᵗ, δ, δp, ampfactor, nev, issymmetric, usedeflation, Teigvec, scaleζ, verbosedeflation, maxIterDeflation, perturb, kwargs...)
</code></pre><p>Automatic branch switching at branch points based on a computation of the normal form. More information is provided in <a href="../branchswitching/#Branch-switching-page">Branch switching</a>. An example of use is provided in <a href="../tutorials/mittelmann/#d-generalized-Bratu–Gelfand-problem">2d generalized Bratu–Gelfand problem</a>.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code>: function <code>(x, p) -&gt; F(x, p)</code> and its differentials <code>(x, p, dx) -&gt; d1F(x, p, dx)</code>, <code>(x, p, dx1, dx2) -&gt; d2F(x, p, dx1, dx2)</code>...</li><li><code>br</code> branch result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br</code> from which you want to branch from</li><li><code>optionsCont</code> options for the call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>Jᵗ</code> associated jacobian transpose, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code>.</li><li><code>δ</code> used internally to compute derivatives w.r.t the parameter <code>p</code>.</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>optionsCont.ds</code>. This allows to use a step larger than <code>optionsCont.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alters the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>issymmetric</code> whether the Jacobian is Symmetric, avoid computing the left eigenvectors in the computation of the reduced equation.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>kwargs</code> optional arguments to be passed to <a href="#BifurcationKit.continuation"><code>continuation</code></a>, the regular <code>continuation</code> one.</li></ul><div class="admonition is-success"><header class="admonition-header">Advanced use</header><div class="admonition-body"><p>In the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at <code>methods(BifurcationKit.multicontinuation)</code> to see how to call these versions. These methods has been tested on GPU with very high memory pressure.</p></div></div></div></section></article><h2 id="Branch-switching-(Hopf-point)"><a class="docs-heading-anchor" href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a><a id="Branch-switching-(Hopf-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(Hopf-point)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.continuation-Tuple{Any, Any, Any, Any, BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}" href="#BifurcationKit.continuation-Tuple{Any, Any, Any, Any, BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">continuation(F, dF, d2F, d3F, br, ind_bif, _contParams, prob; Jᵗ, δ, δp, ampfactor, usedeflation, nev, updateSectionEveryStep, kwargs...)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points of a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code>: function <code>(x, p) -&gt; F(x, p)</code> and its differentials <code>(x, p, dx) -&gt; d1F(x, p, dx)</code>, <code>(x, p, dx1, dx2) -&gt; d2F(x, p, dx1, dx2)</code>... These are used to compute the Hopf normal form.</li><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>prob</code> problem used to specify the way the periodic orbit is computed. It can be <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>, <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>jacobianPO</code> linear algorithm used for the computation of periodic orbits when <code>prob</code> is <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>)</li><li><code>Jᵗ</code> is the jacobian adjoint, used for computation of the eigen-elements of the jacobian adjoint, needed to compute the spectral projector for the Hopf normal form. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of Matrix / Sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoid recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code></li><li><code>δ = 1e-8</code> used for finite differences</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>updateSectionEveryStep = 0</code> updates the section every <code>updateSectionEveryStep</code> step during continuation</li><li><code>jacobianPO</code> specify the way the jacobian is computed.</li><li>all <code>kwargs</code> from <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plotSolution</code> and <code>finaliseSolution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be careful about the options <code>contParams.newtonOptions.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div><div class="admonition is-success"><header class="admonition-header">Jacobian transpose</header><div class="admonition-body"><p>The adjoint of the jacobian <code>J</code> is computed internally when <code>Jᵗ = nothing</code> by using <code>transpose(J)</code> which works fine when <code>J</code> is an <code>AbstractArray</code>. In this case, do not pass the jacobian adjoint like <code>Jᵗ = (x, p) -&gt; transpose(d_xF(x, p))</code> otherwise the jacobian would be computed twice!</p></div></div><div class="admonition is-warning"><header class="admonition-header">Hessian</header><div class="admonition-body"><p>The hessian of <code>F</code>, when <code>d2F</code> is not <code>nothing</code>, is computed with Finite differences.</p></div></div></div></section></article><h2 id="Bifurcation-diagram"><a class="docs-heading-anchor" href="#Bifurcation-diagram">Bifurcation diagram</a><a id="Bifurcation-diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Bifurcation-diagram" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram" href="#BifurcationKit.bifurcationdiagram"><code>BifurcationKit.bifurcationdiagram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bifurcationdiagram(F, dF, d2F, d3F, x0, par0, lens, level, options; kwargs...)
</code></pre><p>Compute the bifurcation diagram associated with the problem <code>F(x, p) = 0</code> recursively.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code> functional and its derivatives</li><li><code>x0</code> initial guess</li><li><code>par0</code> parameter values at <code>x0</code></li><li><code>lens</code> lens to select the parameter axis</li><li><code>level</code> maximum branching (or recursion) level for computing the bifurcation diagram</li><li><code>options = (x, p, level) -&gt; contparams</code> this function allows to change the <a href="#BifurcationKit.continuation"><code>continuation</code></a> options depending on the branching <code>level</code>. The argument <code>x, p</code> denotes the current solution to <code>F(x, p)=0</code>.</li><li><code>kwargs</code> optional arguments. Look at <a href="#BifurcationKit.bifurcationdiagram!"><code>bifurcationdiagram!</code></a> for more details.</li></ul><p><strong>Simplified call:</strong></p><p>We also provide the call</p><p><code>bifurcationdiagram(F, dF, d2F, d3F, br::ContResult, level::Int, options; kwargs...)</code></p><p>where <code>br</code> is a branch computed after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a> from which we want to compute the bifurcating branches recursively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram!" href="#BifurcationKit.bifurcationdiagram!"><code>BifurcationKit.bifurcationdiagram!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bifurcationdiagram!(F, dF, d2F, d3F, node, maxlevel, options; code, usedeflation, halfbranch, kwargs...)
</code></pre><p>Similar to <a href="#BifurcationKit.bifurcationdiagram"><code>bifurcationdiagram</code></a> but you pass a previously computed <code>node</code> from which you want to further compute the bifurcated branches. It is usually used with <code>node = getBranch(diagram, code)</code> from a previously computed bifurcation <code>diagram</code>.</p><p><strong>Arguments</strong></p><ul><li><code>node::BifDiagNode</code> a node in the bifurcation diagram</li><li><code>maxlevel = 1</code> required maximal level of recursion.</li><li><code>options = (x, p, level) -&gt; contparams</code> this function allows to change the <a href="#BifurcationKit.continuation"><code>continuation</code></a> options depending on the branching <code>level</code>. The argument <code>x, p</code> denotes the current solution to <code>F(x, p)=0</code>.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>code = &quot;0&quot;</code> code used to display iterations</li><li><code>usedeflation = false</code></li><li><code>halfbranch = false</code> for Pitchfork/Transcritical bifurcations, compute only half of the branch. Can be useful when there are symmetries.</li><li><code>kwargs</code> optional arguments as for <a href="#BifurcationKit.continuation"><code>continuation</code></a> but also for the different versions listed in <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/library/#Continuation-1">Continuation</a>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getBranch" href="#BifurcationKit.getBranch"><code>BifurcationKit.getBranch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getBranch(tree, code)
</code></pre><p>Return the part of the tree (bifurcation diagram) by recursively descending down the tree using the <code>Int</code> valued tuple <code>code</code>. For example <code>getBranch(tree, (1,2,3,))</code> returns <code>tree.child[1].child[2].child[3]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getBranchesFromBP" href="#BifurcationKit.getBranchesFromBP"><code>BifurcationKit.getBranchesFromBP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getBranchesFromBP(tree, indbif)
</code></pre><p>Return the part of the tree corresponding to the indbif-th bifurcation point on the root branch.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SpecialPoint" href="#BifurcationKit.SpecialPoint"><code>BifurcationKit.SpecialPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SpecialPoint{T, Tp, Tv} &lt;: BifurcationKit.AbstractBifurcationPoint</code></pre><p>Structure to record a generic special (bifurcation) point.</p><ul><li><p><code>type::Symbol</code></p><p>Bifurcation type, <code>:hopf, :bp...</code>. Default: :none</p></li><li><p><code>idx::Int64</code></p><p>Index in <code>br.eig</code> (see <a href="#BifurcationKit.ContResult"><code>ContResult</code></a>) for which the bifurcation occurs. Default: 0</p></li><li><p><code>param::Any</code></p><p>Parameter value at the special (bifurcation) point, this is an estimate. Default: 0.0</p></li><li><p><code>norm::Any</code></p><p>Norm of the equilibrium at the special (bifurcation) point Default: 0.0</p></li><li><p><code>printsol::Any</code></p><p><code>printsol = recordFromSolution(x, param)</code> where <code>recordFromSolution</code> is one of the arguments to <a href="#BifurcationKit.continuation"><code>continuation</code></a> Default: 0.0</p></li><li><p><code>x::Any</code></p><p>Equilibrium at the special (bifurcation) point Default: Vector{T}(undef, 0)</p></li><li><p><code>tau::BorderedArray{Tv, T} where {T, Tv}</code></p><p>Tangent along the branch at the special (bifurcation) point Default: BorderedArray(x, T(0))</p></li><li><p><code>ind_ev::Int64</code></p><p>Eigenvalue index responsible for the special (bifurcation) (if applicable) Default: 0</p></li><li><p><code>step::Int64</code></p><p>Continuation step at which the special (bifurcation) occurs Default: 0</p></li><li><p><code>status::Symbol</code></p><p><code>status ∈ {:converged, :guess}</code> indicates whether the bisection algorithm was successful in detecting the special (bifurcation) point Default: :guess</p></li><li><p><code>δ::Tuple{Int64, Int64}</code></p><p><code>δ = (δr, δi)</code> where δr indicates the change in the number of unstable eigenvalues and δi indicates the change in the number of unstable eigenvalues with nonzero imaginary part. <code>abs(δr)</code> is thus an estimate of the dimension of the kernel of the Jacobian at the special (bifurcation) point. Default: (0, 0)</p></li><li><p><code>precision::Any</code></p><p>Precision in the location of the special (bifurcation) point Default: -1</p></li><li><p><code>interval::Tuple{T, T} where T</code></p><p>Interval containing the special (bifurcation) point Default: (0, 0)</p></li></ul></div></section></article><h2 id="Utils-for-periodic-orbits"><a class="docs-heading-anchor" href="#Utils-for-periodic-orbits">Utils for periodic orbits</a><a id="Utils-for-periodic-orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Utils-for-periodic-orbits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getPeriod" href="#BifurcationKit.getPeriod"><code>BifurcationKit.getPeriod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getPeriod(sh, x)
getPeriod(sh, x, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getPeriod(prob, x, p)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getPeriod(psh, x_bar, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x_bar</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getAmplitude" href="#BifurcationKit.getAmplitude"><code>BifurcationKit.getAmplitude</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getAmplitude(prob, x, p; ratio)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getAmplitude(prob, x, p; ratio)
</code></pre><p>Compute the amplitude of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.getMaximum" href="#BifurcationKit.getMaximum"><code>BifurcationKit.getMaximum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p; ratio)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = 1 + ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>.</p></div></section><section><div><pre><code class="language-julia hljs">getMaximum(prob, x, p; ratio)
</code></pre><p>Compute the maximum of the periodic orbit associated to <code>x</code>. The keyword argument <code>ratio = 1</code> is used as follows. If <code>length(x) = ratio * n</code>, the call returns the amplitude over <code>x[1:n]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SectionSS" href="#BifurcationKit.SectionSS"><code>BifurcationKit.SectionSS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SectionSS{Tn, Tc} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for Section Standard Shooting) encodes a type of section implemented by a single hyperplane. It can be used in conjunction with <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a>. The hyperplane is defined by a point <code>center</code> and a <code>normal</code>.</p><ul><li><p><code>normal::Any</code></p><p>Normal to define hyperplane</p></li><li><p><code>center::Any</code></p><p>Representative point on hyperplane</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.SectionPS" href="#BifurcationKit.SectionPS"><code>BifurcationKit.SectionPS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SectionPS{Tn, Tc, Tnb, Tcb} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for SectionPoincaréShooting) encodes a type of Poincaré sections implemented by hyperplanes. It can be used in conjunction with <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. Each hyperplane is defined par a point (one example in <code>centers</code>) and a normal (one example in <code>normals</code>).</p><ul><li><p><code>M::Int64</code></p></li><li><p><code>normals::Any</code></p></li><li><p><code>centers::Any</code></p></li><li><p><code>indices::Vector{Int64}</code></p></li><li><p><code>normals_bar::Any</code></p></li><li><p><code>centers_bar::Any</code></p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="nohighlight hljs">SectionPS(normals::Vector{Tv}, centers::Vector{Tv})</code></pre></div></section></article><h2 id="Misc."><a class="docs-heading-anchor" href="#Misc.">Misc.</a><a id="Misc.-1"></a><a class="docs-heading-anchor-permalink" href="#Misc." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurKrylovKit" href="#BifurcationKit.PrecPartialSchurKrylovKit"><code>BifurcationKit.PrecPartialSchurKrylovKit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>KrylovKit.jl</code>, from which a projection is built. The options are similar to the ones of <code>EigKrylovKit()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurArnoldiMethod" href="#BifurcationKit.PrecPartialSchurArnoldiMethod"><code>BifurcationKit.PrecPartialSchurArnoldiMethod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>ArnoldiMethod.jl</code>, from which a projection is built. See the package <code>ArnoldiMethod.jl</code> for how to pass the proper options.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.Flow" href="#BifurcationKit.Flow"><code>BifurcationKit.Flow</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Flow{TF, Tf, Tts, Tff, Td, Tse, Tprob, TprobMono, Tfs, Tcb}</code></pre><ul><li><p><code>F::Any</code></p><p>The vector field <code>(x, p) -&gt; F(x, p)</code> associated to a Cauchy problem. Used for the differential of the shooting problem. Default: nothing</p></li><li><p><code>flow::Any</code></p><p>The flow (or semigroup) associated to the Cauchy problem <code>(x, p, t) -&gt; flow(x, p, t)</code>. Only the last time point must be returned in the form (u = ...) Default: nothing</p></li><li><p><code>flowTimeSol::Any</code></p><p>Flow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>flowFull::Any</code></p><p>[Optional] The flow (or semigroup) associated to the Cauchy problem <code>(x, p, t) -&gt; flow(x, p, t)</code>. The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, it is mainly used for plotting on the user side. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>dflow::Any</code></p><p>The differential <code>dflow</code> of the flow <em>w.r.t.</em> <code>x</code>, <code>(x, p, dx, t) -&gt; dflow(x, p, dx, t)</code>. One important thing is that we require <code>dflow(x, dx, t)</code> to return a Named Tuple: <code>(t = t, u = flow(x, p, t), du = dflow(x, p, dx, t))</code>, the last component being the value of the derivative of the flow. Default: nothing</p></li><li><p><code>dfSerial::Any</code></p><p>[Optional] Serial version of dflow. Used internally when using parallel multiple shooting. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>prob::Any</code></p><p>[Internal] store the ODEProblem associated to the flow of the Cauchy problem Default: nothing</p></li><li><p><code>probMono::Any</code></p><p>[Internal] store the ODEProblem associated to the flow of the variational problem Default: nothing</p></li><li><p><code>flowSerial::Any</code></p><p>[Internal] Serial version of the flow Default: nothing</p></li><li><p><code>callback::Any</code></p><p>[Internal] Store possible callback Default: nothing</p></li></ul><p><strong>Simplified constructor(s)</strong></p><p>We provide a simple constructor where you only pass the vector field <code>F</code>, the flow <code>ϕ</code> and its differential <code>dϕ</code>:</p><pre><code class="nohighlight hljs">fl = Flow(F, ϕ, dϕ)</code></pre><p><strong>Simplified constructors for DifferentialEquations.jl</strong></p><p>There are some simple constructors for which you only have to pass a <code>prob::ODEProblem</code> or <code>prob::EnsembleProblem</code> (for parallel computation) from <code>DifferentialEquations.jl</code> and an ODE time stepper like <code>Tsit5()</code>. Hence, you can do for example</p><pre><code class="nohighlight hljs">fl = Flow(F, prob, Tsit5(); kwargs...)</code></pre><p>where <code>kwargs</code> is passed to <code>DiffEqBase::solve</code>. If your vector field depends on parameters <code>p</code>, you can define a <code>Flow</code> using</p><pre><code class="nohighlight hljs">fl = Flow(F, p, prob, Tsit5(); kwargs...)</code></pre><p>Finally, you can pass two <code>ODEProblem</code> where the second one is used to compute the variational equation:</p><pre><code class="nohighlight hljs">fl = Flow(F, p, prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.FloquetQaD" href="#BifurcationKit.FloquetQaD"><code>BifurcationKit.FloquetQaD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">floquet = FloquetQaD(eigsolver::AbstractEigenSolver)</code></pre><p>This composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems (based on the Shooting method or Finite Differences (Trapeze method)), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents when the number of time sections is large because of many matrix products. It allows, nevertheless, to detect bifurcations. The arguments are as follows:</p><ul><li><code>eigsolver::AbstractEigenSolver</code> solver used to compute the eigenvalues.</li></ul><p>If <code>eigsolver == DefaultEig()</code>, then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.</p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver <code>eigsolver</code> needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of <code>eigsolver</code>. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.guessFromHopf-Tuple{Any, Any, AbstractEigenSolver, Any, Any}" href="#BifurcationKit.guessFromHopf-Tuple{Any, Any, AbstractEigenSolver, Any, Any}"><code>BifurcationKit.guessFromHopf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">guessFromHopf(br, ind_hopf, eigsolver, M, amplitude; phase)
</code></pre><p>This function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:</p><ul><li>the parameter value at which a Hopf bifurcation occurs</li><li>the period of the bifurcated periodic orbit</li><li>a guess for the bifurcated periodic orbit</li><li>the equilibrium at the Hopf bifurcation point</li><li>the eigenvector at the Hopf bifurcation point.</li></ul><p>The arguments are</p><ul><li><code>br</code>: the continuation branch which lists the Hopf bifurcation points</li><li><code>ind_hopf</code>: index of the bifurcation branch, as in <code>br.specialpoint</code></li><li><code>eigsolver</code>: the eigen solver used to find the eigenvectors</li><li><code>M</code> number of time slices in the periodic orbit guess</li><li><code>amplitude</code>: amplitude of the periodic orbit guess</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BifurcationKit.computeNormalForm" href="#BifurcationKit.computeNormalForm"><code>BifurcationKit.computeNormalForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computeNormalForm(F, dF, d2F, d3F, br, id_bif; δ, nev, Jᵗ, verbose, ζs, lens, issymmetric, Teigvec, scaleζ)
</code></pre><p>Compute the normal form of the bifurcation point located at <code>br.specialpoint[ind_bif]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>F, dF, d2F, d3F</code> vector field <code>(x, p) -&gt; F(x, p)</code> and its derivatives w.r.t. <code>x</code>.</li><li><code>br</code> result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br.specialpoint</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>δ</code> used to compute ∂pF with finite differences</li><li><code>nev</code> number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.</li><li><code>Jᵗ = (x,p) -&gt; ...</code> jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code>.</li><li><code>verbose</code> whether to display information</li><li><code>ζs</code> list of vectors spanning the kernel of <code>dF</code> at the bifurcation point. Useful to enforce the basis for the normal form.</li><li><code>lens::Lens</code> specify which parameter to take the partial derivative ∂pF</li><li><code>issymmetric</code> whether the Jacobian is Symmetric, avoid computing the left eigenvectors.</li><li><code>scaleζ</code> function to normalise the kernel basis. Indeed, when used with large vectors and <code>norm</code>, it results in ζs and the normal form coefficient being super small.</li></ul><p>Based on Golubitsky, Martin, David G Schaeffer, and Ian Stewart. Singularities and Groups in Bifurcation Theory. New York: Springer-Verlag, 1985, VI.1.d page 295.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../faq/">« Frequently Asked Questions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 1 December 2021 20:02">Wednesday 1 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
