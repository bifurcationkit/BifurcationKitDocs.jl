<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Bifurcation Analysis in Julia</title><meta name="title" content="Library · Bifurcation Analysis in Julia"/><meta property="og:title" content="Library · Bifurcation Analysis in Julia"/><meta property="twitter:title" content="Library · Bifurcation Analysis in Julia"/><meta name="description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="og:description" content="Documentation for Bifurcation Analysis in Julia."/><meta property="twitter:description" content="Documentation for Bifurcation Analysis in Julia."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started with BifurcationKit</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../educational/">Educational introduction</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../waveEigen/">Eigen Solvers</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../hybrid/">AutoSwitch</a></li><li><a class="tocitem" href="../ANM/">ANM</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-8-1" type="checkbox"/><label class="tocitem" for="menuitem-8-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-2" type="checkbox"/><label class="tocitem" for="menuitem-8-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (2 params)</a></li><li><a class="tocitem" href="../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-3" type="checkbox"/><label class="tocitem" for="menuitem-8-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-4" type="checkbox"/><label class="tocitem" for="menuitem-8-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../cusp/">Cusp</a></li><li><a class="tocitem" href="../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../bautin/">Bautin</a></li><li><a class="tocitem" href="../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-5" type="checkbox"/><label class="tocitem" for="menuitem-8-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../bppo/">Simple branch point</a></li><li><a class="tocitem" href="../pd/">Period-doubling</a></li><li><a class="tocitem" href="../ns/">Neimark-Sacker</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8-6" type="checkbox"/><label class="tocitem" for="menuitem-8-6"><span class="docs-label">Branch switching</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro-abs/">Introduction</a></li><li><a class="tocitem" href="../abs-from-eq/">From equilibria to equilibria</a></li><li><a class="tocitem" href="../abs-from-hopf/">From Hopf/PD/Branch to periodic orbits</a></li><li><a class="tocitem" href="../abs-from-codim2-eq/">From codim 2 to equilibria</a></li><li><a class="tocitem" href="../abs-from-codim2-po/">From codim 2 to periodic orbits</a></li></ul></li><li><a class="tocitem" href="../BifurcationDiagram/">Automatic Bifurcation diagram</a></li><li><a class="tocitem" href="../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-10-1" type="checkbox"/><label class="tocitem" for="menuitem-10-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../migration/">Migration from old versions</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Parameters"><span>Parameters</span></a></li><li><a class="tocitem" href="#Results"><span>Results</span></a></li><li><a class="tocitem" href="#Problems"><span>Problems</span></a></li><li><a class="tocitem" href="#Library-LS"><span>Linear solvers</span></a></li><li><a class="tocitem" href="#Library-EIG"><span>Eigen solvers</span></a></li><li><a class="tocitem" href="#Library-BLS"><span>Bordered linear solvers</span></a></li><li><a class="tocitem" href="#Nonlinear-solver"><span>Nonlinear solver</span></a></li><li><a class="tocitem" href="#Library-Continuation"><span>Continuation</span></a></li><li><a class="tocitem" href="#Continuation-algorithms"><span>Continuation algorithms</span></a></li><li><a class="tocitem" href="#Events"><span>Events</span></a></li><li><a class="tocitem" href="#Branch-switching-(branch-point)"><span>Branch switching (branch point)</span></a></li><li><a class="tocitem" href="#Branch-switching-(Hopf-point)"><span>Branch switching (Hopf point)</span></a></li><li><a class="tocitem" href="#Bifurcation-diagram"><span>Bifurcation diagram</span></a></li><li><a class="tocitem" href="#Utils-for-periodic-orbits"><span>Utils for periodic orbits</span></a></li><li><a class="tocitem" href="#Misc."><span>Misc.</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/library.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul><li><a href="#Library">Library</a></li><li class="no-marker"><ul><li><a href="#Parameters">Parameters</a></li><li><a href="#Results">Results</a></li><li><a href="#Problems">Problems</a></li><li class="no-marker"><ul><li><a href="#Periodic-orbits">Periodic orbits</a></li><li><a href="#Waves">Waves</a></li></ul></li><li><a href="#Library-LS">Linear solvers</a></li><li><a href="#Library-EIG">Eigen solvers</a></li><li><a href="#Library-BLS">Bordered linear solvers</a></li><li><a href="#Nonlinear-solver">Nonlinear solver</a></li><li><a href="#Library-Continuation">Continuation</a></li><li><a href="#Continuation-algorithms">Continuation algorithms</a></li><li><a href="#Events">Events</a></li><li><a href="#Branch-switching-(branch-point)">Branch switching (branch point)</a></li><li><a href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a></li><li><a href="#Bifurcation-diagram">Bifurcation diagram</a></li><li><a href="#Utils-for-periodic-orbits">Utils for periodic orbits</a></li><li><a href="#Misc.">Misc.</a></li></ul></li></ul><h2 id="Parameters"><a class="docs-heading-anchor" href="#Parameters">Parameters</a><a id="Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Parameters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.NewtonPar" href="#BifurcationKit.NewtonPar"><code>BifurcationKit.NewtonPar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct NewtonPar{T, L&lt;:BifurcationKit.AbstractLinearSolver, E&lt;:AbstractEigenSolver}</code></pre><p>Returns a variable containing parameters to affect the <code>newton</code> algorithm when solving <code>F(x) = 0</code>.</p><p><strong>Arguments (with default values):</strong></p><ul><li><p><code>tol::Any</code>: absolute tolerance for <code>F(x)</code> Default: 1.0e-12</p></li><li><p><code>max_iterations::Int64</code>: number of Newton iterations Default: 25</p></li><li><p><code>verbose::Bool</code>: display Newton iterations? Default: false</p></li><li><p><code>linsolver::BifurcationKit.AbstractLinearSolver</code>: linear solver, must be <code>&lt;: AbstractLinearSolver</code> Default: DefaultLS()</p></li><li><p><code>eigsolver::AbstractEigenSolver</code>: eigen solver, must be <code>&lt;: AbstractEigenSolver</code> Default: DefaultEig()</p></li><li><p><code>linesearch::Bool</code>: Default: false</p></li><li><p><code>α::Any</code>: Default: convert(typeof(tol), 1.0)</p></li><li><p><code>αmin::Any</code>: Default: convert(typeof(tol), 0.001)</p></li></ul><p><strong>Arguments for line search (Armijo)</strong></p><ul><li><code>linesearch = false</code>: use line search algorithm (i.e. Newton with Armijo&#39;s rule)</li><li><code>α = 1.0</code>: initial value of α (damping) parameter for line search algorithm</li><li><code>αmin  = 0.001</code>: minimal value of the damping <code>alpha</code></li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Accessors.jl</code> to drastically simplify the mutation of different fields. See the tutorials for examples.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Newton.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.ContinuationPar" href="#BifurcationKit.ContinuationPar"><code>BifurcationKit.ContinuationPar</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">options = ContinuationPar(dsmin = 1e-4,...)</code></pre><p>Returns a variable containing parameters to affect the <code>continuation</code> algorithm used to solve <code>F(x, p) = 0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dsmin, dsmax</code> are the minimum, maximum arclength allowed value. It controls the density of points in the computed branch of solutions.</li><li><code>ds = 0.01</code> is the initial arclength.</li><li><code>p_min, p_max</code> allowed parameter range for <code>p</code></li><li><code>max_steps = 100</code> maximum number of continuation steps</li><li><code>newton_options::NewtonPar</code>: options for the Newton algorithm</li><li><code>save_to_file = false</code>: save to file. A name is automatically generated or can be defined in <a href="#BifurcationKit.continuation"><code>continuation</code></a>. This requires <code>using JLD2</code>.</li><li><code>save_sol_every_step::Int64 = 0</code> at which continuation steps do we save the current solution</li><li><code>plot_every_step = 10</code> at which continuation steps do we plot the current solution</li></ul><p><strong>Handling eigen elements, their computation is triggered by the argument <code>detect_bifurcation</code> (see below)</strong></p><ul><li><code>nev = 3</code> number of eigenvalues to be computed. It is automatically increased to have at least <code>nev</code> unstable eigenvalues. To be set for proper  bifurcation detection. See <a href="../detectionBifurcation/#Detection-of-bifurcation-points-of-Equilibria">Detection of bifurcation points of Equilibria</a> for more informations.</li><li><code>save_eig_every_step = 1</code> record eigen vectors every specified steps. <strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li><li><code>save_eigenvectors = true</code> <strong>Important</strong> for memory limited resource, <em>e.g.</em> GPU.</li></ul><p><strong>Handling bifurcation detection</strong></p><ul><li><code>tol_stability = 1e-10</code> lower bound on the real part of the eigenvalues to test for stability of equilibria and periodic orbits</li><li><code>detect_fold = true</code> detect Fold bifurcations? It is a useful option although the detection of Fold is cheap. Indeed, it may happen that there is a lot of Fold points and this can saturate the memory in memory limited devices (e.g. on GPU)</li><li><code>detect_bifurcation::Int</code> ∈ {0, 1, 2, 3} If set to 0, nothing is done. If set to 1, the eigen-elements are computed. If set to 2, the bifurcations points are detected during the continuation run, but not located precisely. If set to 3, a bisection algorithm is used to locate the bifurcations points (slower). The possibility to switch off detection is a useful option. Indeed, it may happen that there are a lot of bifurcation points and this can saturate the memory of memory limited devices (e.g. on GPU)</li><li><code>dsmin_bisection = 1e-16</code> dsmin for the bisection algorithm for locating bifurcation points</li><li><code>n_inversion = 2</code> number of sign inversions in bisection algorithm</li><li><code>max_bisection_steps = 15</code> maximum number of bisection steps</li><li><code>tol_bisection_eigenvalue = 1e-16</code> tolerance on real part of eigenvalue to detect bifurcation points in the bisection steps</li></ul><p><strong>Handling <code>ds</code> adaptation (see <a href="#BifurcationKit.continuation"><code>continuation</code></a> for more information)</strong></p><ul><li><code>a  = 0.5</code> aggressiveness factor. It is used to adapt <code>ds</code> in order to have a number of newton iterations per continuation step roughly constant. The higher <code>a</code> is, the larger the step size <code>ds</code> is changed at each continuation step.</li></ul><p><strong>Handling event detection</strong></p><ul><li><code>detect_event::Int</code> ∈ {0, 1, 2} If set to 0, nothing is done. If set to 1, the event locations are sought during the continuation run, but not located precisely. If set to 2, a bisection algorithm is used to locate the event (slower).</li><li><code>tol_param_bisection_event = 1e-16</code> tolerance on parameter to locate event</li></ul><p><strong>Misc</strong></p><ul><li><code>η = 150.</code> parameter to estimate tangent at first point with parameter  p₀ + ds / η</li><li><code>detect_loop</code> [WORK IN PROGRESS] detect loops in the branch and stop the continuation</li></ul><div class="admonition is-success"><header class="admonition-header">Mutating</header><div class="admonition-body"><p>For performance reasons, we decided to use an immutable structure to hold the parameters. One can use the package <code>Accessors.jl</code> to drastically simplify the mutation of different fields. See tutorials for more examples.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/ContParameters.jl#L1-L43">source</a></section></article><h2 id="Results"><a class="docs-heading-anchor" href="#Results">Results</a><a id="Results-1"></a><a class="docs-heading-anchor-permalink" href="#Results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.NonLinearSolution" href="#BifurcationKit.NonLinearSolution"><code>BifurcationKit.NonLinearSolution</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structure which holds the solution from application of Newton-Krylov algorithm to a nonlinear problem.</p><p>For example</p><pre><code class="nohighlight hljs">sol = newton(prob, NewtonPar())</code></pre><p><strong>Fields</strong></p><ul><li><p><code>u::Any</code>: solution</p></li><li><p><code>prob::Any</code>: nonlinear problem, typically a <code>BifurcationProblem</code></p></li><li><p><code>residuals::Any</code>: sequence of residuals</p></li><li><p><code>converged::Bool</code>: has algorithm converged?</p></li><li><p><code>itnewton::Int64</code>: number of newton steps</p></li><li><p><code>itlineartot::Any</code>: total number of linear iterations</p></li></ul><p><strong>methods</strong></p><ul><li><code>converged(sol)</code> return whether the solution has converged.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Newton.jl#L35-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.ContResult" href="#BifurcationKit.ContResult"><code>BifurcationKit.ContResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ContResult{Tkind&lt;:BifurcationKit.AbstractContinuationKind, Tbr, Teigvals, Teigvec, Biftype, Tsol, Tparc, Tprob, Talg} &lt;: BifurcationKit.AbstractResult{Tkind&lt;:BifurcationKit.AbstractContinuationKind, Tprob}</code></pre><p>Structure which holds the results after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a>.</p><p>You can see the propertynames of a result <code>br</code> by using <code>propertynames(br)</code> or <code>propertynames(br.branch)</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>branch::StructArrays.StructArray</code>: holds the low-dimensional information about the branch. More precisely, <code>branch[i+1]</code> contains the following information <code>(record_from_solution(u, param), param, itnewton, itlinear, ds, θ, n_unstable, n_imag, stable, step)</code> for each continuation step <code>i</code>.</p><ul><li><code>itnewton</code> number of Newton iterations</li><li><code>itlinear</code> total number of linear iterations during newton (corrector)</li><li><code>n_unstable</code> number of eigenvalues with positive real part for each continuation step (to detect stationary bifurcation)</li><li><code>n_imag</code> number of eigenvalues with positive real part and non zero imaginary part at current continuation step (useful to detect Hopf bifurcation).</li><li><code>stable</code> stability of the computed solution for each continuation step. Hence, <code>stable</code> should match <code>eig[step]</code> which corresponds to <code>branch[k]</code> for a given <code>k</code>.</li><li><code>step</code> continuation step (here equal <code>i</code>)</li></ul></li><li><p><code>eig::Array{@NamedTuple{eigenvals::Teigvals, eigenvecs::Teigvec, converged::Bool, step::Int64}, 1} where {Teigvals, Teigvec}</code>: A vector with eigen-elements at each continuation step.</p></li><li><p><code>sol::Any</code>: Vector of solutions sampled along the branch. This is set by the argument <code>save_sol_every_step::Int64</code> (default 0) in <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a>.</p></li><li><p><code>contparams::Any</code>: The parameters used for the call to <code>continuation</code> which produced this branch. Must be a <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a></p></li><li><p><code>kind::BifurcationKit.AbstractContinuationKind</code>: Type of solutions computed in this branch. Default: EquilibriumCont()</p></li><li><p><code>prob::Any</code>: Bifurcation problem used to compute the branch, useful for branch switching. For example, when computing periodic orbits, the functional <code>PeriodicOrbitTrapProblem</code>, <code>ShootingProblem</code>... will be saved here. Default: nothing</p></li><li><p><code>specialpoint::Vector</code>: A vector holding the list of detected bifurcation points. See <a href="#BifurcationKit.SpecialPoint"><code>SpecialPoint</code></a> for a list of special points.</p></li><li><p><code>alg::Any</code>: Continuation algorithm used for the computation of the branch</p></li></ul><p><strong>Associated methods</strong></p><ul><li><code>length(br)</code> number of the continuation steps</li><li><code>show(br)</code> display information about the branch</li><li><code>propertynames(br)</code> give the propertynames of a result</li><li><code>eigenvals(br, ind)</code> returns the eigenvalues for the ind-th continuation step</li><li><code>eigenvec(br, ind, indev)</code> returns the indev-th eigenvector for the ind-th continuation step</li><li><code>get_normal_form(br, ind)</code> compute the normal form of the ind-th points in <code>br.specialpoint</code></li><li><code>getlens(br)</code> return the parameter axis used for the branch</li><li><code>getlenses(br)</code> return the parameter two axis used for the branch when 2 parameters continuation is used (Fold, Hopf, NS, PD)</li><li><code>get_solx(br, k)</code> returns the k-th solution on the branch</li><li><code>get_solp(br, k)</code> returns the parameter  value associated with k-th solution on the branch</li><li><code>getparams(br)</code> Parameters passed to continuation and used in the equation <code>F(x, par) = 0</code>.</li><li><code>getparams(br, ind)</code> Parameters passed to continuation and used in the equation <code>F(x, par) = 0</code> for the ind-th continuation step.</li><li><code>setparam(br, p0)</code> set the parameter value <code>p0</code> according to <code>::Lens</code> for the parameters of the problem <code>br.prob</code></li><li><code>getlens(br)</code> get the lens used for the computation of the branch</li><li><code>eigenvals(br, ind)</code> give the eigenvalues at continuation step <code>ind</code></li><li><code>eigenvalsfrombif(br, ind)</code> give the eigenvalues at bifurcation point index <code>ind</code></li><li><code>type(br, ind)</code> returns the type of the ind-th bifurcation point</li><li><code>br[k+1]</code> gives information about the k-th step. A typical run yields the following</li></ul><pre><code class="nohighlight hljs">julia&gt; br[1]
(x = 0.0, param = 0.1, itnewton = 0, itlinear = 0, ds = -0.01, θ = 0.5, n_unstable = 2, n_imag = 2, stable = false, step = 0, eigenvals = ComplexF64[0.1 - 1.0im, 0.1 + 1.0im], eigenvecs = ComplexF64[0.7071067811865475 - 0.0im 0.7071067811865475 + 0.0im; 0.0 + 0.7071067811865475im 0.0 - 0.7071067811865475im])</code></pre><p>which provides the value <code>param</code> of the parameter of the current point, its stability, information on the newton iterations, etc. The fields can be retrieved using <code>propertynames(br.branch)</code>. This information is stored in <code>br.branch</code> which is a <code>StructArray</code>. You can thus extract the vector of parameters along the branch as</p><pre><code class="nohighlight hljs">julia&gt; br.param
10-element Vector{Float64}:
 0.1
 0.08585786437626905
 0.06464466094067263
 0.03282485578727799
-1.2623798512809007e-5
-0.07160718539365075
-0.17899902778635765
-0.3204203840236672
-0.4618417402609767
-0.5</code></pre><ul><li><code>continuation(br, ind)</code> performs automatic branch switching (aBS) from ind-th bifurcation point. Typically branching from equilibrium to equilibrium, or periodic orbit to periodic orbit.</li><li><code>continuation(br, ind, lens2)</code> performs two parameters <code>(getlens(br), lens2)</code> continuation of the  ind-th bifurcation point.</li><li><code>continuation(br, ind, probPO::AbstractPeriodicOrbitProblem)</code> performs aBS from ind-th bifurcation point (which must be a Hopf bifurcation point) to branch of periodic orbits.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Results.jl#L13">source</a></section></article><h2 id="Problems"><a class="docs-heading-anchor" href="#Problems">Problems</a><a id="Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Problems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.BifFunction" href="#BifurcationKit.BifFunction"><code>BifurcationKit.BifFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BifFunction{Tf, TFinp, Tdf, Tdfad, Tj, Tjad, TJinp, Td2f, Td2fc, Td3f, Td3fc, Tsym, Tδ, Tjet} &lt;: BifurcationKit.AbstractBifurcationFunction</code></pre><p>Structure to hold the vector field and its derivatives. It should rarely be called directly. Also, in essence, it is very close to <code>SciMLBase.ODEFunction</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>F::Any</code>: Vector field. Function of type out-of-place <code>result = f(x, p)</code> or inplace <code>f(result, x, p)</code>. For type stability, the types of <code>x</code> and <code>result</code> should match</p></li><li><p><code>F!::Any</code>: Same as F but inplace with signature F!(result, x, p)</p></li><li><p><code>dF::Any</code>: Differential of <code>F</code> with respect to <code>x</code>, signature <code>dF(x,p,dx)</code></p></li><li><p><code>dFad::Any</code>: Adjoint of the Differential of <code>F</code> with respect to <code>x</code>, signature <code>dFad(x,p,dx)</code></p></li><li><p><code>J::Any</code>: Jacobian of <code>F</code> at <code>(x, p)</code>. It can assume three forms.         1. Either <code>J</code> is a function and <code>J(x, p)</code> returns a <code>::AbstractMatrix</code>. In this case, the default arguments of <code>contparams::ContinuationPar</code> will make <code>continuation</code> work.         2. Or <code>J</code> is a function and <code>J(x, p)</code> returns a function taking one argument <code>dx</code> and returning <code>dr</code> of the same type as <code>dx</code>. In our notation, <code>dr = J * dx</code>. In this case, the default parameters of <code>contparams::ContinuationPar</code> will not work and you have to use a Matrix Free linear solver, for example <code>GMRESIterativeSolvers</code>,         3. Or <code>J</code> is a function and <code>J(x, p)</code> returns a variable <code>j</code> which can assume any type. Then, you must implement a linear solver <code>ls</code> as a composite type, subtype of <code>AbstractLinearSolver</code> which is called like <code>ls(j, rhs)</code> and which returns the solution of the jacobian linear system. See for example <code>examples/SH2d-fronts-cuda.jl</code>. This linear solver is passed to <code>NewtonPar(linsolver = ls)</code> which itself passed to <code>ContinuationPar</code>. Similarly, you have to implement an eigensolver <code>eig</code> as a composite type, subtype of <code>AbstractEigenSolver</code>.</p></li><li><p><code>Jᵗ::Any</code>: jacobian adjoint, it should be implemented in an efficient manner. For matrix-free methods, <code>transpose</code> is not readily available and the user must provide a dedicated method. In the case of sparse based jacobian, <code>Jᵗ</code> should not be passed as it is computed internally more efficiently, i.e. it avoids recomputing the jacobian as it would be if you pass <code>Jᵗ = (x, p) -&gt; transpose(dF(x, p))</code>.</p></li><li><p><code>J!::Any</code>: Inplace jacobian</p></li><li><p><code>d2F::Any</code>: Second Differential of <code>F</code> with respect to <code>x</code>, signature <code>d2F(x,p,dx1,dx2)</code></p></li><li><p><code>d3F::Any</code>: Third Differential of <code>F</code> with respect to <code>x</code>, signature <code>d3F(x,p,dx1,dx2,dx3)</code></p></li><li><p><code>d2Fc::Any</code>: [internal] Second Differential of <code>F</code> with respect to <code>x</code> which accept complex vectors dxi</p></li><li><p><code>d3Fc::Any</code>: [internal] Third Differential of <code>F</code> with respect to <code>x</code> which accept complex vectors dxi</p></li><li><p><code>isSymmetric::Any</code>: Whether the jacobian is auto-adjoint.</p></li><li><p><code>δ::Any</code>: used internally to compute derivatives (with finite differences), for example for normal form computation and codim 2 continuation.</p></li><li><p><code>inplace::Bool</code>: optionally sets whether the function is inplace or not. You can use <code>in_bisection(state)</code> to inquire whether the current state is in bisection mode.</p></li><li><p><code>jet::Any</code>: jet of the vector field</p></li></ul><p><strong>Methods</strong></p><ul><li><code>residual(pb::BifFunction, x, p)</code> calls <code>pb.F(x,p)</code></li><li><code>jacobian(pb::BifFunction, x, p)</code> calls <code>pb.J(x, p)</code></li><li><code>dF(pb::BifFunction, x, p, dx)</code> calls <code>pb.dF(x,p,dx)</code></li><li><code>R21(pb::BifFunction, x, p, dx1, dx2, dp1)</code> calls <code>pb.jet.R21(x, p, dx1, dx2, dp1)</code>. Same for the other jet functions.</li><li>etc</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Problems.jl#L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.BifurcationProblem" href="#BifurcationKit.BifurcationProblem"><code>BifurcationKit.BifurcationProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BifurcationProblem{Tvf, Tu, Tp, Tl&lt;:Union{typeof(identity), IndexLens, PropertyLens, ComposedFunction}, Tplot, Trec, Tgets} &lt;: BifurcationKit.AbstractAllJetBifProblem</code></pre><p>Structure to hold the bifurcation problem.</p><p><strong>Fields</strong></p><ul><li><p><code>VF::Any</code>: Vector field, typically a <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a></p></li><li><p><code>u0::Any</code>: Initial guess</p></li><li><p><code>params::Any</code>: parameters</p></li><li><p><code>lens::Union{typeof(identity), IndexLens, PropertyLens, ComposedFunction}</code>: Typically a <code>Accessors.PropertyLens</code>. It specifies which parameter axis among <code>params</code> is used for continuation. For example, if <code>par = (α = 1.0, β = 1)</code>, we can perform continuation w.r.t. <code>α</code> by using <code>lens = (@optic _.α)</code>. If you have an array <code>par = [ 1.0, 2.0]</code> and want to perform continuation w.r.t. the first variable, you can use <code>lens = (@optic _[1])</code>. For more information, we refer to <code>Accessors.jl</code>.</p></li><li><p><code>plotSolution::Any</code>: user function to plot solutions during continuation. Signature: <code>plot_solution(x, p; kwargs...)</code> for Plot.jl and <code>plot_solution(ax, x, p; ax1 = nothing, kwargs...)</code> for the Makie package(s).</p></li><li><p><code>recordFromSolution::Any</code>: <code>record_from_solution = (x, p; k...) -&gt; norm(x)</code> function used record a few indicators about the solution. It could be <code>norm</code> or <code>(x, p; k...) -&gt; x[1]</code>. This is also useful when saving several huge vectors is not possible for memory reasons (for example on GPU). This function can return pretty much everything but you should keep it small. For example, you can do <code>(x, p; k...) -&gt; (x1 = x[1], x2 = x[2], nrm = norm(x))</code> or simply <code>(x, p; k...) -&gt; (sum(x), 1)</code>. This will be stored in <code>contres.branch</code> where <code>contres::ContResult</code> is the continuation curve of the bifurcation problem. Finally, the first component is used for plotting in the continuation curve.</p></li><li><p><code>save_solution::Any</code>: function to save the full solution on the branch. Some problem are mutable (like periodic orbit functional with adaptive mesh) and this function allows to save the state of the problem along with the solution itself. Signature <code>save_solution(x, p)</code></p></li></ul><p><strong>Methods</strong></p><ul><li><code>re_make(pb; kwargs...)</code> modify a bifurcation problem</li><li><code>getu0(pb)</code> calls <code>pb.u0</code></li><li><code>getparams(pb)</code> calls <code>pb.params</code></li><li><code>getlens(pb)</code> calls <code>pb.lens</code></li><li><code>getparam(pb)</code> calls <code>get(pb.params, pb.lens)</code></li><li><code>setparam(pb, p0)</code> calls <code>set(pb.params, pb.lens, p0)</code></li><li><code>record_from_solution(pb)</code> calls <code>pb.recordFromSolution</code></li><li><code>plot_solution(pb)</code> calls <code>pb.plotSolution</code></li><li><code>is_symmetric(pb)</code> calls <code>is_symmetric(pb.prob)</code></li></ul><p><strong>Constructors</strong></p><ul><li><code>BifurcationProblem(F, u0, params, lens)</code> all derivatives are computed using ForwardDiff.</li><li><code>BifurcationProblem(F, u0, params, lens; J, Jᵗ, d2F, d3F, kwargs...)</code> and <code>kwargs</code> are the fields above. You can pass your own jacobian with <code>J</code> (see <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a> for description of the jacobian function) and jacobian adjoint with <code>Jᵗ</code>. For example, this can be used to provide finite differences based jacobian using <code>BifurcationKit.finite_differences</code>. You can also pass<ul><li><code>record_from_solution</code> see above</li><li><code>plot_solution</code> see above</li><li><code>issymmetric[=false]</code> whether the jacobian is symmetric, this remove the need of providing an adjoint</li><li><code>d2F</code> second Differential of <code>F</code> with respect to <code>x</code>, signature <code>d2F(x,p,dx1,dx2)</code></li><li><code>d3F</code> third Differential of <code>F</code> with respect to <code>x</code>, signature <code>d3F(x,p,dx1,dx2,dx3)</code></li><li><code>save_solution</code> specify a particular way to record solution which are written in <code>br.sol</code>. This can be useful in very particular situations and we recommend using <code>record_from_solution</code> instead. For example, it is used internally to record the mesh in the collocation method because this mesh can be modified.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Problems.jl#L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DeflationOperator" href="#BifurcationKit.DeflationOperator"><code>BifurcationKit.DeflationOperator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DeflationOperator{Tp&lt;:Real, Tdot, T&lt;:Real, vectype} &lt;: BifurcationKit.AbstractDeflationFactor</code></pre><p>Structure for defining a custom distance.</p><p>This operator allows to handle the following situation. Assume you want to solve <code>F(x)=0</code> with a Newton algorithm but you want to avoid the process to return some already known solutions <span>$roots_i$</span>. The deflation operator penalizes these roots. You can create a <code>DeflationOperator</code> to define a scalar function <code>M(u)</code> used to find, with Newton iterations, the zeros of the following function <span>$F(u) \cdot Π_i(\|u - root_i\|^{-2p} + \alpha) := F(u) \cdot M(u)$</span> where <span>$\|u\|^2 = dot(u, u)$</span>. The fields of the struct <code>DeflationOperator</code> are as follows:</p><ul><li><p><code>power::Real</code>: power <code>p</code>. You can use an <code>Int</code> for example</p></li><li><p><code>dot::Any</code>: function, this function has to be bilinear and symmetric for the linear solver to work well</p></li><li><p><code>α::Real</code>: shift</p></li><li><p><code>roots::Vector</code>: roots</p></li><li><p><code>tmp::Any</code></p></li><li><p><code>autodiff::Bool</code></p></li><li><p><code>δ::Real</code></p></li></ul><p>Given <code>defOp::DeflationOperator</code>, one can access its roots via <code>defOp[n]</code> as a shortcut for <code>defOp.roots[n]</code>. Note that you can also use <code>defOp[end]</code>.</p><p>Also, one can add (resp. remove) a new root by using <code>push!(defOp, newroot)</code> (resp. <code>pop!(defOp)</code>). Finally <code>length(defOp)</code> is a shortcut for <code>length(defOp.roots)</code></p><p><strong>Constructors</strong></p><ul><li><code>DeflationOperator(p::Real, α::Real, roots::Vector{vectype}; autodiff = false)</code></li><li><code>DeflationOperator(p::Real, dt, α::Real, roots::Vector{vectype}; autodiff = false)</code></li><li><code>DeflationOperator(p::Real, α::Real, roots::Vector{vectype}, v::vectype; autodiff = false)</code></li></ul><p>The option <code>autodiff</code> triggers the use of automatic differentiation for the computation of the gradient of the scalar function <code>M</code>. This works only on <code>AbstractVector</code> for now.</p><p><strong>Custom distance</strong></p><p>You are asked to pass a scalar product like <code>dot</code> to build a <code>DeflationOperator</code>. However, in some cases, you may want to pass a custom distance <code>dist(u, v)</code>. You can do this using</p><pre><code class="nohighlight hljs">`DeflationOperator(p, CustomDist(dist), α, roots)`</code></pre><p>Note that passing <code>CustomDist(dist, true)</code> will trigger the use of automatic differentiation for the gradient of <code>M</code>.</p><p><strong>Linear solvers</strong></p><p>When used with newton, you have access to the following linear solvers</p><ul><li>custom solver <code>DeflatedProblemCustomLS()</code> which requires solving two linear systems <code>J⋅x = rhs</code>.</li><li>For other linear solvers <code>&lt;: AbstractLinearSolver</code>, a matrix free method is used for the deflated functional.</li><li>if passed <code>Val(:autodiff)</code>, then <code>ForwardDiff.jl</code> is used to compute the jacobian Matrix of the deflated problem</li><li>if passed <code>Val(:fullIterative)</code>, then a full matrix free method is used for the deflated problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/DeflationOperator.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DeflatedProblem" href="#BifurcationKit.DeflatedProblem"><code>BifurcationKit.DeflatedProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pb = DeflatedProblem(prob, M::DeflationOperator, jactype)</code></pre><p>Create a <code>DeflatedProblem</code>.</p><p>This creates a deflated functional (problem) <span>$M(u) \cdot F(u) = 0$</span> where <code>M</code> is a <code>DeflationOperator</code> which encodes the penalization term. <code>prob</code> is an <code>AbstractBifurcationProblem</code> which encodes the functional. It is not meant not be used directly albeit by advanced users.</p><p><strong>Arguments</strong></p><ul><li><code>jactype</code> select the jacobian for the newton solve. Can be <code>Val(:autodiff)</code>, <code>Val(:fullIterative)</code>, <code>Val(:Custom)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/DeflationOperator.jl#L141-L150">source</a></section></article><h3 id="Periodic-orbits"><a class="docs-heading-anchor" href="#Periodic-orbits">Periodic orbits</a><a id="Periodic-orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-orbits" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.PeriodicOrbitTrapProblem" href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>BifurcationKit.PeriodicOrbitTrapProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This composite type implements Finite Differences based on a Trapezoidal rule (Order 2 in time) to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitTrapeze/">here</a>.</p><p><strong>Fields</strong></p><ul><li><code>prob</code> a bifurcation problem</li><li><code>M::Int</code> number of time slices</li><li><code>ϕ</code> used to set a section for the phase constraint equation, of size N*M</li><li><code>xπ</code> used in the section for the phase constraint equation, of size N*M</li><li><code>linsolver: = DefaultLS()</code> linear solver for each time slice, i.e. to solve <code>J⋅sol = rhs</code>. This is only needed for the computation of the Floquet multipliers in a full matrix-free setting.</li><li><code>ongpu::Bool</code> whether the computation takes place on the gpu (Experimental)</li><li><code>massmatrix</code> a mass matrix. You can pass for example a sparse matrix. Default: identity matrix.</li><li><code>update_section_every_step</code> updates the section every <code>update_section_every_step</code> step during continuation</li><li><code>jacobian::Symbol</code> symbol which describes the type of jacobian used in Newton iterations (see below).</li></ul><p>The scheme is as follows. We first consider a partition of <span>$[0,1]$</span> given by <span>$0&lt;s_0&lt;\cdots&lt;s_m=1$</span> and one looks for <code>T = x[end]</code> such that</p><p><span>$M_a\cdot\left(x_{i} - x_{i-1}\right) - \frac{T\cdot h_i}{2} \left(F(x_{i}) + F(x_{i-1})\right) = 0,\ i=1,\cdots,m-1$</span></p><p>with <span>$u_{0} := u_{m-1}$</span> and the periodicity condition <span>$u_{m} - u_{1} = 0$</span> and</p><p>where <span>$h_1 = s_i-s_{i-1}$</span>. <span>$M_a$</span> is a mass matrix. Finally, the phase of the periodic orbit is constrained by using a section (but you could use your own)</p><p><span>$\sum_i\langle x_{i} - x_{\pi,i}, \phi_{i}\rangle=0.$</span></p><p><strong>Constructors</strong></p><p>The structure can be created by calling <code>PeriodicOrbitTrapProblem(;kwargs...)</code>. For example, you can declare such a problem without vector field by doing</p><pre><code class="nohighlight hljs">PeriodicOrbitTrapProblem(M = 100)</code></pre><p><strong>Orbit guess</strong></p><p>You will see below that you can evaluate the residual of the functional (and other things) by calling <code>pb(orbitguess, p)</code> on an orbit guess <code>orbitguess</code>. Note that <code>orbitguess</code> must be a vector of size M * N + 1 where N is the number of unknowns in the state space and <code>orbitguess[M*N+1]</code> is an estimate of the period <span>$T$</span> of the limit cycle. More precisely, using the above notations, <code>orbitguess</code> must be <span>$orbitguess = [x_{1},x_{2},\cdots,x_{M}, T]$</span>.</p><p>Note that you can generate this guess from a function solution using <code>generate_solution</code> or <code>generate_ci_problem</code>.</p><p><strong>Functional</strong></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>pb(orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, p, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb(Val(:JacFullSparse), orbitguess, p)</code> return the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code> without the constraints. It is called <code>A_γ</code> in the docs.</li><li><code>pb(Val(:JacFullSparseInplace), J, orbitguess, p)</code>. Same as <code>pb(Val(:JacFullSparse), orbitguess, p)</code> but overwrites <code>J</code> inplace. Note that the sparsity pattern must be the same independently of the values of the parameters or of <code>orbitguess</code>. In this case, this is significantly faster than <code>pb(Val(:JacFullSparse), orbitguess, p)</code>.</li><li><code>pb(Val(:JacCyclicSparse), orbitguess, p)</code> return the sparse cyclic matrix Jc (see the docs) of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code></li><li><code>pb(Val(:BlockDiagSparse), orbitguess, p)</code> return the diagonal of the sparse matrix of the jacobian <code>dG(orbitguess)</code> at <code>orbitguess</code>. This allows to design Jacobi preconditioner. Use <code>blockdiag</code>.</li></ul><p><strong>Jacobian</strong></p><p>Specify the choice of the jacobian (and linear algorithm), <code>jacobian</code> must belong to <code>[:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.</p><ul><li>For <code>jacobian = :FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>jacobian = :FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>jacobian = :DenseAD</code>, evaluate the jacobian using ForwardDiff</li><li>For <code>jacobian = :BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver.</li><li>For <code>jacobian = :BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:BorderedLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>jacobian = :BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li><li>For <code>jacobian = :FullMatrixFreeAD</code>, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.</li></ul><div class="admonition is-info"><header class="admonition-header">GPU call</header><div class="admonition-body"><p>For these methods to work on the GPU, for example with <code>CuArrays</code> in mode <code>allowscalar(false)</code>, we face the issue that the function <code>_extract_period_fdtrap</code> won&#39;t be well defined because it is a scalar operation. Note that you must pass the option <code>ongpu = true</code> for the functional to be evaluated efficiently on the gpu.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitTrapeze.jl#L35-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.PeriodicOrbitOCollProblem" href="#BifurcationKit.PeriodicOrbitOCollProblem"><code>BifurcationKit.PeriodicOrbitOCollProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pb = PeriodicOrbitOCollProblem(kwargs...)</code></pre><p>This composite type implements an orthogonal collocation (at Gauss points) method of piecewise polynomials to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitCollocation/">here</a>.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code> a bifurcation problem</li><li><code>ϕ::AbstractVector</code> used to set a section for the phase constraint equation</li><li><code>xπ::AbstractVector</code> used in the section for the phase constraint equation</li><li><code>N::Int</code> dimension of the state space</li><li><code>mesh_cache::MeshCollocationCache</code> cache for collocation. See docs of <code>MeshCollocationCache</code></li><li><code>update_section_every_step</code> updates the section every <code>update_section_every_step</code> step during continuation</li><li><code>jacobian = DenseAnalytical()</code> describes the type of jacobian used in Newton iterations. Can only be <code>AutoDiffDense(), DenseAnalytical(), FullSparse(), FullSparseInplace(), DenseAnalyticalInplace()</code>.</li><li><code>meshadapt::Bool = false</code> whether to use mesh adaptation</li><li><code>verbose_mesh_adapt::Bool = true</code> verbose mesh adaptation information</li><li><code>K::Float64 = 500</code> parameter for mesh adaptation, control new mesh step size. More precisely, we set max(hᵢ) / min(hᵢ) ≤ K if hᵢ denotes the time steps.</li><li><code>cache_In = true</code> caches <code>Array(I(n))</code> for computing dense functional jacobian. Should be passed as false for large scale problems.</li></ul><p><strong>Methods</strong></p><p>Here are some useful methods you can apply to <code>pb</code></p><ul><li><code>length(pb)</code> gives the total number of unknowns</li><li><code>size(pb)</code> returns the triplet <code>(N, m, Ntst)</code></li><li><code>getmesh(pb)</code> returns the mesh <code>0 = τ0 &lt; ... &lt; τNtst+1 = 1</code>. This is useful because this mesh is born to vary during automatic mesh adaptation</li><li><code>get_mesh_coll(pb)</code> returns the (static) mesh <code>0 = σ0 &lt; ... &lt; σm+1 = 1</code></li><li><code>get_times(pb)</code> returns the vector of times (length <code>1 + m * Ntst</code>) at the which the collocation is applied.</li><li><code>generate_solution(pb, orbit, period)</code> generate a guess from a function <code>t -&gt; orbit(t)</code> which approximates the periodic orbit.</li><li><code>POSolution(pb, x)</code> return a function interpolating the solution <code>x</code> using a piecewise polynomials function</li></ul><p><strong>Orbit guess</strong></p><p>You can evaluate the residual of the functional (and other things) by calling <code>pb(orbitguess, p)</code> on an orbit guess <code>orbitguess</code>. Note that <code>orbitguess</code> must be of size 1 + N * (1 + m * Ntst) where N is the number of unknowns in the state space and <code>orbitguess[end]</code> is an estimate of the period <span>$T$</span> of the limit cycle.</p><p>Note that you can generate this guess from a function using <code>generate_solution</code> or <code>generate_ci_problem</code>.</p><p><strong>Constructors</strong></p><ul><li><code>PeriodicOrbitOCollProblem(Ntst::Int, m::Int; kwargs)</code> creates an empty functional with <code>Ntst</code> and <code>m</code>.</li></ul><p><strong>Functional</strong></p><p>A functional, hereby called <code>G</code>, encodes this problem. The following methods are available</p><ul><li><code>residual(pb, orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>residual!(pb, out, orbitguess, p)</code> evaluates the functional G on <code>orbitguess</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitCollocation.jl#L149-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.ShootingProblem" href="#BifurcationKit.ShootingProblem"><code>BifurcationKit.ShootingProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pb = ShootingProblem(flow::Flow, ds, section; parallel = false)</code></pre><p>Create a problem to implement the Simple / Parallel Multiple Standard Shooting method to locate periodic orbits. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>ds</code>: vector of time differences for each shooting. Its length is written <code>M</code>. If <code>M == 1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>section</code>: implements a phase condition. The evaluation <code>section(x, T)</code> must return a scalar number where <code>x</code> is a guess for <strong>one point</strong> on the periodic orbit and <code>T</code> is the period of the guess. Also, the method <code>section(x, T, dx, dT)</code> must be available and which returns the differential of <code>section</code>. The type of <code>x</code> depends on what is passed to the newton solver. See <a href="#BifurcationKit.SectionSS"><code>SectionSS</code></a> for a type of section defined as a hyperplane.</li><li><code>parallel</code> whether the shooting is computed in parallel (threading). Available through the use of Flows defined by <code>EnsembleProblem</code> (this is automatically set up for you).</li><li><code>par</code> parameters of the model</li><li><code>lens</code> parameter axis</li><li><code>update_section_every_step</code> updates the section every <code>update_section_every_step</code> step during continuation</li><li><code>jacobian::Symbol</code> symbol which describes the type of jacobian used in Newton iterations (see below).</li></ul><p>A functional, hereby called <code>G</code>, encodes the shooting problem. For example, the following methods are available:</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du)</code> evaluates the jacobian <code>dG(orbitguess)⋅du</code> functional at <code>orbitguess</code> on <code>du</code>.</li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><p>You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size <code>M * N + 1</code> where N is the number of unknowns of the state space and <code>orbitguess[M * N + 1]</code> is an estimate of the period <code>T</code> of the limit cycle. This form of guess is convenient for the use of the linear solvers in <code>IterativeSolvers.jl</code> (for example) which only accept <code>AbstractVector</code>s. Another accepted guess is of the form <code>BorderedArray(guess, T)</code> where <code>guess[i]</code> is the state of the orbit at the <code>i</code>th time slice. This last form allows for non-vector state space which can be convenient for 2d problems for example, use <code>GMRESKrylovKit</code> for the linear solver in this case.</p><p>Note that you can generate this guess from a function solution using <code>generate_solution</code> or <code>generate_ci_problem</code>.</p><p><strong>Jacobian</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Simplified constructors</strong></p><ul><li>The first important constructor is the following which is used for branching to periodic orbits from Hopf bifurcation points:</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(M::Int, prob::Union{ODEProblem, EnsembleProblem}, alg; kwargs...)</code></pre><ul><li>A convenient way to build the functional is to use:</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, centers::AbstractVector; kwargs...)</code></pre><p>where <code>prob</code> is an <code>ODEProblem</code> (resp. <code>EnsembleProblem</code>) which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). <code>centers</code> is list of <code>M</code> points close to the periodic orbit, they will be used to build a constraint for the phase. <code>parallel = false</code> is an option to use Parallel simulations (Threading) to simulate the multiple trajectories in the case of multiple shooting. This is efficient when the trajectories are relatively long to compute. Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. Look at <code>DifferentialEquations.jl</code> for more information. Note that, in this case, the derivative of the flow is computed internally using Finite Differences.</p><ul><li>Another way to create a Shooting problem with more options is the following where in particular, one can provide its own scalar constraint <code>section(x)::Number</code> for the phase:</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="nohighlight hljs">pb = ShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, ds, section; parallel = false, kwargs...)</code></pre><ul><li>The next way is an elaboration of the previous one</li></ul><pre><code class="nohighlight hljs">pb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, M::Int, section; parallel = false, kwargs...)</code></pre><p>or</p><pre><code class="nohighlight hljs">pb = ShootingProblem(prob1::Union{ODEProblem, EnsembleProblem}, alg1, prob2::Union{ODEProblem, EnsembleProblem}, alg2, ds, section; parallel = false, kwargs...)</code></pre><p>where we supply now two <code>ODEProblem</code>s. The first one <code>prob1</code>, is used to define the flow associated to <code>F</code> while the second one is a problem associated to the derivative of the flow. Hence, <code>prob2</code> must implement the following vector field <span>$\tilde F(x,y,p) = (F(x,p), dF(x,p)\cdot y)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/StandardShooting.jl#L1-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.PoincareShootingProblem" href="#BifurcationKit.PoincareShootingProblem"><code>BifurcationKit.PoincareShootingProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>pb = PoincareShootingProblem(flow::Flow, M, sections; δ = 1e-8, interp_points = 50, parallel = false)</code></p><p>This composite type implements the Poincaré Shooting method to locate periodic orbits by relying on Poincaré return maps. More details (maths, notations, linear systems) can be found <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/periodicOrbitShooting/">here</a>. The arguments are as follows</p><ul><li><code>flow::Flow</code>: implements the flow of the Cauchy problem though the structure <a href="#BifurcationKit.Flow"><code>Flow</code></a>.</li><li><code>M</code>: the number of Poincaré sections. If <code>M == 1</code>, then the simple shooting is implemented and the multiple one otherwise.</li><li><code>sections</code>: function or callable struct which implements a Poincaré section condition. The evaluation <code>sections(x)</code> must return a scalar number when <code>M == 1</code>. Otherwise, one must implement a function <code>section(out, x)</code> which populates <code>out</code> with the <code>M</code> sections. See <a href="#BifurcationKit.SectionPS"><code>SectionPS</code></a> for type of section defined as a hyperplane.</li><li><code>δ = 1e-8</code> used to compute the jacobian of the functional by finite differences. If set to <code>0</code>, an analytical expression of the jacobian is used instead.</li><li><code>interp_points = 50</code> number of interpolation point used to define the callback (to compute the hitting of the hyperplane section)</li><li><code>parallel = false</code> whether the shooting are computed in parallel (threading). Only available through the use of Flows defined by <code>EnsembleProblem</code>.</li><li><code>par</code> parameters of the model</li><li><code>lens</code> parameter axis</li><li><code>update_section_every_step</code> updates the section every <code>update_section_every_step</code> step during continuation</li><li><code>jacobian::Symbol</code> symbol which describes the type of jacobian used in Newton iterations (see below).</li></ul><p><strong>Jacobian</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Simplified constructors</strong></p><ul><li><p>The first important constructor is the following which is used for branching to periodic orbits from Hopf bifurcation points   pb = PoincareShootingProblem(M::Int, prob::Union{ODEProblem, EnsembleProblem}, alg; kwargs...)</p></li><li><p>A convenient way is to create a functional is</p></li></ul><p><code>pb = PoincareShootingProblem(prob::ODEProblem, alg, section; kwargs...)</code></p><p>for simple shooting or</p><p><code>pb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, M::Int, section; kwargs...)</code></p><p>for multiple shooting . Here <code>prob</code> is an <code>Union{ODEProblem, EnsembleProblem}</code> which is used to create a flow using the ODE solver <code>alg</code> (for example <code>Tsit5()</code>). Finally, the arguments <code>kwargs</code> are passed to the ODE solver defining the flow. We refer to <code>DifferentialEquations.jl</code> for more information.</p><ul><li>Another convenient call is</li></ul><p><code>pb = PoincareShootingProblem(prob::Union{ODEProblem, EnsembleProblem}, alg, normals::AbstractVector, centers::AbstractVector; δ = 1e-8, kwargs...)</code></p><p>where <code>normals</code> (resp. <code>centers</code>) is a list of normals (resp. centers) which defines a list of hyperplanes <span>$\Sigma_i$</span>. These hyperplanes are used to define partial Poincaré return maps.</p><p><strong>Computing the functionals</strong></p><p>A functional, hereby called <code>G</code> encodes this shooting problem. You can then call <code>pb(orbitguess, par)</code> to apply the functional to a guess. Note that <code>orbitguess::AbstractVector</code> must be of size M * N where N is the number of unknowns in the state space and <code>M</code> is the number of Poincaré maps. Another accepted <code>guess</code> is such that <code>guess[i]</code> is the state of the orbit on the <code>i</code>th section. This last form allows for non-vector state space which can be convenient for 2d problems for example.</p><p>Note that you can generate this guess from a function solution using <code>generate_solution</code>.</p><ul><li><code>pb(orbitguess, par)</code> evaluates the functional G on <code>orbitguess</code></li><li><code>pb(orbitguess, par, du)</code> evaluates the jacobian <code>dG(orbitguess).du</code> functional at <code>orbitguess</code> on <code>du</code></li><li><code>pb</code>(Val(:JacobianMatrixInplace), J, x, par)` compute the jacobian of the functional analytically. This is based on ForwardDiff.jl. Useful mainly for ODEs.</li><li><code>pb(Val(:JacobianMatrix), x, par)</code> same as above but out-of-place.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You can use the function <code>getperiod(pb, sol, par)</code> to get the period of the solution <code>sol</code> for the problem with parameters <code>par</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PoincareShooting.jl#L4-L56">source</a></section></article><h3 id="Waves"><a class="docs-heading-anchor" href="#Waves">Waves</a><a id="Waves-1"></a><a class="docs-heading-anchor-permalink" href="#Waves" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.TWProblem" href="#BifurcationKit.TWProblem"><code>BifurcationKit.TWProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>TWProblem(prob, ∂::Tuple, u₀; DAE = 0, jacobian::Symbol = :AutoDiff)</p><p>This composite type implements a functional for freezing symmetries in order, for example, to compute traveling waves (TW). Note that you can freeze many symmetries, not just one, by passing many Lie generators. When you call <code>pb(x, par)</code>, it computes:</p><pre><code class="nohighlight hljs">                ┌                   ┐
                │ f(x, par) - s⋅∂⋅x │
                │   &lt;x - u₀, ∂⋅u₀&gt;  │
                └                   ┘</code></pre><p><strong>Arguments</strong></p><ul><li><code>prob</code> bifurcation problem with continuous symmetries</li><li><code>∂::Tuple = (T1, T2, ⋯)</code> tuple of Lie generators. In effect, each of these is an (differential) operator which can be specified as a (sparse) matrix or as an operator implementing <code>LinearAlgebra.mul!</code>.</li><li><code>u₀</code> reference solution</li></ul><p><strong>Additional Constructor(s)</strong></p><pre><code class="nohighlight hljs">pb = TWProblem(prob, ∂, u₀; kw...)</code></pre><p>This simplified call handles the case where a single symmetry needs to be frozen.</p><p><strong>Useful function</strong></p><ul><li><code>updatesection!(pb::TWProblem, u0)</code> updates the reference solution of the problem using <code>u0</code>.</li><li><code>nb_constraints(::TWProblem)</code> number of constraints (or Lie generators)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/wave/WaveProblem.jl#L4-L30">source</a></section></article><h2 id="Library-LS"><a class="docs-heading-anchor" href="#Library-LS">Linear solvers</a><a id="Library-LS-1"></a><a class="docs-heading-anchor-permalink" href="#Library-LS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DefaultLS" href="#BifurcationKit.DefaultLS"><code>BifurcationKit.DefaultLS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DefaultLS &lt;: BifurcationKit.AbstractDirectLinearSolver</code></pre><p>This struct is used to provide the backslash operator `<code>. Can be used to solve</code>(a₀ * I + a₁ * J) * x = rhs`.</p><p><strong>Fields</strong></p><ul><li><code>useFactorization::Bool</code>: Whether to catch a factorization for multiple solves. Some operators may not support LU (like ApproxFun.jl) or QR factorization so it is best to let the user decides. Some matrices do not have <code>factorize</code> like <code>StaticArrays.MMatrix</code>. Default: true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearSolver.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DefaultPILS" href="#BifurcationKit.DefaultPILS"><code>BifurcationKit.DefaultPILS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DefaultPILS &lt;: BifurcationKit.AbstractIterativeLinearSolver</code></pre><p>[Mainly for debugging] This solver is used to test Moore-Penrose continuation.  This is defined as an iterative pseudo-inverse linear solver. Used to solve <code>J * x = rhs</code>.</p><p><strong>Fields</strong></p><ul><li><code>useFactorization::Bool</code>: Whether to catch a factorization for multiple solves. Some operators may not support LU (like ApproxFun.jl) or QR factorization so it is best to let the user decides. Some matrices do not have <code>factorize</code> like <code>StaticArrays.MMatrix</code>. Default: true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearSolver.jl#L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.GMRESIterativeSolvers" href="#BifurcationKit.GMRESIterativeSolvers"><code>BifurcationKit.GMRESIterativeSolvers</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct GMRESIterativeSolvers{T, Tl, Tr} &lt;: BifurcationKit.AbstractIterativeLinearSolver</code></pre><p>Linear solver based on <code>gmres</code> from <code>IterativeSolvers.jl</code>. Can be used to solve <code>(a₀ * I + a₁ * J) * x = rhs</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>abstol::Any</code>: Absolute tolerance for solver Default: 0.0</p></li><li><p><code>reltol::Any</code>: Relative tolerance for solver Default: 1.0e-8</p></li><li><p><code>restart::Int64</code>: Number of restarts Default: 200</p></li><li><p><code>maxiter::Int64</code>: Maximum number of iterations Default: 100</p></li><li><p><code>N::Int64</code>: Dimension of the problem Default: 0</p></li><li><p><code>verbose::Bool</code>: Display information during iterations Default: false</p></li><li><p><code>log::Bool</code>: Record information Default: true</p></li><li><p><code>initially_zero::Bool</code>: Start with zero guess Default: true</p></li><li><p><code>Pl::Any</code>: Left preconditioner Default: IterativeSolvers.Identity()</p></li><li><p><code>Pr::Any</code>: Right preconditioner Default: IterativeSolvers.Identity()</p></li><li><p><code>ismutating::Bool</code>: Whether the linear operator is written inplace Default: false</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearSolver.jl#L139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.GMRESKrylovKit" href="#BifurcationKit.GMRESKrylovKit"><code>BifurcationKit.GMRESKrylovKit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct GMRESKrylovKit{T, Tl} &lt;: BifurcationKit.AbstractIterativeLinearSolver</code></pre><p>Create a linear solver based on <code>linsolve</code> from <code>KrylovKit.jl</code>. Can be used to solve <code>(a₀ * I + a₁ * J) * x = rhs</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>dim::Int64</code>: Krylov Dimension Default: KrylovDefaults.krylovdim</p></li><li><p><code>atol::Any</code>: Absolute tolerance for solver Default: KrylovDefaults.tol</p></li><li><p><code>rtol::Any</code>: Relative tolerance for solver Default: KrylovDefaults.tol</p></li><li><p><code>maxiter::Int64</code>: Maximum number of iterations Default: KrylovDefaults.maxiter</p></li><li><p><code>verbose::Int64</code>: Verbosity ∈ {0,1,2} Default: 0</p></li><li><p><code>issymmetric::Bool</code>: If the linear map is symmetric, only meaningful if T&lt;:Real Default: false</p></li><li><p><code>ishermitian::Bool</code>: If the linear map is hermitian Default: false</p></li><li><p><code>isposdef::Bool</code>: If the linear map is positive definite Default: false</p></li><li><p><code>Pl::Any</code>: Left preconditioner Default: nothing</p></li></ul><div class="admonition is-success"><header class="admonition-header">Different linear solvers</header><div class="admonition-body"><p>By tuning the options, you can select CG, GMRES... see <a href="https://jutho.github.io/KrylovKit.jl/stable/man/linear/#KrylovKit.linsolve">here</a></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearSolver.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.KrylovLS" href="#BifurcationKit.KrylovLS"><code>BifurcationKit.KrylovLS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct KrylovLS{F, K, Tl, Tr} &lt;: BifurcationKit.AbstractIterativeLinearSolver</code></pre><p>Create a linear solver based on <a href="https://jso.dev/Krylov.jl">Krylov.jl</a>. Can be used to solve <code>(a₀ * I + a₁ * J) * x = rhs</code>. You have access to <code>cg, cr, gmres, symmlq, cg_lanczos, cg_lanczos_shift_seq</code>...</p><p><strong>Fields</strong></p><ul><li><p><code>KrylovAlg::Any</code>: Can be Krylov.GmresSolver(m, n, memory, S) for example. Default = <code>Krylov.gmres</code></p></li><li><p><code>kwargs::Any</code>: Arguments passed to the linear solver</p></li><li><p><code>Pl::Any</code>: Left preconditioner</p></li><li><p><code>Pr::Any</code>: Right preconditioner</p></li></ul><p><strong>Other methods</strong></p><p>Look at <code>KrylovLSInplace</code> for a method where the Krylov space is kept in memory</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearSolver.jl#L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.KrylovLSInplace" href="#BifurcationKit.KrylovLSInplace"><code>BifurcationKit.KrylovLSInplace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct KrylovLSInplace{F, K, Tl, Tr} &lt;: BifurcationKit.AbstractIterativeLinearSolver</code></pre><p>Create an inplace linear solver based on <a href="https://jso.dev/Krylov.jl">Krylov.jl</a>. Can be used to solve <code>(a₀ * I + a₁ * J) * x = rhs</code>.</p><p>The Krylov space is pre-allocated. This is really great for GPU but also for CPU.</p><p><strong>Fields</strong></p><ul><li><p><code>solver::Any</code>: Can be Krylov.GmresSolver(m, n, memory, S) for example</p></li><li><p><code>kwargs::Any</code>: Arguments passed to the linear solver</p></li><li><p><code>Pl::Any</code>: Left preconditioner</p></li><li><p><code>Pr::Any</code>: Right preconditioner</p></li><li><p><code>is_inplace::Bool</code>: Is the linear mapping inplace</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearSolver.jl#L315">source</a></section></article><h2 id="Library-EIG"><a class="docs-heading-anchor" href="#Library-EIG">Eigen solvers</a><a id="Library-EIG-1"></a><a class="docs-heading-anchor-permalink" href="#Library-EIG" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DefaultEig" href="#BifurcationKit.DefaultEig"><code>BifurcationKit.DefaultEig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DefaultEig{T} &lt;: BifurcationKit.AbstractDirectEigenSolver</code></pre><p>The struct <code>DefaultEig</code> is used to  provide the <code>eigen</code> operator to <code>BifurcationKit</code>.</p><p><strong>Fields</strong></p><ul><li><code>which::Any</code>: How do we sort the computed eigenvalues. Default: real</li></ul><p><strong>Constructors</strong></p><p>Just pass the above fields like <code>DefaultEig(;which=abs)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/EigSolver.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.EigArpack" href="#BifurcationKit.EigArpack"><code>BifurcationKit.EigArpack</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EigArpack{T, Tby, Tw} &lt;: BifurcationKit.AbstractIterativeEigenSolver</code></pre><p>Create an eigen solver based on <a href="https://github.com/JuliaLinearAlgebra/Arpack.jl">Arpack.jl</a>.</p><p><strong>Fields</strong></p><ul><li><p><code>sigma::Any</code>: Shift for Shift-Invert method with `(J - sigma⋅I)</p></li><li><p><code>which::Symbol</code>: Which eigen-element to extract :LR, :LM, ...</p></li><li><p><code>by::Any</code>: Sorting function, default to real</p></li><li><p><code>kwargs::Any</code>: Keyword arguments passed to EigArpack</p></li></ul><p><strong>Constructor</strong></p><p><code>EigArpack(sigma = nothing, which = :LR; kwargs...)</code></p><p>More information is available at <a href="https://github.com/JuliaLinearAlgebra/Arpack.jl">Arpack.jl</a>. You can pass the following parameters <code>tol=0.0, maxiter=300, ritzvec=true, v0=zeros((0,))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/EigSolver.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.EigKrylovKit" href="#BifurcationKit.EigKrylovKit"><code>BifurcationKit.EigKrylovKit</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EigKrylovKit{T, vectype} &lt;: BifurcationKit.AbstractMFEigenSolver</code></pre><p>Create an eigen solver based on <code>KrylovKit.jl</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>dim::Int64</code>: Krylov Dimension Default: KrylovDefaults.krylovdim</p></li><li><p><code>tol::Any</code>: Tolerance Default: 0.0001</p></li><li><p><code>restart::Int64</code>: Number of restarts Default: 200</p></li><li><p><code>maxiter::Int64</code>: Maximum number of iterations Default: KrylovDefaults.maxiter</p></li><li><p><code>verbose::Int64</code>: Verbosity ∈ {0, 1, 2} Default: 0</p></li><li><p><code>which::Symbol</code>: Which eigenvalues are looked for :LR (largest real), :LM, ... Default: :LR</p></li><li><p><code>issymmetric::Bool</code>: If the linear map is symmetric, only meaningful if T&lt;:Real Default: false</p></li><li><p><code>ishermitian::Bool</code>: If the linear map is hermitian Default: false</p></li><li><p><code>x₀::Any</code>: Example of vector to usen for Krylov iterations Default: nothing</p></li></ul><p><strong>Constructors</strong></p><p>Just pass the above fields like <code>EigKrylovKit(;dim=2)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/EigSolver.jl#L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.EigArnoldiMethod" href="#BifurcationKit.EigArnoldiMethod"><code>BifurcationKit.EigArnoldiMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EigArnoldiMethod{T, Tby, Tw, Tkw, vectype} &lt;: BifurcationKit.AbstractIterativeEigenSolver</code></pre><p><strong>Fields</strong></p><ul><li><p><code>sigma::Any</code>: Shift for Shift-Invert method</p></li><li><p><code>which::Any</code>: Which eigen-element to extract LR(), LM(), ...</p></li><li><p><code>by::Any</code>: How do we sort the computed eigenvalues, defaults to real</p></li><li><p><code>kwargs::Any</code>: Key words arguments passed to EigArpack</p></li><li><p><code>x₀::Any</code>: Example of vector used for Krylov iterations</p></li></ul><p>More information is available at <a href="https://github.com/haampie/ArnoldiMethod.jl">ArnoldiMethod.jl</a>. For example, you can pass the parameters <code>tol, mindim, maxdim, restarts</code>.</p><p><strong>Constructor</strong></p><p><code>EigArnoldiMethod(;sigma = nothing, which = ArnoldiMethod.LR(), x₀ = nothing, kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/EigSolver.jl#L176">source</a></section></article><h2 id="Library-BLS"><a class="docs-heading-anchor" href="#Library-BLS">Bordered linear solvers</a><a id="Library-BLS-1"></a><a class="docs-heading-anchor-permalink" href="#Library-BLS" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.MatrixBLS" href="#BifurcationKit.MatrixBLS"><code>BifurcationKit.MatrixBLS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MatrixBLS{S&lt;:Union{Nothing, BifurcationKit.AbstractLinearSolver}} &lt;: BifurcationKit.AbstractBorderedLinearSolver</code></pre><p>This struct is used to  provide the bordered linear solver based on inverting the full matrix.</p><ul><li><code>solver::Union{Nothing, BifurcationKit.AbstractLinearSolver}</code>: Linear solver used to invert the full matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearBorderSolver.jl#L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.BorderingBLS" href="#BifurcationKit.BorderingBLS"><code>BifurcationKit.BorderingBLS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct BorderingBLS{S&lt;:Union{Nothing, BifurcationKit.AbstractLinearSolver}, Ttol} &lt;: BifurcationKit.AbstractBorderedLinearSolver</code></pre><p>This struct is used to provide the bordered linear solver based on the Bordering Method. Using the options, you can trigger a sequence of Bordering reductions to meet a precision.</p><p><strong>Reference</strong></p><p>This is the solver BEC + k in Govaerts, W. “Stable Solvers and Block Elimination for Bordered Systems.” SIAM Journal on Matrix Analysis and Applications 12, no. 3 (July 1, 1991): 469–83. https://doi.org/10.1137/0612034.</p><ul><li><p><code>solver::Union{Nothing, BifurcationKit.AbstractLinearSolver}</code>: Linear solver for the Bordering method. Default: nothing</p></li><li><p><code>tol::Any</code>: Tolerance for checking precision Default: 1.0e-12</p></li><li><p><code>check_precision::Bool</code>: Check precision of the linear solve? Default: true</p></li><li><p><code>k::Int64</code>: Number of recursions to achieve tolerance Default: 1</p></li></ul><p><strong>Constructors</strong></p><ul><li>there is a  simple constructor <code>BorderingBLS(ls)</code> where <code>ls</code> is a linear solver, for example <code>ls = DefaultLS()</code></li><li>you can use keyword argument to create such solver, for example <code>BorderingBLS(solver = DefaultLS(), tol = 1e-4)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearBorderSolver.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.MatrixFreeBLS" href="#BifurcationKit.MatrixFreeBLS"><code>BifurcationKit.MatrixFreeBLS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MatrixFreeBLS{S&lt;:Union{Nothing, BifurcationKit.AbstractLinearSolver}} &lt;: BifurcationKit.AbstractBorderedLinearSolver</code></pre><p>This struct is used to  provide the bordered linear solver based a matrix free operator for the full system in <code>(x, p)</code>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">MatrixFreeBLS(solver, ::Bool)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>solver::Union{Nothing, BifurcationKit.AbstractLinearSolver}</code>: Linear solver for solving the extended linear system</p></li><li><p><code>use_bordered_array::Bool</code>: What is the structure used to hold <code>(x, p)</code>. If <code>true</code>, this is achieved using <code>BorderedArray</code>. If <code>false</code>, a <code>Vector</code> is used.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearBorderSolver.jl#L365">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>BifurcationKit.MatrixFreeBLSmap</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.LSFromBLS" href="#BifurcationKit.LSFromBLS"><code>BifurcationKit.LSFromBLS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LSFromBLS{Ts} &lt;: BifurcationKit.AbstractLinearSolver</code></pre><p>This structure is used to provide the following linear solver. To solve (1) J⋅x = rhs, one decomposes J using Matrix by blocks and then use a bordering strategy to solve (1).</p><blockquote><p>It is interesting for solving the linear system associated with Collocation / Trapezoid functionals, for example using <code>BorderingBLS(solver = BK.LSFromBLS(), tol = 1e-9, k = 2, check_precision = true)</code></p></blockquote><ul><li><code>solver::Any</code>: Linear solver used to solve the smaller linear systems.</li></ul><div class="admonition is-category-warn"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The solver only works for <code>AbstractMatrix</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/LinearBorderSolver.jl#L429">source</a></section></article><h2 id="Nonlinear-solver"><a class="docs-heading-anchor" href="#Nonlinear-solver">Nonlinear solver</a><a id="Nonlinear-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.solve" href="#BifurcationKit.solve"><code>BifurcationKit.solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(prob::AbstractBifurcationProblem, ::Newton, options::NewtonPar; normN = norm, callback = (;x, fx, J, residual, step, itlinear, options, x0, residuals; kwargs...) -&gt; true, kwargs...)</code></pre><p>This is the Newton-Krylov Solver for <code>F(x, p0) = 0</code> with Jacobian w.r.t. <code>x</code> written <code>J(x, p0)</code> and initial guess <code>x0</code>. It is important to set the linear solver <code>options.linsolver</code> properly depending on your problem. This linear solver is used to solve <span>$J(x, p_0)u = -F(x, p_0)$</span> in the Newton step. You can for example use <code>linsolver = DefaultLS()</code> which is the operator backslash: it works well for Sparse / Dense matrices. See <a href="../linearsolver/#Linear-solvers-(LS)">Linear solvers (LS)</a> for more information.</p><p><strong>Arguments</strong></p><ul><li><code>prob</code> a <code>::AbstractBifurcationProblem</code>, typically a  <a href="#BifurcationKit.BifurcationProblem"><code>BifurcationProblem</code></a> which holds the vector field and its jacobian. We also refer to  <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a> for more details.</li><li><code>options::NewtonPar</code> variable holding the internal parameters used by the <code>newton</code> method</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>normN = norm</code> specifies a norm for the convergence criteria</li><li><code>callback</code> function passed by the user which is called at the end of each iteration. The default one is the following <code>cb_default((x, fx, J, residual, step, itlinear, options, x0, residuals); k...) = true</code>. Can be used to update a preconditioner for example. You can use for example <code>cbMaxNorm</code> to limit the residuals norms. If yo  want to specify your own, the arguments passed to the callback are as follows<ul><li><code>x</code> current solution</li><li><code>fx</code> current residual</li><li><code>J</code> current jacobian</li><li><code>residual</code> current norm of the residual</li><li><code>step</code> current newton step</li><li><code>itlinear</code> number of iterations to solve the linear system</li><li><code>options</code> a copy of the argument <code>options</code> passed to <code>newton</code></li><li><code>residuals</code> the history of residuals</li><li><code>kwargs</code> kwargs arguments, contain your initial guess <code>x0</code></li></ul>They can be used as <code>callback = (state;k...) -&gt; state.residual&lt;1</code> for example.</li><li><code>kwargs</code> arguments passed to the callback. Useful when <code>newton</code> is called from <code>continuation</code></li></ul><p><strong>Output:</strong></p><ul><li><code>solution::NonLinearSolution</code>, we refer to <a href="#BifurcationKit.NonLinearSolution"><code>NonLinearSolution</code></a> for more information.</li></ul><div class="admonition is-warning"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>Make sure that the linear solver (Matrix-Free...) corresponds to your jacobian (Matrix-Free vs. Matrix based).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Newton.jl#L119-L149">source</a></section><section><div><pre><code class="language-julia hljs">solve(prob, defOp, options; ...)
solve(prob, defOp, options, _linsolver; kwargs...)
</code></pre><p>This is the deflated version of the Krylov-Newton Solver for <code>F(x, p0) = 0</code>.</p><p>We refer to the regular <a href="#BifurcationKit.solve"><code>solve</code></a> for more information. It penalises the roots saved in <code>defOp.roots</code>. The other arguments are as for <code>solve</code>. See <a href="#BifurcationKit.DeflationOperator"><code>DeflationOperator</code></a> for more information on <code>defOp</code>.</p><p><strong>Arguments</strong></p><p>Compared to <a href="#BifurcationKit.solve"><code>solve</code></a>, the only different arguments are</p><ul><li><code>defOp::DeflationOperator</code> deflation operator</li><li><code>linsolver</code> linear solver used to invert the Jacobian of the deflated functional.<ul><li>custom solver <code>DeflatedProblemCustomLS()</code> which requires solving two linear systems <code>J⋅x = rhs</code>.</li><li>For other linear solvers <code>&lt;: AbstractLinearSolver</code>, a matrix free method is used for the deflated functional.</li><li>if passed <code>Val(:autodiff)</code>, then <code>ForwardDiff.jl</code> is used to compute the jacobian Matrix of the deflated problem</li><li>if passed <code>Val(:fullIterative)</code>, then a full matrix free method is used for the deflated problem.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/DeflationOperator.jl#L294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.newton" href="#BifurcationKit.newton"><code>BifurcationKit.newton</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>This specific Newton-Krylov method first tries to converge to a solution <code>sol0</code> close the guess <code>x0</code>. It then attempts to converge from the guess <code>x1</code> while avoiding the previous converged solution close to <code>sol0</code>. This is very handy for branch switching. The method is based on a deflated Newton-Krylov solver.</p><p><strong>Arguments</strong></p><p>Compared to <a href="#BifurcationKit.newton"><code>newton</code></a>, the only different arguments are</p><ul><li><code>defOp::DeflationOperator</code> deflation operator</li><li><code>linsolver</code> linear solver used to invert the Jacobian of the deflated functional.<ul><li>custom solver <code>DeflatedProblemCustomLS()</code> which requires solving two linear systems <code>J⋅x = rhs</code>.</li><li>For other linear solvers <code>&lt;: AbstractLinearSolver</code>, a matrix free method is used for the deflated functional.</li><li>if passed <code>Val(:autodiff)</code>, then <code>ForwardDiff.jl</code> is used to compute the jacobian Matrix of the deflated problem</li><li>if passed <code>Val(:fullIterative)</code>, then a full matrix free method is used for the deflated problem.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/DeflationOperator.jl#L346">source</a></section><section><div><pre><code class="language-julia hljs">newton(
    br,
    ind_bif;
    normN,
    options,
    start_with_eigen,
    lens2,
    kwargs...
)
</code></pre><p>This function turns an initial guess for a Fold / Hopf point into a solution to the Fold / Hopf problem based on a Minimally Augmented formulation.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> results returned after a call to <a href="#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>options::NewtonPar</code>, default value <code>br.contparams.newton_options</code></li><li><code>normN = norm</code></li><li><code>options</code> You can pass newton parameters different from the ones stored in <code>br</code> by using this argument <code>options</code>.</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>start_with_eigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements.</li><li><code>kwargs</code> keywords arguments to be passed to the regular Newton-Krylov solver</li></ul><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option <code>bdlinsolver = MatrixBLS()</code></p></div></div><div class="admonition is-success"><header class="admonition-header">start_with_eigen</header><div class="admonition-body"><p>It is recommended that you use the option <code>start_with_eigen=true</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/codim2/codim2.jl#L154">source</a></section><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, options; lens, δ, kwargs...)
</code></pre><p>This is the Newton-Krylov Solver for computing a periodic orbit using the (Standard / Poincaré) Shooting method. Note that the linear solver has to be appropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. These two problems have specific options to be tuned, we refer to their link for more information and to the tutorials.</p><ul><li><code>prob</code> a problem of type <code>&lt;: AbstractShootingProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit. See <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> and See <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> for information regarding the shape of <code>orbitguess</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <a href="#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L193-L201">source</a></section><section><div><pre><code class="language-julia hljs">newton(prob, orbitguess, defOp, options; lens, kwargs...)
</code></pre><p>This is the deflated Newton-Krylov Solver for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>.</p><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul><p><strong>Output:</strong></p><ul><li>solution::NonLinearSolution, see <a href="#BifurcationKit.NonLinearSolution"><code>NonLinearSolution</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L222-L230">source</a></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, options; kwargs...)
</code></pre><p>This is the Krylov-Newton Solver for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments:</strong></p><ul><li><code>prob</code> a problem of type <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a> encoding the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It should be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</li><li><code>par</code> parameters to be passed to the functional</li><li><code>options</code> same as for the regular <code>newton</code> method</li></ul><p>Specify the choice of the jacobian (and linear algorithm), <code>jacobian</code> must belong to <code>[:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.</p><ul><li>For <code>jacobian = :FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>jacobian = :FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>jacobian = :DenseAD</code>, evaluate the jacobian using ForwardDiff</li><li>For <code>jacobian = :BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver.</li><li>For <code>jacobian = :BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:BorderedLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>jacobian = :BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li><li>For <code>jacobian = :FullMatrixFreeAD</code>, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitTrapeze.jl#L878-L889">source</a></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, defOp, options; kwargs...)
</code></pre><p>This function is similar to <code>newton(probPO, orbitguess, options, jacobianPO; kwargs...)</code> except that it uses deflation in order to find periodic orbits different from the ones stored in <code>defOp</code>. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitTrapeze.jl#L895-L899">source</a></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, options; kwargs...)
</code></pre><p>This is the Newton solver for computing a periodic orbit using orthogonal collocation method. Note that the linear solver has to be apropriately set up in <code>options</code>.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.newton"><code>newton</code></a> except that <code>prob</code> is a <a href="#BifurcationKit.PeriodicOrbitOCollProblem"><code>PeriodicOrbitOCollProblem</code></a>.</p><ul><li><code>prob</code> a problem of type <code>&lt;: PeriodicOrbitOCollProblem</code> encoding the shooting functional G.</li><li><code>orbitguess</code> a guess for the periodic orbit.</li><li><code>options</code> same as for the regular <a href="#BifurcationKit.newton"><code>newton</code></a> method.</li></ul><p><strong>Optional argument</strong></p><ul><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>(AutoDiffDense(), )</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>AutoDiffDense()</code>. The jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one using <code>options</code>. The jacobian is formed inplace.</li><li>For <code>DenseAnalytical()</code> Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitCollocation.jl#L952-L956">source</a></section><section><div><pre><code class="language-julia hljs">newton(probPO, orbitguess, defOp, options; kwargs...)
</code></pre><p>This function is similar to <code>newton(probPO, orbitguess, options, jacobianPO; kwargs...)</code> except that it uses deflation in order to find periodic orbits different from the ones stored in <code>defOp</code>. We refer to the mentioned method for a full description of the arguments. The current method can be used in the vicinity of a Hopf bifurcation to prevent the Newton-Krylov algorithm from converging to the equilibrium point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitCollocation.jl#L974-L978">source</a></section></article><h2 id="Library-Continuation"><a class="docs-heading-anchor" href="#Library-Continuation">Continuation</a><a id="Library-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Library-Continuation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DotTheta" href="#BifurcationKit.DotTheta"><code>BifurcationKit.DotTheta</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DotTheta{Tdot, Ta}</code></pre><ul><li><p><code>dot::Any</code>: dot product used in pseudo-arclength constraint</p></li><li><p><code>apply!::Any</code>: Linear operator associated with dot product, i.e. dot(x, y) = &lt;x, Ay&gt;, where &lt;,&gt; is the standard dot product on R^N. You must provide an inplace function which evaluates A. For example <code>x -&gt; rmul!(x, 1/length(x))</code>.</p></li></ul><p>This parametric type allows to define a new dot product from the one saved in <code>dt::dot</code>. More precisely:</p><pre><code class="nohighlight hljs">dt(u1, u2, p1::T, p2::T, theta::T) where {T &lt;: Real}</code></pre><p>computes, the weighted dot product <span>$\langle (u_1,p_1), (u_2,p_2)\rangle_\theta = \theta \Re \langle u_1,u_2\rangle  +(1-\theta)p_1p_2$</span> where <span>$u_i\in\mathbb R^N$</span>. The <span>$\Re$</span> factor is put to ensure a real valued result despite possible complex valued arguments.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This is used in the pseudo-arclength constraint with the dot product <span>$\frac{1}{N} \langle u_1, u_2\rangle,\quad u_i\in\mathbb R^N$</span></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/Palc.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.continuation" href="#BifurcationKit.continuation"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">continuation(
    prob,
    alg,
    contparams;
    linear_algo,
    bothside,
    kwargs...
)
</code></pre><p>Compute the continuation curve associated to the functional <code>F</code> which is stored in the bifurcation problem <code>prob</code>. General information is available in <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/IntroContinuation/">Continuation methods: introduction</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>prob::AbstractBifurcationFunction</code> a <code>::AbstractBifurcationProblem</code>, typically a  <a href="#BifurcationKit.BifurcationProblem"><code>BifurcationProblem</code></a> which holds the vector field and its jacobian. We also refer to  <a href="#BifurcationKit.BifFunction"><code>BifFunction</code></a> for more details.</li><li><code>alg</code> continuation algorithm, for example <code>Natural(), PALC(), Multiple(),...</code>. See <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/Predictors/">algos</a></li><li><code>contparams::ContinuationPar</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a></li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plot = false</code> whether to plot the solution/branch/spectrum while computing the branch</li><li><code>bothside = true</code> compute the branches on the two sides of the initial parameter value <code>p0</code>, merge them and return it.</li><li><code>normC = norm</code> norm used in the nonlinear solves</li><li><code>filename</code> to save the computed branch during continuation. The identifier .jld2 will be appended to this filename. This requires <code>using JLD2</code>.</li><li><code>callback_newton</code> callback for newton iterations. See docs of <a href="#BifurcationKit.newton"><code>newton</code></a>. For example, it can be used to change the preconditioners.</li><li><code>finalise_solution = (z, tau, step, contResult; kwargs...) -&gt; true</code> Function called at the end of each continuation step. Can be used to alter the continuation procedure (stop it by returning <code>false</code>), save personal data, plot... The notations are <code>z = BorderedArray(x, p)</code> where <code>x</code> (resp. <code>p</code>) is the current solution (resp. parameter value), <code>tau::BorderedArray</code> is the tangent at <code>z</code>, <code>step::Int</code> is the index of the current continuation step and <code>contResult</code> is the current branch. For advanced use:<ul><li>the state <code>state::ContState</code> of the continuation iterator is passed in <code>kwargs</code>. This can be used for testing whether this is called from bisection for locating bifurcation points / events: <code>in_bisection(state)</code> for example. This allows to escape some personal code in this case.</li></ul>Note that you can have a better control over the continuation procedure by using an iterator, see <a href="../iterator/#Iterator-Interface">Iterator Interface</a>.<ul><li>the iterator <code>iter::ContIterable</code> of the continuation is passed in <code>kwargs</code>.</li></ul></li><li><code>verbosity::Int = 0</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,1,2,3}</code>. In case <code>contparams.newton_options.verbose = false</code>, the following is valid (otherwise the newton iterations are shown). Each case prints more information than the previous one:<ul><li>case 0: print nothing</li><li>case 1: print basic information about the continuation: used predictor, step size and parameter values</li><li>case 2: print newton iterations number, stability of solution, detected bifurcations / events</li><li>case 3: print information during bisection to locate bifurcations / events</li></ul></li><li><code>linear_algo</code> set the linear solver for the continuation algorithm <code>alg.</code> For example, <code>PALC</code> needs a linear solver for an enlarged problem (size <code>n+1</code> instead of <code>n</code>) and one thus needs to tune the one passed in <code>contparams.newton_options.linsolver</code>. This is a convenient argument to thus change the <code>alg</code> linear solver and is used mostly internally. The proper way is to pass directly to <code>alg</code> the correct linear solver.</li><li><code>kind::AbstractContinuationKind</code> [Internal] flag to describe continuation kind (equilibrium, codim 2, ...). Default = <code>EquilibriumCont()</code></li></ul><p><strong>Output:</strong></p><ul><li><code>contres::ContResult</code> composite type which contains the computed branch. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information.</li></ul><div class="admonition is-success"><header class="admonition-header">Continuing the branch in the opposite direction</header><div class="admonition-body"><p>Just change the sign of <code>ds</code> in <code>ContinuationPar</code>.</p></div></div><div class="admonition is-success"><header class="admonition-header">Debug mode</header><div class="admonition-body"><p>Use debug mode to access more irformation about the progression of the continuation run, like iterative solvers convergence, problem update, ...</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Continuation.jl#L571">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    prob,
    algdc,
    contParams;
    verbosity,
    plot,
    linear_algo,
    dot_palc,
    callback_newton,
    filename,
    normC,
    kwcont...
)
</code></pre><p>This function computes the set of curves of solutions <code>γ(s) = (x(s), p(s))</code> to the equation <code>F(x,p) = 0</code> based on the algorithm of <strong>deflated continuation</strong> as described in Farrell, Patrick E., Casper H. L. Beentjes, and Ásgeir Birkisson. “The Computation of Disconnected Bifurcation Diagrams.” ArXiv:1603.00809 [Math], March 2, 2016. http://arxiv.org/abs/1603.00809.</p><p>Depending on the options in <code>contParams</code>, it can locate the bifurcation points on each branch. Note that you can specify different predictors using <code>alg</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>prob::AbstractBifurcationProblem</code> bifurcation problem</li><li><code>alg::DefCont</code>, deflated continuation algorithm, see <a href="#BifurcationKit.DefCont"><code>DefCont</code></a></li><li><code>contParams</code> parameters for continuation. See <a href="#BifurcationKit.ContinuationPar"><code>ContinuationPar</code></a> for more information about the options</li></ul><p><strong>Optional Arguments:</strong></p><ul><li><code>plot = false</code> whether to plot the solution while computing,</li><li><code>callback_newton</code> callback for newton iterations. see docs for <code>newton</code>. Can be used to change preconditioners or affect the newton iterations. In the deflation part of the algorithm, when seeking for new branches, the callback is passed the keyword argument <code>fromDeflatedNewton = true</code> to tell the user can it is not in the continuation part (regular newton) of the algorithm,</li><li><code>verbosity::Int</code> controls the amount of information printed during the continuation process. Must belong to <code>{0,⋯,5}</code>,</li><li><code>normC = norm</code> norm used in the Newton solves,</li><li><code>dot_palc = (x, y) -&gt; dot(x, y) / length(x)</code>, dot product used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see online docs on <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/PALC/">PALC</a>). This argument can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...),</li></ul><p><strong>Outputs:</strong></p><ul><li><code>contres::DCResult</code> composite type which contains the computed branches. See <a href="#BifurcationKit.ContResult"><code>ContResult</code></a> for more information,</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/DeflatedContinuation.jl#L173">source</a></section><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif, lens2; ...)
continuation(
    br,
    ind_bif,
    lens2,
    options_cont;
    prob,
    start_with_eigen,
    detect_codim2_bifurcation,
    update_minaug_every_step,
    kwargs...
)
</code></pre><p>Codimension 2 continuation of Fold / Hopf points. This function turns an initial guess for a Fold / Hopf point into a curve of Fold / Hopf points based on a Minimally Augmented formulation. The arguments are as follows</p><ul><li><code>br</code> results returned after a call to <a href="#Library-Continuation">continuation</a></li><li><code>ind_bif</code> bifurcation index in <code>br</code></li><li><code>lens2</code> second parameter used for the continuation, the first one is the one used to compute <code>br</code>, e.g. <code>getlens(br)</code></li><li><code>options_cont = br.contparams</code> arguments to be passed to the regular <a href="#Library-Continuation">continuation</a></li></ul><p><strong>Optional arguments:</strong></p><ul><li><code>linsolve_adjoint</code> solver for (J+iω)˟ ⋅sol = rhs or Jᵗ ⋅sol = rhs</li><li><code>bdlinsolver</code> bordered linear solver for the constraint equation</li><li><code>bdlinsolver_adjoint</code> bordered linear solver for the constraint equation with top-left block (J-iω)˟ or Jᵗ. Required in the linear solver for the Minimally Augmented Fold/Hopf functional. This option can be used to pass a dedicated linear solver for example with specific preconditioner.</li><li><code>update_minaug_every_step</code> update vectors <code>a, b</code> in Minimally Formulation every <code>update_minaug_every_step</code> steps</li><li><code>start_with_eigen = false</code> whether to start the Minimally Augmented problem with information from eigen elements</li><li><code>detect_codim2_bifurcation ∈ {0,1,2}</code> whether to detect Bogdanov-Takens, Bautin and Cusp. If equals <code>1</code> non precise detection is used. If equals <code>2</code>, a bisection method is used to locate the bifurcations.</li><li><code>kwargs</code> keywords arguments to be passed to the regular <a href="#Library-Continuation">continuation</a></li></ul><p>where the parameters are as above except that you have to pass the branch <code>br</code> from the result of a call to <code>continuation</code> with detection of bifurcations enabled and <code>index</code> is the index of Hopf point in <code>br</code> you want to refine.</p><div class="admonition is-success"><header class="admonition-header">ODE problems</header><div class="admonition-body"><p>For ODE problems, it is more efficient to use the Matrix based Bordered Linear Solver passing the option <code>bdlinsolver = MatrixBLS()</code></p></div></div><div class="admonition is-success"><header class="admonition-header">start_with_eigen</header><div class="admonition-body"><p>It is recommended that you use the option <code>start_with_eigen = true</code></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/codim2/codim2.jl#L207">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    prob,
    x0,
    par0,
    x1,
    p1,
    alg,
    lens,
    contParams;
    bothside,
    kwargs...
)
</code></pre><p>[Internal] This function is not meant to be called directly.</p><p>This function is the analog of <a href="#BifurcationKit.continuation"><code>continuation</code></a> when the first two points on the branch are passed (instead of a single one). Hence <code>x0</code> is the first point on the branch (with pseudo arc length <code>s=0</code>) with parameter <code>par0</code> and <code>x1</code> is the second point with parameter <code>set(par0, lens, p1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/bifdiagram/BranchSwitching.jl#L1">source</a></section><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif; ...)
continuation(
    br,
    ind_bif,
    options_cont;
    alg,
    δp,
    ampfactor,
    override,
    nev,
    usedeflation,
    verbosedeflation,
    max_iter_deflation,
    perturb,
    plot_solution,
    Teigvec,
    scaleζ,
    tol_fold,
    kwargs_deflated_newton,
    kwargs...
)
</code></pre><p>Automatic branch switching at branch points based on a computation of the normal form. More information is provided in <a href="../intro-abs/#Branch-switching-page">Branch switching</a>. An example of use is provided in <a href="@ref">2d generalized Bratu–Gelfand problem</a>.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br</code> from which you want to branch from</li><li><code>options_cont</code> options for the call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm to be used, default value: <code>br.alg</code></li><li><code>δp</code> used to specify a specific value for the parameter on the bifurcated branch which is otherwise determined by <code>options_cont.ds</code>. This allows to use a step larger than <code>options_cont.dsmax</code>.</li><li><code>ampfactor = 1</code> factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep. Can also be used to select the upper/lower branch in Pitchfork bifurcations. See also override below.</li><li><code>override = false</code>. If <code>override==false</code>, the normal form is computed as well as its predictor and a guess is automatically formed. If <code>override==false</code>, the parameter value <code>p = p₀ + δp</code> and the guess <code>x = x₀ + ampfactor .* e</code> (where <code>e</code> is a vector of the kernel) are used as initial guess. This is useful in case automatic branch switching does not work.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>usedeflation = false</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated</li><li><code>verbosedeflation</code> print deflated newton iterations</li><li><code>max_iter_deflation</code> number of newton steps in deflated newton</li><li><code>perturb = identity</code> which perturbation function to use during deflated newton</li><li><code>Teigvec = _getvectortype(br)</code> type of the eigenvector. Useful when <code>br</code> was loaded from a file and this information was lost</li><li><code>scaleζ = norm</code> pass a norm to normalize vectors during normal form computation</li><li><code>plot_solution</code> change plot solution method in the problem <code>br.prob</code></li><li><code>kwargs</code> optional arguments to be passed to <a href="#BifurcationKit.continuation"><code>continuation</code></a>, the regular <code>continuation</code> one and to <a href="#BifurcationKit.get_normal_form"><code>get_normal_form</code></a>.</li></ul><div class="admonition is-success"><header class="admonition-header">Advanced use</header><div class="admonition-body"><p>In the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at <code>methods(BifurcationKit.multicontinuation)</code> to see how to call these versions. These methods has been tested on GPU with very high memory pressure.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/bifdiagram/BranchSwitching.jl#L46">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    probPO,
    orbitguess,
    alg,
    contParams,
    linear_algo;
    δ,
    eigsolver,
    record_from_solution,
    plot_solution,
    kwargs...
)
</code></pre><p>This is the continuation method for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>probPO</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Optional arguments</strong></p><ul><li><code>eigsolver</code> specify an eigen solver for the computation of the Floquet exponents, defaults to <code>FloquetQaD</code></li><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L273-L281">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    prob,
    orbitguess,
    alg,
    _contParams;
    linear_algo,
    kwargs...
)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a (Standard / Poincaré) Shooting method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is either a <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or a <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Optional argument</strong></p><ul><li><code>linear_algo::AbstractBorderedLinearSolver</code></li><li><code>jacobian</code> Specify the choice of the linear algorithm, which must belong to <code>[AutoDiffMF(), MatrixFree(), AutodiffDense(), AutoDiffDenseAnalytical(), FiniteDifferences(), FiniteDifferencesMF()]</code>. This is used to select a way of inverting the jacobian dG<ul><li>For <code>MatrixFree()</code>, matrix free jacobian, the jacobian is specified by the user in <code>prob</code>. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutoDiffMF()</code>, we use Automatic Differentiation (AD) to compute the (matrix-free) derivative of <code>x -&gt; prob(x, p)</code> using a directional derivative. This is to be used with an iterative solver (e.g. GMRES) to solve the linear system</li><li>For <code>AutodiffDense()</code>. Same as for <code>AutoDiffMF</code> but the jacobian is formed as a dense Matrix. You can use a direct solver or an iterative one.</li><li>For <code>FiniteDifferences()</code>, same as for <code>AutoDiffDense</code> but we use Finite Differences to compute the jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li><li>For <code>AutoDiffDenseAnalytical()</code>. Same as for <code>AutoDiffDense</code> but the jacobian is formed using a mix of AD and analytical formula.</li><li>For <code>FiniteDifferencesMF()</code>, use Finite Differences to compute the matrix-free jacobian of <code>x -&gt; prob(x, p)</code> using the <code>δ = 1e-8</code> which can be passed as an argument.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L328-L336">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    br,
    ind_bif,
    _contParams,
    pbPO;
    prob_vf,
    alg,
    δp,
    ampfactor,
    usedeflation,
    use_normal_form,
    autodiff_nf,
    nev,
    kwargs...
)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points of a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>probPO</code> problem used to specify the way the periodic orbit is computed. It can be <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>, <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>use_normal_form = true</code> compute the normal form to get the predictor. When <code>false</code>, <code>ampfactor</code> and <code>δp</code> are used to make a predictor based on the eigenvector. This can be useful when computing the normal form is not possible for example when higher order derivatives are not available.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>autodiff_nf = true</code> use <code>autodiff</code> in <code>get_normal_form</code>?</li><li>all <code>kwargs</code> from <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plot_solution</code> and <code>finalise_solution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be careful about the options <code>contParams.newton_options.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L353">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    br,
    ind_bif,
    _contParams;
    alg,
    δp,
    ampfactor,
    usedeflation,
    linear_algo,
    detailed,
    prm,
    override,
    kwargs...
)
</code></pre><p>Branch switching at a bifurcation point on a branch of periodic orbits (PO) specified by a <code>br::AbstractBranchResult</code>. The functional used to compute the PO is <code>br.prob</code>. A deflated Newton-Krylov solver can be used to improve the branch switching capabilities.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch of periodic orbits computed with a <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a></li><li><code>ind_bif</code> index of the branch point</li><li><code>_contParams</code> parameters to be used by a regular <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>δp = 0.1</code> used to specify a particular guess for the parameter in the branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor which alters the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>detailed = false</code> whether to fully compute the normal form.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>record_from_solution = (u, p) -&gt; u[end]</code>, record method used in the bifurcation diagram, by default this records the period of the periodic orbit.</li><li><code>linear_algo = BorderingBLS()</code>, same as for <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>kwargs</code> keywords arguments used for a call to the regular <a href="#BifurcationKit.continuation"><code>continuation</code></a> and the ones specific to periodic orbits (POs).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L496">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    prob,
    orbitguess,
    alg,
    _contParams;
    1052,
    record_from_solution,
    linear_algo,
    kwargs...
)
</code></pre><p>This is the continuation routine for computing a periodic orbit using a functional G based on Finite Differences and a Trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><code>prob::PeriodicOrbitTrapProblem</code> encodes the functional G</li><li><code>orbitguess</code> a guess for the periodic orbit where <code>orbitguess[end]</code> is an estimate of the period of the orbit. It could be a vector of size <code>N * M + 1</code> where <code>M</code> is the number of time slices, <code>N</code> is the dimension of the phase space. This must be compatible with the numbers <code>N, M</code> in <code>prob</code>.</li><li><code>alg</code> continuation algorithm</li><li><code>contParams</code> same as for the regular <a href="#BifurcationKit.continuation"><code>continuation</code></a> method</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>linear_algo</code> same as in <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>Specify the choice of the jacobian (and linear algorithm), <code>jacobian</code> must belong to <code>[:FullLU, :FullSparseInplace, :Dense, :DenseAD, :BorderedLU, :BorderedSparseInplace, :FullMatrixFree, :BorderedMatrixFree, :FullMatrixFreeAD]</code>. This is used to select a way of inverting the jacobian <code>dG</code> of the functional G.</p><ul><li>For <code>jacobian = :FullLU</code>, we use the default linear solver based on a sparse matrix representation of <code>dG</code>. This matrix is assembled at each newton iteration. This is the default algorithm.</li><li>For <code>jacobian = :FullSparseInplace</code>, this is the same as for <code>:FullLU</code> but the sparse matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:FullLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :Dense</code>, same as above but the matrix <code>dG</code> is dense. It is also updated inplace. This option is useful to study ODE of small dimension.</li><li>For <code>jacobian = :DenseAD</code>, evaluate the jacobian using ForwardDiff</li><li>For <code>jacobian = :BorderedLU</code>, we take advantage of the bordered shape of the linear solver and use a LU decomposition to invert <code>dG</code> using a bordered linear solver.</li><li>For <code>jacobian = :BorderedSparseInplace</code>, this is the same as for <code>:BorderedLU</code> but the cyclic matrix <code>dG</code> is updated inplace. This method allocates much less. In some cases, this is significantly faster than using <code>:BorderedLU</code>. Note that this method can only be used if the sparsity pattern of the jacobian is always the same.</li><li>For <code>jacobian = :FullMatrixFree</code>, a matrix free linear solver is used for <code>dG</code>: note that a preconditioner is very likely required here because of the cyclic shape of <code>dG</code> which affects negatively the convergence properties of GMRES.</li><li>For <code>jacobian = :BorderedMatrixFree</code>, a matrix free linear solver is used but for <code>Jc</code> only (see docs): it means that <code>options.linsolver</code> is used to invert <code>Jc</code>. These two Matrix-Free options thus expose different part of the jacobian <code>dG</code> in order to use specific preconditioners. For example, an ILU preconditioner on <code>Jc</code> could remove the constraints in <code>dG</code> and lead to poor convergence. Of course, for these last two methods, a preconditioner is likely to be required.</li><li>For <code>jacobian = :FullMatrixFreeAD</code>, the evaluation map of the differential is derived using automatic differentiation. Thus, unlike the previous two cases, the user does not need to pass a Matrix-Free differential.</li></ul><p>Note that by default, the method prints the period of the periodic orbit as function of the parameter. This can be changed by providing your <code>record_from_solution</code> argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitTrapeze.jl#L1028-L1039">source</a></section><section><div><pre><code class="language-julia hljs">continuation(
    coll,
    orbitguess,
    alg,
    _contParams,
    linear_algo;
    δ,
    eigsolver,
    record_from_solution,
    plot_solution,
    kwargs...
)
</code></pre><p>This is the continuation method for computing a periodic orbit using an orthogonal collocation method.</p><p><strong>Arguments</strong></p><p>Similar to <a href="#BifurcationKit.continuation"><code>continuation</code></a> except that <code>prob</code> is a <a href="#BifurcationKit.PeriodicOrbitOCollProblem"><code>PeriodicOrbitOCollProblem</code></a>. By default, it prints the period of the periodic orbit.</p><p><strong>Keywords arguments</strong></p><ul><li><code>eigsolver</code> specify an eigen solver for the computation of the Floquet exponents, defaults to <code>FloquetQaD</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitCollocation.jl#L1018">source</a></section></article><h2 id="Continuation-algorithms"><a class="docs-heading-anchor" href="#Continuation-algorithms">Continuation algorithms</a><a id="Continuation-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-algorithms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.PALC" href="#BifurcationKit.PALC"><code>BifurcationKit.PALC</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PALC{Ttang&lt;:BifurcationKit.AbstractTangentComputation, Tbls&lt;:BifurcationKit.AbstractLinearSolver, T, Tdot} &lt;: BifurcationKit.AbstractContinuationAlgorithm</code></pre><p>Pseudo-arclength continuation algorithm.</p><p>Additional information is available on the <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/PALC/">website</a>.</p><p><strong>Fields</strong></p><ul><li><p><code>tangent::BifurcationKit.AbstractTangentComputation</code>: Tangent predictor, must be a subtype of <code>AbstractTangentComputation</code>. For example <code>Secant()</code> or <code>Bordered()</code>,  Default: Secant()</p></li><li><p><code>θ::Any</code>: <code>θ</code> is a parameter in the arclength constraint. It is very <strong>important</strong> to tune it. It should be tuned for the continuation to work properly especially in the case of large problems where the &lt; x - x<em>0, dx</em>0 &gt; component in the constraint equation might be favoured too much. Also, large thetas favour p as the corresponding term in N involves the term 1-theta. Default: 0.5</p></li><li><p><code>_bothside::Bool</code>: [internal],  Default: false</p></li><li><p><code>bls::BifurcationKit.AbstractLinearSolver</code>: Bordered linear solver used to invert the jacobian of the bordered problem during newton iterations. It is also used to compute the tangent for the predictor <code>Bordered()</code>,  Default: MatrixBLS()</p></li><li><p><code>dotθ::Any</code>: <code>dotθ = DotTheta()</code>, this sets up a dot product <code>(x, y) -&gt; dot(x, y) / length(x)</code> used to define the weighted dot product (resp. norm) <span>$\|(x, p)\|^2_\theta$</span> in the constraint <span>$N(x, p)$</span> (see online docs on <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/PALC/">PALC</a>). This argument can be used to remove the factor <code>1/length(x)</code> for example in problems where the dimension of the state space changes (mesh adaptation, ...) or when a specific (FEM) dot product is provided. Default: DotTheta()</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/Palc.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.Natural" href="#BifurcationKit.Natural"><code>BifurcationKit.Natural</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Natural continuation algorithm. The predictor is the constant predictor and the parameter is incremented by `ContinuationPar().ds` at each continuation step.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/Natural.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.Secant" href="#BifurcationKit.Secant"><code>BifurcationKit.Secant</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Secant Tangent predictor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/Palc.jl#L173-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.Bordered" href="#BifurcationKit.Bordered"><code>BifurcationKit.Bordered</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bordered Tangent predictor</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/Palc.jl#L209-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.Polynomial" href="#BifurcationKit.Polynomial"><code>BifurcationKit.Polynomial</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Polynomial Tangent predictor</code></pre><ul><li><p><code>n::Int64</code>: Order of the polynomial</p></li><li><p><code>k::Int64</code>: Length of the last solutions vector used for the polynomial fit</p></li><li><p><code>A::Matrix{T} where T&lt;:Real</code>: Matrix for the interpolation</p></li><li><p><code>tangent::BifurcationKit.AbstractTangentComputation</code>: Algo for tangent when polynomial predictor is not possible</p></li><li><p><code>solutions::DataStructures.CircularBuffer</code>: Vector of solutions</p></li><li><p><code>parameters::DataStructures.CircularBuffer{T} where T&lt;:Real</code>: Vector of parameters</p></li><li><p><code>arclengths::DataStructures.CircularBuffer{T} where T&lt;:Real</code>: Vector of arclengths</p></li><li><p><code>coeffsSol::Vector</code>: Coefficients for the polynomials for the solution</p></li><li><p><code>coeffsPar::Vector{T} where T&lt;:Real</code>: Coefficients for the polynomials for the parameter</p></li><li><p><code>update::Bool</code>: Update the predictor by adding the last point (x, p)? This can be disabled in order to just use the polynomial prediction. It is useful when the predictor is called mutiple times during bifurcation detection using bisection.</p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="nohighlight hljs">Polynomial(pred, n, k, v0)

Polynomial(n, k, v0)</code></pre><ul><li><code>n</code> order of the polynomial</li><li><code>k</code> length of the last solutions vector used for the polynomial fit</li><li><code>v0</code> example of solution to be stored. It is only used to get the <code>eltype</code> of the tangent.</li></ul><p>Can be used like</p><pre><code class="nohighlight hljs">PALC(tangent = Polynomial(Bordered(), 2, 6, rand(1)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/Palc.jl#L257-L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.Multiple" href="#BifurcationKit.Multiple"><code>BifurcationKit.Multiple</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Multiple Tangent continuation algorithm.</code></pre><p>The predictor is designed [Uecker2014] to avoid spurious branch switching and pass singular points especially in PDE where branch point density can be quite high. It is called <code>pmcont</code> in <code>pde2path</code>.</p><ul><li><p><code>alg::PALC</code>: Tangent predictor used Default: PALC()</p></li><li><p><code>τ::Any</code>: Save the current tangent</p></li><li><p><code>α::Real</code>: Damping in Newton iterations, 0 &lt; α &lt; 1</p></li><li><p><code>nb::Int64</code>: Number of predictors</p></li><li><p><code>currentind::Int64</code>: Index of the largest converged predictor Default: 0</p></li><li><p><code>pmimax::Int64</code>: Index for lookup in residual history Default: 1</p></li><li><p><code>imax::Int64</code>: Maximum index for lookup in residual history Default: 4</p></li><li><p><code>dsfact::Real</code>: Factor to increase ds upon successful step Default: 1.5</p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="nohighlight hljs">Multiple(alg, x0, α, n)

Multiple(pred, x0, α, n)

Multiple(x0, α, n)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/Multiple.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.AutoSwitch" href="#BifurcationKit.AutoSwitch"><code>BifurcationKit.AutoSwitch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct AutoSwitch{Talg, T} &lt;: BifurcationKit.AbstractContinuationAlgorithm</code></pre><p>Continuation algorithm which switches automatically between Natural continuation and PALC depending on the stiffness of the branch being continued.</p><ul><li><p><code>alg::Any</code>: Continuation algorithm to switch to when Natural is discarded. Typically <code>PALC()</code></p></li><li><p><code>tol_param::Any</code>: tolerance for switching to PALC(), default value = 0.5</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/AutoSwitch.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.MoorePenrose" href="#BifurcationKit.MoorePenrose"><code>BifurcationKit.MoorePenrose</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Moore-Penrose predictor / corrector</code></pre><p>Moore-Penrose continuation algorithm.</p><p>Additional information is available on the <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/MooreSpence/">website</a>.</p><p><strong>Constructors</strong></p><p><code>alg = MoorePenrose()</code></p><p><code>alg = MoorePenrose(tangent = PALC())</code></p><p><strong>Fields</strong></p><ul><li><p><code>tangent::Any</code>: Tangent predictor, for example <code>PALC()</code></p></li><li><p><code>method::MoorePenroseLS</code>: Moore Penrose linear solver. Can be BifurcationKit.direct, BifurcationKit.pInv or BifurcationKit.iterative</p></li><li><p><code>ls::BifurcationKit.AbstractLinearSolver</code>: (Bordered) linear solver</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/continuation/MoorePenrose.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DefCont" href="#BifurcationKit.DefCont"><code>BifurcationKit.DefCont</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DefCont{Tdo, Talg, Tps, Tas, Tud, Tk} &lt;: BifurcationKit.AbstractContinuationAlgorithm</code></pre><p>Structure which holds the parameters specific to Deflated continuation.</p><p><strong>Fields</strong></p><ul><li><p><code>deflation_operator::Any</code>: Deflation operator, <code>::DeflationOperator</code> Default: nothing</p></li><li><p><code>alg::Any</code>: Used as a predictor, <code>::AbstractContinuationAlgorithm</code>. For example <code>PALC()</code>, <code>Natural()</code>,... Default: PALC()</p></li><li><p><code>max_branches::Int64</code>: maximum number of (active) branches to be computed Default: 100</p></li><li><p><code>seek_every_step::Int64</code>: whether to seek new (deflated) solution at every step Default: 1</p></li><li><p><code>max_iter_defop::Int64</code>: maximum number of deflated Newton iterations Default: 5</p></li><li><p><code>perturb_solution::Any</code>: perturb function Default: _perturbSolution</p></li><li><p><code>accept_solution::Any</code>: accept (solution) function Default: _acceptSolution</p></li><li><p><code>update_deflation_op::Any</code>: function to update the deflation operator, ie pushing new solutions Default: _updateDeflationOp</p></li><li><p><code>jacobian::Any</code>: jacobian for deflated newton. Can be <code>DeflatedProblemCustomLS()</code>, or <code>Val(:autodiff)</code>, <code>Val(:fullIterative)</code> Default: DeflatedProblemCustomLS()</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/DeflatedContinuation.jl#L5">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AsymptoticNumericalMethod.ANM</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Events"><a class="docs-heading-anchor" href="#Events">Events</a><a id="Events-1"></a><a class="docs-heading-anchor-permalink" href="#Events" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.DiscreteEvent" href="#BifurcationKit.DiscreteEvent"><code>BifurcationKit.DiscreteEvent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DiscreteEvent{Tcb, Tl, Tf, Td} &lt;: BifurcationKit.AbstractDiscreteEvent</code></pre><p>Structure to pass a DiscreteEvent function to the continuation algorithm. A discrete call back returns a discrete value and we seek when it changes.</p><ul><li><p><code>nb::Int64</code>: number of events, ie the length of the result returned by the callback function</p></li><li><p><code>condition::Any</code>: = <code>(iter, state) -&gt; NTuple{nb, Int64}</code> callback function which at each continuation state, returns a tuple. For example, to detect a value change.</p></li><li><p><code>computeEigenElements::Bool</code>: whether the event requires to compute eigen elements</p></li><li><p><code>labels::Any</code>: Labels used to display information. For example <code>labels[1]</code> is used to qualify an event occurring in the first component. You can use <code>labels = (&quot;hopf&quot;,)</code> or <code>labels = (&quot;hopf&quot;, &quot;fold&quot;)</code>. You must have <code>labels::Union{Nothing, NTuple{N, String}}</code>.</p></li><li><p><code>finaliser::Any</code>: Finaliser function</p></li><li><p><code>data::Any</code>: Place to store some personal data</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/events/Event.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.ContinuousEvent" href="#BifurcationKit.ContinuousEvent"><code>BifurcationKit.ContinuousEvent</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ContinuousEvent{Tcb, Tl, T, Tf, Td} &lt;: BifurcationKit.AbstractContinuousEvent</code></pre><p>Structure to pass a ContinuousEvent function to the continuation algorithm. A continuous call back returns a <strong>tuple/scalar</strong> value and we seek its zeros.</p><ul><li><p><code>nb::Int64</code>: number of events, ie the length of the result returned by the callback function</p></li><li><p><code>condition::Any</code>: , <code>(iter, state) -&gt; NTuple{nb, T}</code> callback function which, at each continuation state, returns a tuple. For example, to detect crossing at 1.0 and at -2.0, you can pass <code>(iter, state) -&gt; (getp(state)+2, getx(state)[1]-1)),</code>. Note that the type <code>T</code> should match the one of the parameter specified by the <code>::Lens</code> in <code>continuation</code>.</p></li><li><p><code>computeEigenElements::Bool</code>: whether the event requires to compute eigen elements</p></li><li><p><code>labels::Any</code>: Labels used to display information. For example <code>labels[1]</code> is used to qualify an event of the type <code>(0, 1.3213, 3.434)</code>. You can use <code>labels = (&quot;hopf&quot;,)</code> or <code>labels = (&quot;hopf&quot;, &quot;fold&quot;)</code>. You must have <code>labels::Union{Nothing, NTuple{N, String}}</code>.</p></li><li><p><code>tol::Any</code>: Tolerance on event value to declare it as true event.</p></li><li><p><code>finaliser::Any</code>: Finaliser function</p></li><li><p><code>data::Any</code>: Place to store some personal data</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/events/Event.jl#L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.SetOfEvents" href="#BifurcationKit.SetOfEvents"><code>BifurcationKit.SetOfEvents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SetOfEvents{Tc&lt;:Tuple, Td&lt;:Tuple} &lt;: BifurcationKit.AbstractEvent</code></pre><p>Multiple events can be chained together to form a <code>SetOfEvents</code>. A <code>SetOfEvents</code> is constructed by passing to the constructor <code>ContinuousEvent</code>, <code>DiscreteEvent</code> or other <code>SetOfEvents</code> instances:</p><pre><code class="nohighlight hljs">SetOfEvents(cb1, cb2, cb3)</code></pre><p><strong>Example</strong></p><pre><code class="nohighlight hljs"> BifurcationKit.SetOfEvents(BK.FoldDetectCB, BK.BifDetectCB)</code></pre><p>You can pass as many events as you like.</p><ul><li><p><code>eventC::Tuple</code>: Continuous event</p></li><li><p><code>eventD::Tuple</code>: Discrete event</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/events/Event.jl#L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.PairOfEvents" href="#BifurcationKit.PairOfEvents"><code>BifurcationKit.PairOfEvents</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct PairOfEvents{Tc&lt;:BifurcationKit.AbstractContinuousEvent, Td&lt;:BifurcationKit.AbstractDiscreteEvent} &lt;: BifurcationKit.AbstractEvent</code></pre><p>Structure to pass a PairOfEvents function to the continuation algorithm. It is composed of a pair ContinuousEvent / DiscreteEvent. A <code>PairOfEvents</code> is constructed by passing to the constructor a <code>ContinuousEvent</code> and a <code>DiscreteEvent</code>:</p><pre><code class="nohighlight hljs">PairOfEvents(contEvent, discreteEvent)</code></pre><p><strong>Fields</strong></p><ul><li><p><code>eventC::BifurcationKit.AbstractContinuousEvent</code>: Continuous event</p></li><li><p><code>eventD::BifurcationKit.AbstractDiscreteEvent</code>: Discrete event</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/events/Event.jl#L197">source</a></section></article><h2 id="Branch-switching-(branch-point)"><a class="docs-heading-anchor" href="#Branch-switching-(branch-point)">Branch switching (branch point)</a><a id="Branch-switching-(branch-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(branch-point)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.continuation-Tuple{BifurcationKit.AbstractResult{BifurcationKit.EquilibriumCont}, Int64, ContinuationPar}" href="#BifurcationKit.continuation-Tuple{BifurcationKit.AbstractResult{BifurcationKit.EquilibriumCont}, Int64, ContinuationPar}"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">continuation(br, ind_bif; ...)
continuation(
    br,
    ind_bif,
    options_cont;
    alg,
    δp,
    ampfactor,
    override,
    nev,
    usedeflation,
    verbosedeflation,
    max_iter_deflation,
    perturb,
    plot_solution,
    Teigvec,
    scaleζ,
    tol_fold,
    kwargs_deflated_newton,
    kwargs...
)
</code></pre><p>Automatic branch switching at branch points based on a computation of the normal form. More information is provided in <a href="../intro-abs/#Branch-switching-page">Branch switching</a>. An example of use is provided in <a href="@ref">2d generalized Bratu–Gelfand problem</a>.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br</code> from which you want to branch from</li><li><code>options_cont</code> options for the call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm to be used, default value: <code>br.alg</code></li><li><code>δp</code> used to specify a specific value for the parameter on the bifurcated branch which is otherwise determined by <code>options_cont.ds</code>. This allows to use a step larger than <code>options_cont.dsmax</code>.</li><li><code>ampfactor = 1</code> factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep. Can also be used to select the upper/lower branch in Pitchfork bifurcations. See also override below.</li><li><code>override = false</code>. If <code>override==false</code>, the normal form is computed as well as its predictor and a guess is automatically formed. If <code>override==false</code>, the parameter value <code>p = p₀ + δp</code> and the guess <code>x = x₀ + ampfactor .* e</code> (where <code>e</code> is a vector of the kernel) are used as initial guess. This is useful in case automatic branch switching does not work.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>usedeflation = false</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated</li><li><code>verbosedeflation</code> print deflated newton iterations</li><li><code>max_iter_deflation</code> number of newton steps in deflated newton</li><li><code>perturb = identity</code> which perturbation function to use during deflated newton</li><li><code>Teigvec = _getvectortype(br)</code> type of the eigenvector. Useful when <code>br</code> was loaded from a file and this information was lost</li><li><code>scaleζ = norm</code> pass a norm to normalize vectors during normal form computation</li><li><code>plot_solution</code> change plot solution method in the problem <code>br.prob</code></li><li><code>kwargs</code> optional arguments to be passed to <a href="#BifurcationKit.continuation"><code>continuation</code></a>, the regular <code>continuation</code> one and to <a href="#BifurcationKit.get_normal_form"><code>get_normal_form</code></a>.</li></ul><div class="admonition is-success"><header class="admonition-header">Advanced use</header><div class="admonition-body"><p>In the case of a very large model and use of special hardware (GPU, cluster), we suggest to discouple the computation of the reduced equation, the predictor and the bifurcated branches. Have a look at <code>methods(BifurcationKit.multicontinuation)</code> to see how to call these versions. These methods has been tested on GPU with very high memory pressure.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/bifdiagram/BranchSwitching.jl#L46">source</a></section></article><h2 id="Branch-switching-(Hopf-point)"><a class="docs-heading-anchor" href="#Branch-switching-(Hopf-point)">Branch switching (Hopf point)</a><a id="Branch-switching-(Hopf-point)-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-switching-(Hopf-point)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}" href="#BifurcationKit.continuation-Tuple{BifurcationKit.AbstractBranchResult, Int64, ContinuationPar, BifurcationKit.AbstractPeriodicOrbitProblem}"><code>BifurcationKit.continuation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">continuation(
    br,
    ind_bif,
    _contParams,
    pbPO;
    prob_vf,
    alg,
    δp,
    ampfactor,
    usedeflation,
    use_normal_form,
    autodiff_nf,
    nev,
    kwargs...
)
</code></pre><p>Perform automatic branch switching from a Hopf bifurcation point labelled <code>ind_bif</code> in the list of the bifurcated points of a previously computed branch <code>br::ContResult</code>. It first computes a Hopf normal form.</p><p><strong>Arguments</strong></p><ul><li><code>br</code> branch result from a call to <code>continuation</code></li><li><code>ind_hopf</code> index of the bifurcation point in <code>br</code></li><li><code>contParams</code> parameters for the call to <code>continuation</code></li><li><code>probPO</code> problem used to specify the way the periodic orbit is computed. It can be <a href="#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>, <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> or <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> .</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>alg = br.alg</code> continuation algorithm</li><li><code>δp</code> used to specify a particular guess for the parameter on the bifurcated branch which is otherwise determined by <code>contParams.ds</code>. This allows to use a step larger than <code>contParams.dsmax</code>.</li><li><code>ampfactor = 1</code> factor to alter the amplitude of the bifurcated solution. Useful to magnify the bifurcated solution when the bifurcated branch is very steep.</li><li><code>usedeflation = true</code> whether to use nonlinear deflation (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) to help finding the guess on the bifurcated branch</li><li><code>use_normal_form = true</code> compute the normal form to get the predictor. When <code>false</code>, <code>ampfactor</code> and <code>δp</code> are used to make a predictor based on the eigenvector. This can be useful when computing the normal form is not possible for example when higher order derivatives are not available.</li><li><code>nev</code> number of eigenvalues to be computed to get the right eigenvector</li><li><code>autodiff_nf = true</code> use <code>autodiff</code> in <code>get_normal_form</code>?</li><li>all <code>kwargs</code> from <a href="#BifurcationKit.continuation"><code>continuation</code></a></li></ul><p>A modified version of <code>prob</code> is passed to <code>plot_solution</code> and <code>finalise_solution</code>.</p><div class="admonition is-info"><header class="admonition-header">Linear solver</header><div class="admonition-body"><p>You have to be careful about the options <code>contParams.newton_options.linsolver</code>. In the case of Matrix-Free solver, you have to pass the right number of unknowns <code>N * M + 1</code>. Note that the options for the preconditioner are not accessible yet.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L353">source</a></section></article><h2 id="Bifurcation-diagram"><a class="docs-heading-anchor" href="#Bifurcation-diagram">Bifurcation diagram</a><a id="Bifurcation-diagram-1"></a><a class="docs-heading-anchor-permalink" href="#Bifurcation-diagram" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram" href="#BifurcationKit.bifurcationdiagram"><code>BifurcationKit.bifurcationdiagram</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bifurcationdiagram(
    prob,
    alg,
    level,
    options;
    linear_algo,
    kwargs...
)
</code></pre><p>Compute the bifurcation diagram associated with the problem <code>F(x, p) = 0</code> recursively.</p><p><strong>Arguments</strong></p><ul><li><code>prob::AbstractBifurcationProblem</code> bifurcation problem</li><li><code>alg</code> continuation algorithm</li><li><code>level</code> maximum branching (or recursion) level for computing the bifurcation diagram</li><li><code>options = (x, p, level) -&gt; contparams</code> this function allows to change the <a href="#BifurcationKit.continuation"><code>continuation</code></a> options depending on the branching <code>level</code>. The argument <code>x, p</code> denotes the current solution to <code>F(x, p)=0</code>.</li><li><code>kwargs</code> optional arguments. Look at <a href="#BifurcationKit.bifurcationdiagram!"><code>bifurcationdiagram!</code></a> for more details.</li></ul><p><strong>Simplified call:</strong></p><p>We also provide the method</p><p><code>bifurcationdiagram(prob, br::ContResult, level::Int, options; kwargs...)</code></p><p>where <code>br</code> is a branch computed after a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a> from which we want to compute the bifurcating branches recursively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/bifdiagram/BifurcationDiagram.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.bifurcationdiagram!" href="#BifurcationKit.bifurcationdiagram!"><code>BifurcationKit.bifurcationdiagram!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bifurcationdiagram!(
    prob,
    node,
    maxlevel,
    options;
    code,
    halfbranch,
    verbosediagram,
    kwargs...
)
</code></pre><p>Similar to <a href="#BifurcationKit.bifurcationdiagram"><code>bifurcationdiagram</code></a> but you pass a previously computed <code>node</code> from which you want to further compute the bifurcated branches. It is usually used with <code>node = get_branch(diagram, code)</code> from a previously computed bifurcation <code>diagram</code>.</p><p><strong>Arguments</strong></p><ul><li><code>node::BifDiagNode</code> a node in the bifurcation diagram</li><li><code>maxlevel = 1</code> required maximal level of recursion.</li><li><code>options = (x, p, level) -&gt; contparams</code> this function allows to change the <a href="#BifurcationKit.continuation"><code>continuation</code></a> options depending on the branching <code>level</code>. The argument <code>x, p</code> denotes the current solution to <code>F(x, p)=0</code>.</li></ul><p><strong>Optional arguments</strong></p><ul><li><code>code = &quot;0&quot;</code> code used to display iterations</li><li><code>usedeflation = false</code></li><li><code>halfbranch = false</code> for Pitchfork / Transcritical bifurcations, compute only half of the branch. Can be useful when there are symmetries.</li><li><code>verbosediagram</code> verbose specific to bifurcation diagram. Print information about the branches as they are being computed.</li><li><code>kwargs</code> optional arguments as for <a href="#BifurcationKit.continuation"><code>continuation</code></a> but also for the different versions listed in <a href="https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/library/#Continuation-1">Continuation</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/bifdiagram/BifurcationDiagram.jl#L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.get_branch" href="#BifurcationKit.get_branch"><code>BifurcationKit.get_branch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_branch(diagram, code)
</code></pre><p>Return the part of the diagram (bifurcation diagram) by recursively descending down the diagram using the <code>Int</code> valued tuple <code>code</code>. For example <code>get_branch(diagram, (1,2,3,))</code> returns <code>diagram.child[1].child[2].child[3]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/bifdiagram/BifurcationDiagram.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.get_branches_from_BP" href="#BifurcationKit.get_branches_from_BP"><code>BifurcationKit.get_branches_from_BP</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_branches_from_BP(diagram, indbif)
</code></pre><p>Return the part of the diagram corresponding to the indbif-th bifurcation point on the root branch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/bifdiagram/BifurcationDiagram.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.SpecialPoint" href="#BifurcationKit.SpecialPoint"><code>BifurcationKit.SpecialPoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SpecialPoint{T, Tp, Tv, Tvτ} &lt;: BifurcationKit.AbstractBifurcationPoint</code></pre><p>Structure to record special points on a curve. There are two types of special points that are recorded in this structure: bifurcation points and events (see https://bifurcationkit.github.io/BifurcationKitDocs.jl/dev/EventCallback/).</p><p><strong>Associated methods</strong></p><ul><li><code>BifurcationKit.type(::SpecialPoint)</code> returns the bifurcation type (<code>::Symbol</code>)</li></ul><ul><li><p><code>type::Symbol</code>: Description of the special points. In case of Events, this field records the user passed named to the event, or the default <code>:userD</code>, <code>:userC</code>. In case of bifurcation points, it can be one of the following:</p><pre><code class="nohighlight hljs">- :bp Bifurcation point, simple eigenvalue crossing the imaginary axis
- :fold Fold point
- :hopf Hopf point
- :nd not documented bifurcation point. Detected by multiple eigenvalues crossing. Generally occurs in problems with symmetries or in cases where the continuation step size is too large and merge two different bifurcation points.
- :cusp Cusp point
- :gh Generalized Hopf point (also called Bautin point)
- :bt Bogdanov-Takens point
- :zh Zero-Hopf point
- :hh Hopf-Hopf point
- :ns Neimark-Sacker point
- :pd Period-doubling point
- :R1 Strong resonance 1:1 of periodic orbits
- :R2 Strong resonance 1:2 of periodic orbits
- :R3 Strong resonance 1:3 of periodic orbits
- :R4 Strong resonance 1:4 of periodic orbits
- :foldFlip Fold / Flip of periodic orbits
- :foldNS Fold / Neimark-Sacker of periodic orbits
- :pdNS  Period-Doubling / Neimark-Sacker of periodic orbits
- :gpd Generalized Period-Doubling of periodic orbits
- :nsns Double Neimark-Sacker of periodic orbits
- :ch Chenciner bifurcation of periodic orbits
 Default: :none</code></pre></li><li><p><code>idx::Int64</code>: Index in <code>br.branch</code> or <code>br.eig</code> (see <a href="#BifurcationKit.ContResult"><code>ContResult</code></a>) for which the bifurcation occurs. Default: 0</p></li><li><p><code>param::Any</code>: Parameter value at the special point (this is an estimate). Default: 0.0</p></li><li><p><code>norm::Any</code>: Norm of the equilibrium at the special point Default: 0.0</p></li><li><p><code>printsol::Any</code>: <code>printsol = record_from_solution(x, param)</code> where <code>record_from_solution</code> is one of the arguments to <a href="#BifurcationKit.continuation"><code>continuation</code></a> Default: 0.0</p></li><li><p><code>x::Any</code>: Equilibrium at the special point Default: Vector{T}(undef, 0)</p></li><li><p><code>τ::BorderedArray{Tvτ, T} where {T, Tvτ}</code>: Tangent along the branch at the special point Default: BorderedArray(x, T(0))</p></li><li><p><code>ind_ev::Int64</code>: Eigenvalue index responsible for detecting the special point (if applicable) Default: 0</p></li><li><p><code>step::Int64</code>: Continuation step at which the special occurs Default: 0</p></li><li><p><code>status::Symbol</code>: <code>status ∈ {:converged, :guess, :guessL}</code> indicates whether the bisection algorithm was successful in detecting the special (bifurcation) point. If <code>status == :guess</code>, the bisection algorithm failed to meet the requirements given in <code>::ContinuationPar</code>. Same for <code>status == :guessL</code> but the bisection algorithm stopped on the left of the bifurcation point. Default: :guess</p></li><li><p><code>δ::Tuple{Int64, Int64}</code>: <code>δ = (δr, δi)</code> where δr indicates the change in the number of unstable eigenvalues and δi indicates the change in the number of unstable eigenvalues with nonzero imaginary part. <code>abs(δr)</code> is thus an estimate of the dimension of the kernel of the Jacobian at the special (bifurcation) point. Default: (0, 0)</p></li><li><p><code>precision::Any</code>: Precision in the location of the special point Default: -1</p></li><li><p><code>interval::Tuple{T, T} where T</code>: Interval parameter containing the special point Default: (0, 0)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/BifurcationPoints.jl#L8">source</a></section></article><h2 id="Utils-for-periodic-orbits"><a class="docs-heading-anchor" href="#Utils-for-periodic-orbits">Utils for periodic orbits</a><a id="Utils-for-periodic-orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Utils-for-periodic-orbits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.getperiod" href="#BifurcationKit.getperiod"><code>BifurcationKit.getperiod</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getperiod(, x)
getperiod(, x, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbits.jl#L18">source</a></section><section><div><pre><code class="language-julia hljs">getperiod(prob, x, p)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitTrapeze.jl#L152">source</a></section><section><div><pre><code class="language-julia hljs">getperiod(psh, x_bar, par)
</code></pre><p>Compute the period of the periodic orbit associated to <code>x_bar</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PoincareShooting.jl#L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.SectionSS" href="#BifurcationKit.SectionSS"><code>BifurcationKit.SectionSS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SectionSS{Tn, Tc} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for Section Standard Shooting) encodes a type of section implemented by a single hyperplane. It can be used in conjunction with <a href="#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a>. The hyperplane is defined by a point <code>center</code> and a <code>normal</code>.</p><ul><li><p><code>normal::Any</code>: Normal to define hyperplane</p></li><li><p><code>center::Any</code>: Representative point on hyperplane</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/Sections.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.SectionPS" href="#BifurcationKit.SectionPS"><code>BifurcationKit.SectionPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct SectionPS{Tn, Tc, Tnb, Tcb, Tr} &lt;: BifurcationKit.AbstractSection</code></pre><p>This composite type (named for SectionPoincaréShooting) encodes a type of Poincaré sections implemented by hyperplanes. It can be used in conjunction with <a href="#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a>. Each hyperplane is defined par a point (one example in <code>centers</code>) and a normal (one example in <code>normals</code>).</p><ul><li><p><code>M::Int64</code></p></li><li><p><code>normals::Any</code></p></li><li><p><code>centers::Any</code></p></li><li><p><code>indices::Vector{Int64}</code></p></li><li><p><code>normals_bar::Any</code></p></li><li><p><code>centers_bar::Any</code></p></li><li><p><code>radius::Any</code></p></li></ul><p><strong>Constructor(s)</strong></p><pre><code class="nohighlight hljs">SectionPS(normals::Vector{Tv}, centers::Vector{Tv})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/Sections.jl#L63">source</a></section></article><h2 id="Misc."><a class="docs-heading-anchor" href="#Misc.">Misc.</a><a id="Misc.-1"></a><a class="docs-heading-anchor-permalink" href="#Misc." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurKrylovKit" href="#BifurcationKit.PrecPartialSchurKrylovKit"><code>BifurcationKit.PrecPartialSchurKrylovKit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrecPartialSchurKrylovKit(J, x0, nev, which = :LM; krylovdim = max(2nev, 20), verbosity = 0)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>KrylovKit.jl</code>, from which a projection is built. The options are similar to the ones of <code>EigKrylovKit()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Preconditioner.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.PrecPartialSchurArnoldiMethod" href="#BifurcationKit.PrecPartialSchurArnoldiMethod"><code>BifurcationKit.PrecPartialSchurArnoldiMethod</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrecPartialSchurArnoldiMethod(J, N, nev, which = LM(); tol = 1e-9, kwargs...)</code></pre><p>Builds a preconditioner based on deflation of <code>nev</code> eigenvalues chosen according to <code>which</code>. A partial Schur decomposition is computed (Matrix-Free), using the package <code>ArnoldiMethod.jl</code>, from which a projection is built. See the package <code>ArnoldiMethod.jl</code> for how to pass the proper options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/Preconditioner.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.Flow" href="#BifurcationKit.Flow"><code>BifurcationKit.Flow</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Flow{TF, Tf, Tts, Tff, Td, Tad, Tse, Tprob, TprobMono, Tfs, Tcb, Tδ} &lt;: BifurcationKit.AbstractFlow</code></pre><ul><li><p><code>F::Any</code>: The vector field <code>(x, p) -&gt; F(x, p)</code> associated to a Cauchy problem. Used for the differential of the shooting problem. Default: nothing</p></li><li><p><code>flow::Any</code>: The flow (or semigroup) <code>(x, p, t) -&gt; flow(x, p, t)</code> associated to the Cauchy problem. Only the last time point must be returned in the form (u = ...) Default: nothing</p></li><li><p><code>flowTimeSol::Any</code>: Flow which returns the tuple (t, u(t)). Optional, mainly used for plotting on the user side. Default: nothing</p></li><li><p><code>flowFull::Any</code>: [Optional] The flow (or semigroup) associated to the Cauchy problem <code>(x, p, t) -&gt; flow(x, p, t)</code>. The whole solution on the time interval [0,t] must be returned. It is not strictly necessary to provide this, it is mainly used for plotting on the user side. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>jvp::Any</code>: The differential <code>dflow</code> of the flow <em>w.r.t.</em> <code>x</code>, <code>(x, p, dx, t) -&gt; dflow(x, p, dx, t)</code>. One important thing is that we require <code>dflow(x, dx, t)</code> to return a Named Tuple: <code>(t = t, u = flow(x, p, t), du = dflow(x, p, dx, t))</code>, the last component being the value of the derivative of the flow. Default: nothing</p></li><li><p><code>vjp::Any</code>: The adjoint differential <code>vjpflow</code> of the flow <em>w.r.t.</em> <code>x</code>, <code>(x, p, dx, t) -&gt; vjpflow(x, p, dx, t)</code>. One important thing is that we require <code>vjpflow(x, p, dx, t)</code> to return a Named Tuple: <code>(t = t, u = flow(x, p, t), du = vjpflow(x, p, dx, t))</code>, the last component being the value of the derivative of the flow. Default: nothing</p></li><li><p><code>jvpSerial::Any</code>: [Optional] Serial version of dflow. Used internally when using parallel multiple shooting. Please use <code>nothing</code> as default. Default: nothing</p></li><li><p><code>prob::Any</code>: [Internal] store the ODEProblem associated to the flow of the Cauchy problem Default: nothing</p></li><li><p><code>probMono::Any</code>: [Internal] store the ODEProblem associated to the flow of the variational problem Default: nothing</p></li><li><p><code>flowSerial::Any</code>: [Internal] Serial version of the flow Default: nothing</p></li><li><p><code>callback::Any</code>: [Internal] Store possible callback Default: nothing</p></li><li><p><code>delta::Any</code>: [Internal] Default: 1.0e-8</p></li></ul><p><strong>Simplified constructor(s)</strong></p><p>We provide a simple constructor where you only pass the vector field <code>F</code>, the flow <code>ϕ</code> and its differential <code>dϕ</code>:</p><pre><code class="nohighlight hljs">fl = Flow(F, ϕ, dϕ)</code></pre><p><strong>Simplified constructors for DifferentialEquations.jl</strong></p><p>These are some simple constructors for which you only have to pass a <code>prob::ODEProblem</code> or <code>prob::EnsembleProblem</code> (for parallel computation) from <code>DifferentialEquations.jl</code> and an ODE time stepper like <code>Tsit5()</code>. Hence, you can do for example</p><pre><code class="nohighlight hljs">fl = Flow(prob, Tsit5(); kwargs...)</code></pre><p>where <code>kwargs</code> is passed to <code>SciMLBase::solve</code>. If your vector field depends on parameters <code>p</code>, you can define a <code>Flow</code> using</p><pre><code class="nohighlight hljs">fl = Flow(prob, Tsit5(); kwargs...)</code></pre><p>Finally, you can pass two <code>ODEProblem</code> where the second one is used to compute the variational equation:</p><pre><code class="nohighlight hljs">fl = Flow(prob1::ODEProblem, alg1, prob2::ODEProblem, alg2; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/Flow.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.FloquetQaD" href="#BifurcationKit.FloquetQaD"><code>BifurcationKit.FloquetQaD</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">floquet = FloquetQaD(eigsolver::AbstractEigenSolver)</code></pre><p>This composite type implements the computation of the eigenvalues of the monodromy matrix in the case of periodic orbits problems (based on the Shooting method or Finite Differences (Trapeze method)), also called the Floquet multipliers. The method, dubbed Quick and Dirty (QaD), is not numerically very precise for large / small Floquet exponents when the number of time sections is large because of many matrix products. It allows, nevertheless, to detect bifurcations. The arguments are as follows:</p><ul><li><code>eigsolver::AbstractEigenSolver</code> solver used to compute the eigenvalues.</li></ul><p>If <code>eigsolver == DefaultEig()</code>, then the monodromy matrix is formed and its eigenvalues are computed. Otherwise, a Matrix-Free version of the monodromy is used.</p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver <code>eigsolver</code> needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of <code>eigsolver</code>. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/Floquet.jl#L20-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.guess_from_hopf" href="#BifurcationKit.guess_from_hopf"><code>BifurcationKit.guess_from_hopf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">guess_from_hopf(
    br,
    ind_hopf,
    eigsolver,
    M,
    amplitude;
    phase
)
</code></pre><p>This function returns several useful quantities regarding a Hopf bifurcation point. More precisely, it returns:</p><ul><li>the parameter value at which a Hopf bifurcation occurs</li><li>the period of the bifurcated periodic orbit</li><li>a guess for the bifurcated periodic orbit</li><li>the equilibrium at the Hopf bifurcation point</li><li>the eigenvector at the Hopf bifurcation point.</li></ul><p>The arguments are</p><ul><li><code>br</code>: the continuation branch which lists the Hopf bifurcation points</li><li><code>ind_hopf</code>: index of the bifurcation branch, as in <code>br.specialpoint</code></li><li><code>eigsolver</code>: the eigen solver used to find the eigenvectors</li><li><code>M</code> number of time slices in the periodic orbit guess</li><li><code>amplitude</code>: amplitude of the periodic orbit guess</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/PeriodicOrbitUtils.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BifurcationKit.get_normal_form" href="#BifurcationKit.get_normal_form"><code>BifurcationKit.get_normal_form</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_normal_form(
    prob,
    br,
    id_bif;
    nev,
    verbose,
    ζs,
    ζs_ad,
    lens,
    Teigvec,
    scaleζ,
    detailed,
    autodiff,
    bls,
    bls_adjoint,
    bls_block
)
</code></pre><p>Compute the normal form of the bifurcation point located at <code>br.specialpoint[ind_bif]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prob::AbstractBifurcationProblem</code></li><li><code>br</code> result from a call to <a href="#BifurcationKit.continuation"><code>continuation</code></a></li><li><code>ind_bif</code> index of the bifurcation point in <code>br.specialpoint</code></li></ul><p><strong>Optional arguments</strong></p><ul><li><code>nev</code> number of eigenvalues used to compute the spectral projection. This number has to be adjusted when used with iterative methods.</li><li><code>verbose</code> whether to display information</li><li><code>ζs</code> list of vectors spanning the kernel of <code>dF</code> at the bifurcation point. Useful to enforce the basis for the normal form.</li><li><code>lens::Lens</code> specify which parameter to take the partial derivative ∂pF</li><li><code>scaleζ</code> function to normalise the kernel basis. Indeed, when used with large vectors and <code>norm</code>, it results in ζs and the normal form coefficient being super small.</li><li><code>autodiff = true</code> whether to use ForwardDiff for the differentiations w.r.t the parameters that are required to compute the normal form. Used for example for Bogdanov-Takens point. You can set to <code>autodiff = false</code> if you wish.</li><li><code>detailed = true</code> whether to compute only a simplified normal form. Used for example for Bogdanov-Takens point.</li><li><code>bls = MatrixBLS()</code> specify Bordered linear solver. Used for example for Bogdanov-Takens point.</li><li><code>bls_adjoint = bls</code> specify Bordered linear solver for the adjoint problem.</li><li><code>bls_block = bls</code> specify Bordered linear solver when the border has dimension 2 (1 for <code>bls</code>).</li></ul><p><strong>Available method</strong></p><p>You can directly call </p><pre><code class="nohighlight hljs">get_normal_form(br, ind_bif ; kwargs...)</code></pre><p>which is a shortcut for <code>get_normal_form(getprob(br), br, ind_bif ; kwargs...)</code>.</p><p>Once the normal form <code>nf</code> has been computed, you can call <code>predictor(nf, δp)</code> to obtain an estimate of the bifurcating branch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/NormalForms.jl#L436">source</a></section><section><div><pre><code class="language-julia hljs">get_normal_form(
    prob,
    br,
    id_bif;
    nev,
    verbose,
    ζs,
    lens,
    Teigvec,
    scaleζ,
    prm,
    autodiff,
    detailed,
    δ,
    k...
)
</code></pre><p>Compute the normal form (NF) of periodic orbits. We detail the additional keyword arguments specific to periodic orbits</p><p><strong>Optional arguments</strong></p><ul><li><code>prm = true</code> compute the normal form using Poincaré return map (PRM). If false, use the Iooss normal form. </li><li><code>nev = length(eigenvalsfrombif(br, id_bif))</code>,</li><li><code>verbose = false</code>,</li><li><code>ζs = nothing</code>, pass the eigenvectors</li><li><code>lens = getlens(br)</code>,</li><li><code>Teigvec = _getvectortype(br)</code> type of the eigenvectors (can be useful for GPU)</li><li><code>scaleζ = norm</code>, scale the eigenvector</li><li><code>prm = true</code> NF based on Poincare return map (<code>prm=true</code>) or Iooss&#39; method.</li><li><code>autodiff = false</code> use autodiff or finite differences in some part of the normal form computation</li><li><code>detailed = true</code> to get detailed normal form</li><li><code>δ = getdelta(prob)</code> delta used for finite differences</li></ul><p><strong>Notes</strong></p><p>For collocation, the default method to compute the NF of Period-doubling and Neimark-Sacker bifurcations is Iooss&#39; method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bifurcationkit/BifurcationKit.jl/blob/v0.4.10/src/periodicorbit/NormalForms.jl#L1">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../migration/">« Migration from old versions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Saturday 29 March 2025 15:03">Saturday 29 March 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
