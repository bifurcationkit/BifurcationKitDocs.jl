<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fold / Hopf Continuation (2 params) · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../capabilities/">Overview of capabilities</a></li><li><a class="tocitem" href="../tutorials/tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Basics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../guidelines/">Guidelines</a></li><li><a class="tocitem" href="../educational/">Educational introduction</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../plotting/">Plot functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Problems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../BifProblem/">Bifurcation Problem</a></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Trapezoid</a></li><li><a class="tocitem" href="../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../intro_wave/">Introduction</a></li><li><a class="tocitem" href="../waveEigen/">Eigen Solvers</a></li><li><a class="tocitem" href="../ModulatedTW/">Modulated Travelling waves</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore-Penrose continuation</a></li><li><a class="tocitem" href="../ANM/">ANM</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated continuation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-7-1" type="checkbox"/><label class="tocitem" for="menuitem-7-1"><span class="docs-label">Nonlinear equations (Newton)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../newton/">Krylov-Newton algorithm</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-2" type="checkbox" checked/><label class="tocitem" for="menuitem-7-2"><span class="docs-label">Bifurcations (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (1 param)</a></li><li class="is-active"><a class="tocitem" href>Fold / Hopf Continuation (2 params)</a><ul class="internal"><li><a class="tocitem" href="#Fold-continuation"><span>Fold continuation</span></a></li><li><a class="tocitem" href="#Hopf-continuation"><span>Hopf continuation</span></a></li><li><a class="tocitem" href="#jac-fold"><span>Setting the jacobian</span></a></li><li><a class="tocitem" href="#Newton-refinement"><span>Newton refinement</span></a></li><li><a class="tocitem" href="#Codim-2-continuation"><span>Codim 2 continuation</span></a></li><li><a class="tocitem" href="#Advanced-use"><span>Advanced use</span></a></li><li><a class="tocitem" href="#Algorithmic-details-(Fold)"><span>Algorithmic details (Fold)</span></a></li><li><a class="tocitem" href="#Algorithmic-details-(Hopf)"><span>Algorithmic details (Hopf)</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../codim3Continuation/">Bogdanov-Takens refinement (3 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-3" type="checkbox"/><label class="tocitem" for="menuitem-7-3"><span class="docs-label">Bifurcations (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../detectionBifurcationPO/">Bifurcation detection (1 param)</a></li><li><a class="tocitem" href="../FoldContinuationPO/">Fold continuation (2 params)</a></li><li><a class="tocitem" href="../PDContinuationPO/">Period-Doubling continuation (2 params)</a></li><li><a class="tocitem" href="../NSContinuationPO/">Neimark-Sacker continuation (2 params)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-4" type="checkbox"/><label class="tocitem" for="menuitem-7-4"><span class="docs-label">Normal form (equilibria)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf</a></li><li><a class="tocitem" href="../cusp/">Cusp</a></li><li><a class="tocitem" href="../bt/">Bogdanov-Takens</a></li><li><a class="tocitem" href="../bautin/">Bautin</a></li><li><a class="tocitem" href="../zh/">Zero-Hopf</a></li><li><a class="tocitem" href="../hh/">Hopf-Hopf</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7-5" type="checkbox"/><label class="tocitem" for="menuitem-7-5"><span class="docs-label">Normal form (periodic orbits)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../pd/">Period-doubling</a></li><li><a class="tocitem" href="../ns/">Neimarck-Sacker</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../EventCallback/">Event handling and Callback</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">Contributing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-9-1" type="checkbox"/><label class="tocitem" for="menuitem-9-1"><span class="docs-label">Interfaces</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../interfaceLS/">Vector</a></li><li><a class="tocitem" href="../interfaceLS/">Linear / eigen Solvers</a></li><li><a class="tocitem" href="../interfacePred/">Predictor / corrector</a></li><li><a class="tocitem" href="../interfaceFlow/">Flow</a></li></ul></li></ul></li><li><a class="tocitem" href="../faq/">Frequently asked questions</a></li><li><a class="tocitem" href="../migration/">Migration to v0.2.x</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functionalities</a></li><li><a class="is-disabled">Bifurcations (equilibria)</a></li><li class="is-active"><a href>Fold / Hopf Continuation (2 params)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fold / Hopf Continuation (2 params)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bifurcationkit/BifurcationKitDocs.jl/blob/main/docs/src/codim2Continuation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fold-/-Hopf-Continuation"><a class="docs-heading-anchor" href="#Fold-/-Hopf-Continuation">Fold / Hopf Continuation</a><a id="Fold-/-Hopf-Continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Fold-/-Hopf-Continuation" title="Permalink"></a></h1><ul><li><a href="#Fold-/-Hopf-Continuation">Fold / Hopf Continuation</a></li><li class="no-marker"><ul><li><a href="#Fold-continuation">Fold continuation</a></li><li><a href="#Hopf-continuation">Hopf continuation</a></li><li><a href="#jac-fold">Setting the jacobian</a></li><li><a href="#Newton-refinement">Newton refinement</a></li><li><a href="#Codim-2-continuation">Codim 2 continuation</a></li><li><a href="#Advanced-use">Advanced use</a></li><li><a href="#Algorithmic-details-(Fold)">Algorithmic details (Fold)</a></li><li><a href="#Algorithmic-details-(Hopf)">Algorithmic details (Hopf)</a></li><li><a href="#References">References</a></li></ul></li></ul><p>In this page, we explain how to perform continuation of Fold / Hopf points and detect the associated bifurcations.</p><p>For this to work best, it is advised to have an analytical expression for the jacobian. See the tutorial <a href="../tutorials/tutorials1/#Temperature-model-(Simplest-example)">Temperature model (Simplest example)</a> for more details.</p><p>A quite complete example for detection of codim 2 bifurcations of equilibria is <a href="../tutorials/ode/lorenz84/#lorenz">Extended Lorenz-84 model (codim 2 + BT/ZH aBS)</a> although it is for ODEs.</p><h3 id="List-of-detected-codim-2-bifurcation-points"><a class="docs-heading-anchor" href="#List-of-detected-codim-2-bifurcation-points">List of detected codim 2 bifurcation points</a><a id="List-of-detected-codim-2-bifurcation-points-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-detected-codim-2-bifurcation-points" title="Permalink"></a></h3><table><tr><th style="text-align: right">Bifurcation</th><th style="text-align: right">symbol used</th></tr><tr><td style="text-align: right">Bogdanov-Takens</td><td style="text-align: right">bt</td></tr><tr><td style="text-align: right">Bautin</td><td style="text-align: right">gh</td></tr><tr><td style="text-align: right">Cusp</td><td style="text-align: right">cusp</td></tr><tr><td style="text-align: right">Zero-Hopf</td><td style="text-align: right">zh</td></tr><tr><td style="text-align: right">Hopf-Hopf</td><td style="text-align: right">hh</td></tr></table><p>In a nutshell, all you have to do (see below) is to call <code>continuation(br, ind_bif, lens2)</code> to continue the bifurcation point stored in <code>br.specialpoint[ind_bif]</code> and set proper options.</p><h2 id="Fold-continuation"><a class="docs-heading-anchor" href="#Fold-continuation">Fold continuation</a><a id="Fold-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Fold-continuation" title="Permalink"></a></h2><p>The continuation of Fold bifurcation points is based on a <strong>Minimally Augmented</strong><sup class="footnote-reference"><a id="citeref-Govaerts" href="#footnote-Govaerts">[Govaerts]</a></sup> formulation which is an efficient way to detect singularities. The continuation of Fold points is based on the formulation</p><p class="math-container">\[G(u,p) = (F(u,p), \sigma(u,p))\in\mathbb R^{n+1}\quad\quad (F_f)\]</p><p>where the test function <span>$g$</span> is solution of</p><p class="math-container">\[\left[\begin{array}{cc}
dF(u,p) &amp; w \\
v^{\top} &amp; 0
\end{array}\right]\left[\begin{array}{c}
r \\
\sigma(u,p)
\end{array}\right]=\left[\begin{array}{c}0_{n} \\1\end{array}\right]\quad\quad (M_f)\]</p><p>where <span>$w,v$</span> are chosen in order to have a non-singular matrix <span>$(M_f)$</span>. More precisely, <span>$v$</span> (resp. <span>$w$</span>) should be close to a null vector of <code>dF(u,p)</code> (resp. <code>dF(u,p)&#39;</code>). During continuation, the vectors <span>$w,v$</span> are updated so that the matrix <span>$(M_f)$</span> remains non-singular ; this is controlled with the argument <code>update_minaug_every_step</code> (see below).</p><blockquote><p>note that there are very simplified calls for this, see <strong>Newton refinement</strong> below. In particular, you don&#39;t need to set up the Fold Minimally Augmented problem yourself. This is done in the background.</p></blockquote><div class="admonition is-warning"><header class="admonition-header">Linear Method</header><div class="admonition-body"><p>You can pass the bordered linear solver to solve <span>$(M_f)$</span> using the option <code>bdlinsolver</code> (see below). Note that the choice <code>bdlinsolver = BorderingBLS()</code> can lead to singular systems. Indeed, in this case, <span>$(M_f)$</span> is solved by inverting <code>dF(u,p)</code> which is singular at Fold points.</p></div></div><h3 id="Detection-of-codim-2-bifurcation-points"><a class="docs-heading-anchor" href="#Detection-of-codim-2-bifurcation-points">Detection of codim 2 bifurcation points</a><a id="Detection-of-codim-2-bifurcation-points-1"></a><a class="docs-heading-anchor-permalink" href="#Detection-of-codim-2-bifurcation-points" title="Permalink"></a></h3><p>You can detect the following codim 2 bifurcation points by using the option <code>detect_codim2_bifurcation</code> in the method <code>continuation</code>. Under the hood, the detection of these bifurcations is done by using Event detection as explained in <a href="../EventCallback/#Event-Handling">Event Handling</a>.</p><ul><li>the detection of Cusp (Cusp) is done by the detection of Fold bifurcation points along the curve of Folds by monitoring the parameter component of the tangent.</li><li>the detection of Bogdanov-Takens (BT) is performed using the test function<sup class="footnote-reference"><a id="citeref-Bindel" href="#footnote-Bindel">[Bindel]</a></sup> <span>$\psi_{BT}(p) = \langle w(p),v(p)\rangle$</span></li><li>the detection of Zero-Hopf (ZH) is performed by monitoring the number of eigenvalues <span>$\lambda$</span> such that <span>$\Re\lambda &gt; \min\limits_{\nu\in\Sigma(dF)}|\Re\nu|$</span> and <span>$\Im\lambda &gt; \epsilon$</span> where <span>$\epsilon$</span> is the Newton tolerance.</li></ul><h2 id="Hopf-continuation"><a class="docs-heading-anchor" href="#Hopf-continuation">Hopf continuation</a><a id="Hopf-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Hopf-continuation" title="Permalink"></a></h2><p>The continuation of Fold bifurcation points is based on a <strong>Minimally Augmented</strong> (see <sup class="footnote-reference"><a id="citeref-Govaerts" href="#footnote-Govaerts">[Govaerts]</a></sup> p. 87) formulation which is an efficient way to detect singularities. The continuation of Hopf points is based on the formulation</p><p class="math-container">\[G(u,\omega,p) = (F(u,\omega,p), \Re\sigma(u,\omega,p), \Im\sigma(u,\omega,p))\in\mathbb R^{n+2}\quad\quad (F_h)\]</p><p>where the test function <span>$g$</span> is solution of</p><p class="math-container">\[\left[\begin{array}{cc}
dF(u,p)-i\omega I_n &amp; w \\
v^{\top} &amp; 0
\end{array}\right]\left[\begin{array}{c}
r \\
\sigma(u,\omega,p)
\end{array}\right]=\left[\begin{array}{c}
0_{n} \\
1
\end{array}\right]\quad\quad (M_h)\]</p><p>where <span>$w,v$</span> are chosen in order to have a non-singular matrix <span>$(M_h)$</span>. More precisely, <span>$w$</span> (resp. <span>$v$</span>) should be a left (resp. right) approximate null vector of <span>$dF(u,p)-i\omega I_n$</span>. During continuation, the vectors <span>$w,v$</span> are updated so that the matrix <span>$(M_h)$</span> remains non-singular ; this is controlled with the argument <code>update_minaug_every_step</code> (see below).</p><blockquote><p>note that there are very simplified calls to this, see <strong>Newton refinement</strong> below. In particular, you don&#39;t need to set up the Hopf Minimally Augmented problem yourself. This is done in the background.</p></blockquote><div class="admonition is-warning"><header class="admonition-header">Linear Method</header><div class="admonition-body"><p>You can pass the bordered linear solver to solve <span>$(M_h)$</span> using the option <code>bdlinsolver</code> (see below). Note that the choice <code>bdlinsolver = BorderingBLS()</code> can lead to singular systems. Indeed, in this case, <span>$(M_h)$</span> is solved by inverting <code>dF(u,p)-iω I_n</code> which is singular at Hopf points.</p></div></div><h3 id="Detection-of-codim-2-bifurcation-points-2"><a class="docs-heading-anchor" href="#Detection-of-codim-2-bifurcation-points-2">Detection of codim 2 bifurcation points</a><a class="docs-heading-anchor-permalink" href="#Detection-of-codim-2-bifurcation-points-2" title="Permalink"></a></h3><p>You can detect the following codim 2 bifurcation points by using the option <code>detect_codim2_bifurcation</code> in the method <code>continuation</code>. Under the hood, the detection of these bifurcations is done by using Event detection as explained in <a href="../EventCallback/#Event-Handling">Event Handling</a>.</p><ul><li>the detection of Bogdanov-Takens (BT) is performed using the test function<sup class="footnote-reference"><a id="citeref-Bindel" href="#footnote-Bindel">[Bindel]</a></sup>,<sup class="footnote-reference"><a id="citeref-Blank" href="#footnote-Blank">[Blank]</a></sup> <span>$\psi_{BT}(p) = 	\langle w(p),v(p)\rangle$</span></li><li>the detection of Bautin (GH) is based on the test function <span>$\psi_{GH}(p) = \Re(l_1(p))$</span> where <span>$l_1$</span> is the Lyapunov coefficient defined in <a href="../simplehopf/#Simple-Hopf-point">Simple Hopf point</a>.</li><li>the detection of Zero-Hopf (ZH) is performed by monitoring the eigenvalues.</li><li>the detection of Hopf-Hopf (HH) is performed by monitoring the eigenvalues.</li></ul><blockquote><p>The continuation of Hopf points is stopped at BT and when <span>$\omega&lt;100\epsilon$</span> where <span>$\epsilon$</span> is the newton tolerance.</p></blockquote><h2 id="jac-fold"><a class="docs-heading-anchor" href="#jac-fold">Setting the jacobian</a><a id="jac-fold-1"></a><a class="docs-heading-anchor-permalink" href="#jac-fold" title="Permalink"></a></h2><p>In order to apply the newton algorithm to <span>$F_f$</span> or <span>$F_h$</span>, one needs to invert the jacobian. This is not completely trivial as one must compute this jacobian and then invert it. You can select the following jacobians for your computations (see below):</p><ul><li>[Default] for <code>jacobian_ma = :autodiff</code>, automatic differentiation is applied to <span>$F_f$</span> (or <span>$F_h$</span>) and the matrix is then inverted using the provided linear solver. In particular, the jacobian is formed. This is very well suited for small dimensions  (say &lt; 100)</li><li>for <code>jacobian_ma = :minaug</code>, a specific procedure for evaluating the jacobian <span>$F_f$</span> (or <span>$F_h$</span>) and inverting it (without forming the jacobian!) is used. This is well suited for large dimensions.</li></ul><h2 id="Newton-refinement"><a class="docs-heading-anchor" href="#Newton-refinement">Newton refinement</a><a id="Newton-refinement-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-refinement" title="Permalink"></a></h2><p>Once a Fold / Hopf point has been detected after a call to <code>br = continuation(...)</code>, it can be refined using <code>newton</code> iterations. Let us say that <code>ind_bif</code> is the index in <code>br.specialpoint</code> of a Fold / Hopf point. This guess can be refined as follows:</p><pre><code class="language-julia hljs">outfold = newton(br::AbstractBranchResult, ind_bif::Int;  
	normN = norm, options = br.contparams.newton_options,
	bdlinsolver = BorderingBLS(options.linsolver),
	start_with_eigen = false, kwargs...)</code></pre><p>For the options parameters, we refer to <a href="../library/#Newton">Newton</a>.</p><p>It is important to note that for improved performances, a function implementing the expression of the <strong>hessian</strong> should be provided. This is by far the fastest. Reader interested in this advanced usage should look at the code <code>example/chan.jl</code> of the tutorial <a href="../tutorials/tutorials1/#Temperature-model-(Simplest-example)">Temperature model (Simplest example)</a>.</p><h2 id="Codim-2-continuation"><a class="docs-heading-anchor" href="#Codim-2-continuation">Codim 2 continuation</a><a id="Codim-2-continuation-1"></a><a class="docs-heading-anchor-permalink" href="#Codim-2-continuation" title="Permalink"></a></h2><p>To compute the codim 2 curve of Fold / Hopf points, one can call <a href="../library/#BifurcationKit.continuation"><code>continuation</code></a> with the following options</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>continuation(br::BifurcationKit.AbstractBranchResult, ind_bif::Int64, 				lens2::Lens, options_cont::ContinuationPar = br.contparams ; 				kwargs...)</code>. Check Documenter&#39;s build log for details.</p></div></div><p>where the options are as above except with have an additional parameter axis <code>lens2</code> which is used to locate the bifurcation points.</p><p>See <a href="../tutorials/tutorials1/#Temperature-model-(Simplest-example)">Temperature model (Simplest example)</a> for an example of use.</p><h2 id="Advanced-use"><a class="docs-heading-anchor" href="#Advanced-use">Advanced use</a><a id="Advanced-use-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-use" title="Permalink"></a></h2><p>Here, we expose the solvers that are used to perform newton refinement or codim 2 continuation in case the above methods fails. This is useful in case it is too involved to expose the linear solver options. An example of advanced use is the continuation of Folds of periodic orbits, see <a href="../FoldContinuationPO/#fold-po">Continuation of Fold of periodic orbits</a>.</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>newtonFold</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>newtonHopf</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>continuationFold</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>continuationHopf</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Algorithmic-details-(Fold)"><a class="docs-heading-anchor" href="#Algorithmic-details-(Fold)">Algorithmic details (Fold)</a><a id="Algorithmic-details-(Fold)-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithmic-details-(Fold)" title="Permalink"></a></h2><p>If we write <span>$(s,\sigma)$</span> the solution of the adjoint problem associated to <span>$(M_f)$</span>, one can show<sup class="footnote-reference"><a id="citeref-Govaerts" href="#footnote-Govaerts">[Govaerts]</a></sup> that the differential of <span>$\sigma$</span> satisfies: $ \partial \sigma + \langle s,\partial dF \cdot r\rangle = 0 $ This allows to compute the jacobian of the Fold functional to use for the Newton algorithm</p><p class="math-container">\[\left[\begin{array}{cc}
\partial_{u}F(u,p) &amp; \partial_pF(u,p) \\
\partial_x\sigma(u,p) &amp; \partial_p\sigma(u,p)
\end{array}\right].\]</p><h2 id="Algorithmic-details-(Hopf)"><a class="docs-heading-anchor" href="#Algorithmic-details-(Hopf)">Algorithmic details (Hopf)</a><a id="Algorithmic-details-(Hopf)-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithmic-details-(Hopf)" title="Permalink"></a></h2><p>We recall that the unknowns are <span>$(x,p,\omega)$</span>. The jacobian of the Hopf functional to use for the Newton algorithm</p><p class="math-container">\[\left[\begin{array}{ccc}
\partial_{u}F &amp; \partial_pF &amp; 0 \\
\partial_x\sigma_r &amp; \partial_p\sigma_r &amp; \partial_\omega\sigma_r\\
\partial_x\sigma_i &amp; \partial_p\sigma_i &amp; \partial_\omega\sigma_i
\end{array}\right].\]</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Govaerts"><a class="tag is-link" href="#citeref-Govaerts">Govaerts</a><blockquote><p>Govaerts, Willy J. F. Numerical Methods for Bifurcations of Dynamical Equilibria. Philadelphia, Pa: Society for Industrial and Applied Mathematics, 2000.</p></blockquote></li><li class="footnote" id="footnote-Blank"><a class="tag is-link" href="#citeref-Blank">Blank</a><blockquote><p>Blank, H. J. de, Yu. A. Kuznetsov, M. J. Pekkér, and D. W. M. Veldman. “Degenerate Bogdanov–Takens Bifurcations in a One-Dimensional Transport Model of a Fusion Plasma.” Physica D: Nonlinear Phenomena 331 (September 15, 2016): 13–26. https://doi.org/10.1016/j.physd.2016.05.008.</p></blockquote></li><li class="footnote" id="footnote-Bindel"><a class="tag is-link" href="#citeref-Bindel">Bindel</a><blockquote><p>Bindel, D., M. Friedman, W. Govaerts, J. Hughes, and Yu.A. Kuznetsov. “Numerical Computation of Bifurcations in Large Equilibrium Systems in Matlab.” Journal of Computational and Applied Mathematics 261 (May 2014): 232–48. https://doi.org/10.1016/j.cam.2013.10.034.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../detectionBifurcation/">« Bifurcation detection (1 param)</a><a class="docs-footer-nextpage" href="../codim3Continuation/">Bogdanov-Takens refinement (3 params) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 25 September 2023 14:56">Monday 25 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
